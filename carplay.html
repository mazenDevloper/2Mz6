
<!DOCTYPE html>
<html lang="ar" dir="rtl" style="
    
">
<head>
    <link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#000000">
 
<!-- ŸÑÿ™ÿ∫ÿ∑Ÿäÿ© ÿßŸÑÿ¥ÿßÿ¥ÿ© ÿ®ÿßŸÑŸÉÿßŸÖŸÑ ŸÖÿπ ÿ≠ŸàÿßŸÅ ÿßŸÑŸÜŸàÿ™ÿ¥ -->
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Cache Control Meta Tags -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>CarPlay</title>
    <!-- Tailwind CSS CDN for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons for modern, customizable SVG icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Font Awesome for additional icons (e.g., Trip log) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    <!-- Chart.js for the new weekly forecast chart -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- YouTube Iframe API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    <link 
        rel="stylesheet" 
        href="https://dmusera.netlify.app/carplay.css" 
        media="print" 
        onload="this.media='all'"
    >
    <style>
        /* Import Amiri Quran font for Adhkar text */
        @import url('https://fonts.googleapis.com/css2?family=Amiri+Quran:wght@400;700&display=swap');
        /* NEW: Import Amiri font for Thuluth-like style */
        @import url('https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&display=swap');

/* --- START: Last Watched & History Styles --- */
/* --- START: Fullscreen Toggle Button Styles --- */

.fullscreen-toggle-button {
    /* Positioning the button inside the section, usually top right */
    position: absolute; 
    bottom: 1rem;
    left: 1rem;
    z-index: 99; /* Ensure it's above content but below floating buttons (like popup video) */
    
    /* Aesthetic styling (can be adjusted to match your glass-surface style) */
    background-color: rgba(255, 255, 255, 0.1); 
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    backdrop-filter: blur(5px);
    transition: all 0.3s ease;
}

.fullscreen-toggle-button:hover {
    background-color: rgba(255, 255, 255, 0.2);
    transform: scale(1.1);
}


#quran-go-button,#fullscreen-reciters-iframe-btn,#fullscreen-radio-iframe-btn{
    z-index:999;
}
/* CRITICAL: The class that forces the section to cover the viewport 
*/
.is-fullscreen {
    /* Overrides parent containers and positions relative to the viewport */
    position: fixed !important; 
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    margin: 0 !important;
    z-index: 100 !important; /* Must be high to cover everything else */
    border-radius: 0 !important; /* Removes rounded corners for a true fullscreen feel */
    overflow-y: auto !important; /* Ensure content remains scrollable if needed */
    transition: all 0.5s ease-in-out; /* Smooth transition for the effect */
}

/* Optional: Hide the navigation bar when a screen is fullscreen */
body.fullscreen-mode nav {
    display: none !important; 
}

section#screen-Reciters {
    HEIGHT: 100% ! IMPORTANT;
    PADDING: 1px;
    MARGIN: 0px;
}
/* --- START: Last Watched Carousel (2.5 items) Styles --- */
#last-watched-container {
    width: 100%;
    max-width: 600px; /* Optional: constrain max width for larger screens */
  
    padding-bottom: 1rem;
    margin-bottom: 1rem;
}
 .tabs-container.flex.p-1.rounded-full.bg-black\/20.self-center {
    bottom: 51px!important;
    left: 99px!important;
    position: fixed!important;
     z-index: 1000!important;
}
.iframe-src-button.active {
  background-color: #a855f7; /* Brighter purple for active */
  box-shadow: 0 0 10px rgba(168, 85, 247, 0.7);
}
.flex.gap-2.mt-2.homebtn {
    display: none;
}
button#video-popup-bookmark-button {
    position: fixed;
    left: 2px;
}
div#add-channel-prompt-content {
    max-width: 100%;
}
.video-meta>div>div>img {
    width: 37px!important;
    height: 37px!important;
    border-radius: 70px!important;
}
.video-meta>div {justify-content: right;font-size:1.3rem;}
.video-meta>span {justify-content: right;font-size:1.2rem;}

h3.video-title {
    text-align-last: right;
    font-size:1.3rem;
}
.last-watched-carousel-wrapper {
    position: relative;
    width: 237%;
}
.last-watched-carousel-wrapper {
    direction: ltr;
}
/* NEW: Carousel Navigation Buttons */
        section#screen-Dashboard,section#screen-Media {
        height: 105% !important;
}



.carousel-nav-button {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    z-index: 10;
    background-color: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: none; /* Hidden by default */
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}
.carousel-nav-button:hover {
    background-color: rgba(0, 0, 0, 0.6);
    transform: translateY(-50%) scale(1.1);
}
.carousel-nav-button.prev {
    right: 10px;
     width: 70px;
     height: 70px;
    
}
.carousel-nav-button.next {
     right: 73px;
     width: 70px;
     height: 70px;
}
/* This is the scrollable viewport */
.last-watched-slides-container {
    display: flex;
    gap: 1rem; /* The space between cards */
    overflow-x: auto; /* This enables horizontal scrolling */
    scroll-snap-type: x mandatory; /* This enables snapping behavior */
    -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    padding: 0.5rem 1rem; /* Adds some vertical and horizontal padding */
    clip-path: inset(-5px -10px -5px -10px); /* Prevents padding from clipping box-shadow */
    scrollbar-width: none; /* Hides scrollbar for Firefox */
}
/* Hides scrollbar for Chrome, Safari, and Opera */
.last-watched-slides-container::-webkit-scrollbar {
    display: none;
}
div#youtube-suggestions {
    overflow: clip;
}
.last-watched-slide {
    flex: 0 0 45%; /* Each slide is ~45% of the container. 2 slides = 90% + gap, leaving the 3rd one partially visible. */
    scroll-snap-align: start; /* Each card will snap to the start of the container when scrolling stops */
    scroll-snap-stop: always; /* Ensures it stops precisely on each snap point */
}

.last-watched-slide .glass-surface {
    width: 100%;
}

/* Ensure text doesn't wrap and overflow awkwardly */
.last-watched-slide h3, .last-watched-slide p {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
button.delete-channel-btn.absolute.bottom-2.right-2.p-1\.5.bg-red-600\/80.hover\:bg-red-500.rounded-full.transition-colors.z-10.navigable.grid-item {
    z-index: 0;
}
/* --- END: Last Watched Carousel Styles --- */
.resume-play-button {
    background-color: rgba(99, 102, 241, 0.8); /* Indigo color */
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 9999px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.2s;
    border: none;
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.resume-play-button:hover {
    background-color: rgba(79, 70, 229, 1);
}

.youtube-video-card.is-watched .video-title {
    color: #a5b4fc; /* Lighter, muted color for watched videos */
}

/* --- END: Last Watched & History Styles --- */

/* --- START: Bookmark Styles --- */
.bookmark-button {
    position: absolute;
    top: 8px;
    left: 8px; /* For RTL layout */
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    z-index: 5;
}
.bookmark-button:hover {
    background-color: rgba(99, 102, 241, 1); /* Indigo */
}
.bookmark-button.saved-d {
    color: #60a5fa; /* Blue 400 */
}
.bookmark-button.saved-m {
    color: #f472b6; /* Pink 400 */
}
.bookmark-button.saved-both {
    background: linear-gradient(45deg, #60a5fa, #f472b6);
    color: white;
}

.favorites-menu {
    position: fixed; /* Use fixed to break out of scrolling containers */
    background-color: rgba(30, 41, 59, 0.9);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 0.75rem;
    padding: 0.5rem;
    z-index: 150; /* High z-index */
    display: none;
    min-width: 150px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
.favorites-menu.show {
    display: block;
}
.favorites-menu button {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    width: 100%;
    padding: 0.5rem 0.75rem;
    text-align: right;
    font-size: 0.9rem;
    color: white;
    background-color: transparent;
    border: none;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: background-color 0.2s;
}
.favorites-menu button:hover {
    background-color: rgba(71, 85, 105, 0.7);
}

.remove-favorite-button {
    position: absolute;
    top: 8px;
    left: 8px;
    background-color: rgba(220, 38, 38, 0.7); /* Red */
    color: white;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    z-index: 5;
}
.remove-favorite-button:hover {
    background-color: rgba(185, 28, 28, 1);
}
/* --- END: Bookmark Styles --- */

div#tv{display:none;}
div#geolocation-error-overlay {
    display: none !important;
}
button#back-to-search-floating-button {
    Z-INDEX: 99999;
}

.search-results-nav {
    width: 50%;
    justify-self: center;
}

.w-full.grid.grid-cols-3.items-center.p-2.sticky.bottom-0.bg-black\/40.backdrop-blur-sm.flex-shrink-0 {
    WIDTH: 50%;
    JUSTIFY-SELF: CENTER;
}



 .flex.flex-wrap.justify-center.gap-2.w-full {zoom: 0.85;}

/* --- Try removing !important from these rules --- */
.tabs-container {
  display: flex; /* Remove !important */
  gap: 0.5rem; /* Remove !important */
  padding: 0.25rem; /* Remove !important */
  border-radius: 9999px; /* Remove !important */
  background-color: rgba(0, 0, 0, 0.8)!important; /* Remove !important */
  align-self: center; /* Remove !important */
  margin-bottom: 1rem; /* Remove !important */
}

button#back-to-playlists-bottom-button-search {
    position: sticky;
    justify-self: anchor-center;
}
        /* Import Inter font for a modern, clean look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            /* Default background gradient - UPDATED: black parts are wider, animation is 3x slower */
            background: linear-gradient(-45deg, #000000 0%, #000000 30%, #00FFFF 35%, #000000 60%, #4B0082 65%, #8A2BE2 70%, #FF00FF 75%, #000000 100%);
            background-size: 400% 400%;
            animation: gradient 15s ease infinite; /* Animation duration decreased to 15s */
            transition: background-image 0.5s ease; /* Smooth transition for background changes */
            min-height: 100vh; /* Ensure body takes full viewport height */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Prevent body scroll */
        }
        
div#hourly-forecast-container {
    min-height: 93px;
}
button#tab-tarteel {
    display: none;
}

.flex.items-center.justify-between.w-full.gap-2 {
    direction: rtl;
}
        body.animation-paused {
            animation-play-state: paused !important;
        }
        body.video-playing {
            animation-duration: 75s !important; /* 80% slower animation */
        }
.bg-black2 {
    background-image: linear-gradient(45deg, #000000, #6f6f6f39)!important;
}
        img.max-w-full.max-h-full.object-contain { max-width: 50%;
    mix-blend-mode: hard-light;
}
        /* Ensure RTL direction for specific elements if needed */
        div#youtube-video-list-view, div#youtube-search-results-view {
            direction: rtl;
        }
        div#youtube-readers-section {
            direction: rtl;
        }
        /* Define different background themes for customization */
        body.theme-gradient-1 {
            background: linear-gradient(-45deg, #000000 0%, #000000 30%, #00FFFF 35%, #000000 60%, #4B0082 65%, #8A2BE2 70%, #FF00FF 75%, #000000 100%);
            background-size: 400% 400%;
            animation: gradient 15s ease infinite;
        }
       
        div#quran-quick-access {
            display: none !important;
        }

        .h-full {
            height: 97% !important;
        }

        /* NEW GLASS SURFACE CSS - Enhanced for liquid 3D effect and "drop glass" */
        .glass-surface {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: opacity 0.26s ease-out;
            border-radius: 1.5rem; /* Ensure rounded corners */
        }
        .glass-surface__filter {
            width: 100%;
            height: 100%;
            pointer-events: none;
            position: absolute;
            inset: 0;
            opacity: 0;
            z-index: -1;
        }

        div#youtube-search-results-view {
    overflow: scroll;
}

.glass-surface.glass-surface--svg.youtube-video-card.navigable.grid-item {
    direction: ltr!important;
}

        .glass-surface__content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            border-radius: inherit;
            position: relative;
            z-index: 1;
        }
        div#geares {
    height: 114px;
}

div#\33 d-screen-weather-widget {
    height: 115px;
    width: 116px;
}
        .glass-surface--svg {
            /* Adjusted background for a more pronounced "drop" effect */
            background: light-dark(hsl(0 0% 100% / var(--glass-frost, 0.1)), /* Slightly more opaque background */
                hsl(0 0% 0% / var(--glass-frost, 0.2))); /* Darker opaque background for dark mode */
            
            /* Enhanced backdrop-filter for stronger blur and saturation */
            backdrop-filter: var(--filter-id, url(#glass-filter)) blur(8px) saturate(1.8) brightness(1.1); /* e.g., 8px instead of 10px */
     -webkit-backdrop-filter: blur(8px) saturate(1.8) brightness(1.1);/* Webkit prefix */

            /* More pronounced box-shadow for a "dropped" effect */
            box-shadow:
                0 0 5px 2px rgba(255, 255, 255, 0.1) inset, /* Inner light glow */
                0 0 15px 6px rgba(0, 255, 255, 0.15) inset, /* Inner cyan glow */
                0px 8px 30px rgba(17, 17, 26, 0.1), /* Stronger outer shadow */
                0px 16px 60px rgba(17, 17, 26, 0.15), /* Even stronger outer shadow */
                0px 24px 80px rgba(17, 17, 26, 0.2), /* Deepest outer shadow */
                inset 0 0 20px 8px rgba(0,0,0,0.3), /* Deeper inner shadow for depth */
                inset 0 0 25px 10px rgba(0,0,0,0.2), /* Even deeper inner shadow */
                0 0 20px rgba(255, 255, 255, 0.15); /* Added subtle outer white glow for "shine" */
            border: 1px solid rgba(255, 255, 255, 0.3); /* Added a subtle white border */
        }
        
        /* Fallback for browsers not supporting backdrop-filter - also enhanced */
        .glass-surface--fallback {
            background: rgba(255, 255, 255, 0.35); /* More opaque fallback */
            backdrop-filter: blur(15px) saturate(2.0) brightness(1.2); /* Stronger fallback blur/saturate */
            -webkit-backdrop-filter: blur(15px) saturate(2.0) brightness(1.2);
            border: 1px solid rgba(255, 255, 255, 0.4); /* Stronger border */
            box-shadow:
                0 10px 40px 0 rgba(31, 38, 135, 0.3), /* Stronger fallback shadow */
                0 4px 20px 0 rgba(31, 38, 135, 0.2),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.5),
                inset 0 -1px 0 0 rgba(255, 255, 255, 0.3);
        }
        @media (prefers-color-scheme: dark) {
            .glass-surface--fallback {
                background: rgba(255, 255, 255, 0.15); /* Dark mode fallback */
                backdrop-filter: blur(15px) saturate(2.0) brightness(1.3);
                -webkit-backdrop-filter: blur(15px) saturate(2.0) brightness(1.3);
                border: 1px solid rgba(255, 255, 255, 0.3);
                box-shadow:
                    inset 0 1px 0 0 rgba(255, 255, 255, 0.3),
                    inset 0 -1px 0 0 rgba(255, 255, 255, 0.2);
            }
        }
        @supports not (backdrop-filter: blur(10px)) {
            .glass-surface--fallback {
                background: rgba(255, 255, 255, 0.5); /* Strongest fallback for no backdrop-filter */
                box-shadow:
                    inset 0 1px 0 0 rgba(255, 255, 255, 0.6),
                    inset 0 -1px 0 0 rgba(255, 255, 255, 0.4);
            }
            .glass-surface--fallback::before {
                content: '';
                position: absolute;
                inset: 0;
                background: rgba(255, 255, 255, 0.2); /* More opaque overlay */
                border-radius: inherit;
                z-index: -1;
            }
        }
        
        /* TV Remote Focus Style */
        .navigable:focus, .navigable.tv-focus {
            outline: 3px solid #0A84FF !important; /* Use !important to override other outlines */
            box-shadow: 0 0 20px rgba(10, 132, 255, 0.7) !important; /* Use !important */
            transform: scale(1.03);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }



        /* Keyframe animation for the background gradient */
        @keyframes gradient {
              
          0% {
    background-position: 29.0118% 50%;
  }
  50% {
    background-position: 65.0118% 50%;
  }
    0% {
    background-position: 29.0118% 50%;
  }
        }

        /* Styles for individual app screens */
        .app-screen {
            display: none; /* Hidden by default */
            animation: fadeIn 0.1s ease-in-out; /* Fade-in transition */
            width: 100%;
            height: 100%;
            flex-direction: column;
            border-radius: 1.5rem; /* Ensure app screens have rounded corners */
        }
        .app-screen.active {
            display: flex; /* Display when active */
        }
        
        /* Fade-in animation for screen transitions */
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1); }
        }
        
        /* Styling for iframes to fit their containers */
        .full-iframe {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 1.5rem;
        }

        .homebtn{display:none}

        /* Floating Button Styles - Positioned and styled for glass effect */
        #floating-media-button,
        #back-to-playlists-bottom-button,
        #back-to-playlists-bottom-button-search,
        #floating-keyboard-button,
        #start-trip-floating-button { 
            position: fixed;
            background-color: rgba(138, 8, 6, 0.5); /* Purple glass */
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 9999px; /* Pill shape */
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            z-index: 100; /* Above everything else */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        /* UPDATED: Clear Search Button style */
        #clear-search-button {
            background-color: rgba(220, 38, 38, 0.6); /* Red glass */
            color: white;
            padding: 0.75rem;
            border-radius: 9999px; /* Pill shape */
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #floating-media-button:hover,
        #back-to-playlists-bottom-button:hover,
        #floating-keyboard-button:hover,
        #clear-search-button:hover,
        #start-trip-floating-button:hover {
            transform: scale(1.05); /* Only scale, no translate */
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
        }

        /* Specific positioning for floating buttons */
        #floating-media-button { bottom: 1rem; right: 1rem; }
        #floating-keyboard-button {
            bottom: 1rem;
            right: 8rem; /* Adjusted to be next to media button */
            display: none; /* Hidden by default */
        }
        #floating-keyboard-button.active-keyboard {
            background-color: #90EE90; /* Chrome Green */
            color: black; /* Black icon */
        }
        #floating-keyboard-button.inactive-keyboard {
            background-color: #FF0000; /* Red */
            color: white; /* White icon */
        }

        #back-to-playlists-bottom-button, #back-to-playlists-bottom-button-search {
            bottom: 1rem;
            left: 50%;
        
            display: none; /* Hidden by default */
        }

        #start-trip-floating-button {
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: #10B981; /* Green color */
            display: none; /* Hidden by default */
        }

        /* NEW: Style for the minimized video player button */
        #floating-minimized-video-button {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            background-color: rgba(245, 158, 11, 0.7); /* Amber/Yellow color */
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 9999px; /* Pill shape */
            display: none; /* Hidden by default */
            align-items: center;
            gap: 0.75rem;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            z-index: 105;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 250px; /* Prevent it from getting too wide */
        }
        #floating-minimized-video-button .minimized-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }


        /* Top bar positioning and transition */
        .top-bar {
            top: 1rem;
            transition: opacity 0.3s ease;
        }

        /* Main CarPlay interface container adjustments */
        #carplay-main-interface {
    position: fixed;
    top: 0%;
    left: 0%;
    width: 100vw;
    height: 100vh;
    transition: all 0.5s ease-in-out;
    border-radius: 2rem;
}

        /* Pseudo-fullscreen class for the CarPlay interface */
        #carplay-main-interface.carplay-pseudo-fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            margin: 0;
            border-radius: 0;
            z-index: 99; /* Ensure it's above other content but below the floating button */
            max-width: 100vw; /* When fullscreen, it should take full width */
        }

        /* Shrink content when in pseudo-fullscreen mode for better fit */
        #carplay-main-interface.carplay-pseudo-fullscreen #digital-time {
            font-size: 2.2rem !important;
        }
        #carplay-main-interface.carplay-pseudo-fullscreen #weather-temp-main {
            font-size: 4rem !important;
        }

        /* Scrollbar styling for better aesthetics */
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 10px; }

        /* Active app icon styling */
        .app-icon.active {
            background-color: #6b22ff; /* Purple */
            color: white;
            transform: scale(1.1);
        }

        /* Gemini-like Chat Styling */
        .chat-message {
            max-width: 70%;
            padding: 0.75rem 1rem;
            border-radius: 1.5rem; /* More rounded */
            margin-bottom: 0.75rem;
            word-wrap: break-word;
            font-size: 0.9rem; /* Slightly smaller font for chat */
        }

        .chat-message.user {
            background-color: #4f46e5; /* Blue */
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 0.5rem; /* Pointy bottom right */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .chat-message.ai {
            background-color: #2d3748; /* Darker gray */
            color: white;
            margin-right: auto;
            border-bottom-left-radius: 0.5rem; /* Pointy bottom left */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #ai-input {
            border-radius: 2rem; /* Fully rounded pill shape */
            padding: 0.75rem 1.25rem;
            background-color: rgba(255, 255, 255, 0.15); /* Lighter glass */
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
        }
        #ai-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        #ai-input:focus {
            background-color: rgba(255, 255, 255, 0.2);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.4), 0 0 0 2px rgba(147, 51, 234, 0.5);
        }
        
        /* YouTube Video Card Styling (List View and Search Results) - UPDATED */
        .youtube-video-card, .youtube-search-card {
            display: flex;
            flex-direction: row;
            align-items: flex-start; /* CHANGED to align items to the top */
            padding: 0.75rem;
            border-radius: 1rem;
            background-color: rgba(255, 255, 255, 0.05);
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            width: 100%;
            box-sizing: border-box;
            cursor: pointer;
            gap: 1rem;
        }
        .youtube-video-card:hover, .youtube-search-card:hover {
            background-color: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }
        .youtube-video-card .thumbnail-container {
            position: relative;
            width: 180px;  /* INCREASED */
            height: 101.25px; /* INCREASED (16:9 ratio) */
            flex-shrink: 0;
            overflow: hidden; /* Important for progress bar */
        }

        .glass-surface.glass-surface--svg.p-4.rounded-3xl.text-center.flex.flex-col.items-center.justify-center.navigable.grid-item {
    height: 169px;
}
        /* NEW: Styles for Watched Progress Bar */
        .watched-progress-bar-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.3);
        }
        .watched-progress-bar {
            height: 100%;
            background-color: #ef4444; /* Red color */
            border-radius: 0 2px 2px 0;
        }

        /* NEW: Style for Watched Badge */
        .watched-badge {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .youtube-video-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 0.5rem;
        }
        .video-duration {
            position: absolute;
            bottom: 4px;
            right: 4px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 0.75rem;
            padding: 2px 4px;
            border-radius: 4px;
        }
        .video-details {
            display: flex;
            flex-direction: column;
            gap: 4px;
            overflow: hidden;
            flex-grow: 1;
            min-width: 0;
        }
        .video-title {
            font-size: 1rem;
            font-weight: 600;
            color: white;
            line-height: 1.3;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        .video-meta {
            display: flex;
            flex-direction: column;
            gap: 4px; /* Gap between channel line and stats line */
            font-size: 0.8rem;
            color: #a7f3d0; /* A minty color, less harsh than cyan */
            font-weight: 500;
        }

        /* NEW: Explicit scrollbar for search results */
        #search-results-container::-webkit-scrollbar {
            width: 8px;
            display: block; /* Ensure it's always displayed */
        }
        #search-results-container::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        #search-results-container::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.5);
            border-radius: 10px;
        }
        
        /* YouTube Reader Card Styling (Suggestions) - UPDATED */
        .youtube-reader-card {
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.75rem;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s ease-in-out;
            border-radius: 1.25rem;
            background-color: rgba(255, 255, 255, 0.05);
        }
        .youtube-reader-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            background-color: rgba(255, 255, 255, 0.1);
        }
        .youtube-reader-card img {
            width: 100px; /* MODIFIED: Increased size */
            height: 100px; /* MODIFIED: Increased size */
            object-fit: cover;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
        }
        .youtube-reader-card h3 {
            font-size: 1.1rem; /* MODIFIED: Increased font size */
            font-weight: 600;
            color: white;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 95%;
            margin-bottom: 1rem; /* MODIFIED: Increased margin */
        }
        .youtube-reader-card.selected {
            background-color: #9333ea !important;
            box-shadow: 0 0 15px rgba(147, 51, 234, 0.8);
            transform: translateY(-5px) scale(1.05);
        }
        /* UPDATED: Reader container is now a grid */
        .reader-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); /* MODIFIED: Responsive columns */
            overflow-y: auto;
            padding-bottom: 1rem;
            gap: 1.25rem; /* MODIFIED: Increased gap */
            direction: ltr;
            max-height: 45vh; /* MODIFIED: Increased height */
            width: 100%; /* MODIFIED: Ensure full width */
        }
        .reader-container::-webkit-scrollbar { display: block; }
        .reader-container { -ms-overflow-style: auto; scrollbar-width: thin; }


        /* YouTube Suggestion Buttons (for Surahs) - UPDATED */
        .youtube-suggestion-button {
            color: white;
            padding: 0.25rem 0.75rem; /* Zoomed out padding */
            border-radius: 9999px;
            font-size: 0.75rem; /* Zoomed out font */
            font-weight: bold;
            transition: background-color 0.2s ease, transform 0.1s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
            /* NEW: Switched to inline-flex for variable width */
            display: inline-flex;
            width: auto;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            position: relative;
            overflow: hidden; /* Keep overflow hidden on the button itself */
        }
        .youtube-suggestion-button:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .youtube-suggestion-button:active {
            transform: translateY(0);
        }
        
        /* NEW: Style for the Surah name text to handle long names */
        .surah-name-text {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: right; /* Align text to the right for RTL */
        }

        /* NEW: Badge for Juz number */
        .youtube-suggestion-button .juz-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 9999px;
            background-color: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 0.8rem;
            font-weight: bold;
            flex-shrink: 0; /* Prevent badge from shrinking */
            line-height: 1;
            position: relative; /* Allow z-index */
            z-index: 2; /* Ensure it's on top */
        }

        /* YouTube Suggestion Category Tag */
        .youtube-suggestion-category-tag {
            display: inline-block;
            padding: 0.3rem 0.8rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: bold;
            color: white;
            margin-bottom: 0.5rem;
            align-self: flex-start;
        }
        /* NEW: Surah Buttons Scrollable Container */
        .surah-buttons-scrollable {
            max-height: 77%;
            overflow-y: auto;
            padding-right: 8px; 
            padding-left: 8px; 
        }
        .surah-buttons-scrollable::-webkit-scrollbar { width: 6px; }
        .surah-buttons-scrollable::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 10px; }
        .surah-buttons-scrollable::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.4); border-radius: 10px; }
        
        /* NEW: Styling for Tabs in Media Screen */
        .tabs-container {
            display: flex;
            gap: 0.5rem;
            padding: 0.25rem;
            border-radius: 9999px; /* pill shape */
            background-color: rgba(0, 0, 0, 0.8);
            align-self: center; /* Center the tab bar */
            margin-bottom: 1rem;
        }
        .tab-button {
            padding: 0.5rem 1.25rem;
            background-color: transparent;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
            font-size: 0.9rem;
            border: none;
            border-radius: 9999px; /* pill shape */
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .tab-button.active {
            color: white;
            background-color: rgba(147, 51, 234, 0.6); /* Purple */
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .tab-content {
            width: 100%;
            height: 100%;
        }
        .tab-content.hidden {
            display: none;
        }


        /* Dashboard Logo Effect */
        .metallic-logo-effect {
            width: 300px;
            height: auto;
            margin-bottom: 1rem;
            filter: grayscale(100%) brightness(30%);
        }

        /* Car Dashboard Specific Styles */
        .car-dashboard-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .gauge-container.absolute-pos {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .gauge-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 0.25rem;
        }

        .speed-display {
            font-size: 2.5rem;
            line-height: 1;
        }

        .rpm-display {
            font-size: 1.2rem;
            line-height: 1;
        }

        .gear-indicator {
            font-size: 4rem;
            font-weight: bold;
            color: #10b981;
        }

        div#youtube-suggestions {
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }

.glass-surface.glass-surface--svg.p-3.rounded-2x1.text-center.flex.items-center.gap-3.navigable.grid-item {
    height: 122px;
}.glass-surface.glass-surface--svg.p-3.rounded-2x1.text-center.flex.items-center.gap-3.navigable.grid-item {}

div#\33 d-screen-gear {
    font-size: 2.7rem;
}

/* NEW: Style for direction indicator */
div#\33 d-screen-dir {
    font-size: 2.7rem;
}


div#youtube-readers-section {
    height: 100%;
}

.reader-container {
    max-width: 100% !important;
    max-height: 100% !important;
} 

section#screen-Media {
    height: 101%!important;
    padding: 0px!important;
    overflow-y: auto;
    background: #000000b5;
}

        
div#youtube-readers-section {
    height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: rgba(255, 255, 255, 0.7);
            box-shadow: inset 0 0 15px rgba(0,0,0,0.7);
            overflow: hidden;
            position: relative;
        }
        .car-cam-360-container img {
            height: 160%;
            width: 100%; 
            object-fit: cover;
        }
        .car-cam-360-controls {
            position: absolute;
            bottom: 1rem;
            display: flex;
            gap: 0.5rem;
            z-index: 20;
        }
        .car-cam-360-controls button {
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .car-cam-360-controls button:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }


        /* Digital Clock Styles (Apple iOS 19 style) */
        #digital-time {
            font-size: 1.8rem;
            font-weight: 800;
            color: white;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: baseline;
            gap: 0.2rem;
            direction: ltr; /* FIX: Enforce LTR for correct HH:MM:SS order */
        }
        #digital-time span {
            transition: opacity 0.3s ease;
        }
        #digital-time .hours { opacity: 1; }
        #digital-time .minutes { opacity: 0.8; }
       #digital-time .seconds {
    opacity: 0.6;
    font-size: 2.2rem;
}

        /* Updated #digital-date styles based on user request */
        #digital-date {
            font-size: 1.2rem;
            color: rgb(255 255 255 / 99%);
            font-weight: bold;
            text-align: center;
            line-height: 1.4;
        }
        /* Countdown to Azan */
        .countdown-azan {
            color: cyan !important;
        }
        /* Countdown to Iqama */
        .countdown-iqama {
            color: orange !important;
        }
        /* Count-up after Iqama */
        .countdown-up {
            color: #98FB98 !important; /* PaleGreen, close to lightmint */
        }


        /* Settings Range Input Styling */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover { opacity: 1; }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #9333ea;
            cursor: pointer;
            box-shadow: 0 0 0 3px rgba(147, 51, 234, 0.5);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #9333ea;
            cursor: pointer;
            box-shadow: 0 0 0 3px rgba(147, 51, 234, 0.5);
        }

        /* Animated Weather Icon Styles */
        @keyframes pulse-float {
            0% { transform: scale(1) translateY(0px); opacity: 1; }
            50% { transform: scale(1.05) translateY(-2px); opacity: 0.9; }
            100% { transform: scale(1) translateY(0px); opacity: 1; }
        }
        #dashboard-weather-icon, #weather-icon {
            animation: pulse-float 3s ease-in-out infinite alternate;
            transition: transform 0.3s ease-in-out;
        }

@media (max-width: 768px) {
    /* ... (ÿ®ŸÇŸäÿ© ÿßŸÑÿ£ŸÉŸàÿßÿØ ÿßŸÑÿÆÿßÿµÿ© ÿ®ÿßŸÑŸáŸàÿßÿ™ŸÅ ÿßŸÑŸÖÿ≠ŸÖŸàŸÑÿ©) ... */

    /* üõë ÿ•ÿÆŸÅÿßÿ° ÿ£ŸäŸÇŸàŸÜÿßÿ™ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇÿßÿ™ ÿ∫Ÿäÿ± ÿßŸÑÿ∂ÿ±Ÿàÿ±Ÿäÿ© ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑŸÖŸàÿ®ÿßŸäŸÑ */
    button[data-app="Map"] {
        display: none !important; /* ÿ•ÿÆŸÅÿßÿ° ÿ£ŸäŸÇŸàŸÜÿ© Map/3D Car (ÿ™ŸÖÿ™ ÿ•ÿπÿßÿØÿ© ÿ™ÿ≥ŸÖŸäÿ™Ÿáÿß) */
    }
    button[data-app="Radio"] {
        display: none !important; /* ÿ•ÿÆŸÅÿßÿ° ÿ£ŸäŸÇŸàŸÜÿ© Radio */
    }
    
    /* üõë ÿ•ÿÆŸÅÿßÿ° ÿ≤ÿ± ÿßŸÑŸàÿ≥ÿßÿ¶ÿ∑ ÿßŸÑÿπÿßÿ¶ŸÖ (ŸÖŸÉÿ±ÿ± ŸÖÿπ ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ™ŸÜŸÇŸÑ) */
    #floating-media-button {
        display: none !important;
    }

    /* ŸÖŸÑÿßÿ≠ÿ∏ÿ©: Ÿäÿ™ŸÖ ÿ®ÿßŸÑŸÅÿπŸÑ ÿ•ÿÆŸÅÿßÿ° floating-media-button ÿπŸÜÿØŸÖÿß ÿ™ŸÉŸàŸÜ ÿ¥ÿßÿ¥ÿ© Media ŸÜÿ¥ÿ∑ÿ© ŸÅŸä handleMediaViewSwitch */
    
    /* ... (ÿ®ŸÇŸäÿ© ÿßŸÑÿ£ŸÉŸàÿßÿØ) ... */
}

        /* NEW: Responsive padding toggle */
        @media (min-width: 768px) {
            body.small-padding .md\:p-6 {
                padding: 1.5rem !important;
            }
        }
          #digital-time .hours { font-size: 2.2rem; }
        #digital-time .minutes { font-size: 2.2rem; }
       #digital-time .seconds { 
    font-size: 1.8rem;
}


div#bottom-left-controls {
    left: 90px!important;
}
        img.w-full.h-full.object-cover.rounded-lg.opacity-80 {
            position: fixed;
        }
        /* Prayer Times Specific Styles */
        .prayer-times-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            width: 100%;
            margin-top: 1rem;
        }
        .prayer-time-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
            font-size: 0.9rem;
            min-width: 80px;
            text-align: center;
            transition: background-color 0.3s ease;
        }
        /* UPDATED: Current prayer is green */
        .prayer-time-item.current-prayer {
            background-color: rgba(16, 185, 129, 0.4); /* Greenish */
            font-weight: bold;
            border: 1px solid #10B981;
        }
        /* UPDATED: Next prayer is orange */
        .prayer-time-item.next-prayer {
            background-color: rgba(251, 146, 60, 0.3); /* Orangey */
            border: 1px solid #fb923c;
        }
        .prayer-name {
           color: rgba(255, 255, 255);
    font-size: 1rem;
    font-family: sans-serif;
    font-weight: bold;
    margin-bottom: 0.2rem;
        }
        .prayer-time {
           color: rgba(255, 255, 255,0.85);
            font-size: 1.4rem;
            font-weight: bold;
   
        }
       span.prayer-iqama{
             font-size: 1rem;
             color: rgb(255 179 20 / 85%);
             font-family: sans-serif;
             font-weight: bold;
            margin-bottom: 0.2rem;
            font-size: 1.3rem;
            
        }

        /* --- START: Islamic Daily Reminders Styles (MODIFIED) --- */

.reminders-grid {
    display: grid;
    grid-template-columns: repeat(2, 48%); /* ÿπŸÖŸàÿØŸäŸÜ ÿ®ÿπÿ±ÿ∂ 48% ŸÑŸÉŸÑ ŸÖŸÜŸáŸÖÿß */
    justify-content: center; /* ÿ™Ÿàÿ≥Ÿäÿ∑ ÿßŸÑÿπŸÖŸàÿØŸäŸÜ ŸÅŸä ÿßŸÑÿ≠ÿßŸàŸäÿ© */
    gap: 1rem;
    width: 100%;
    height: 100%;
    align-content: center; 
    padding: 1rem; 
}

.reminder-item {
    background-color: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 1.25rem;
    padding: 0.8rem 1rem; /* ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿ≠ÿ¥Ÿà */
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: flex-start;
    gap: 0.75rem; /* ÿ™ŸÇŸÑŸäŸÑ ÿßŸÑŸÖÿ≥ÿßŸÅÿ© */
    transition: all 0.3s ease;
    cursor: pointer;
    height:80%;
}

.reminder-item .icon {
    color: rgba(255, 255, 255, 0.5); 
    flex-shrink: 0; /* ŸÑŸÖŸÜÿπ ÿßŸÑÿ£ŸäŸÇŸàŸÜÿ© ŸÖŸÜ ÿßŸÑÿßŸÜŸÉŸÖÿßÿ¥ */
    /* ÿ™ÿµÿ∫Ÿäÿ± ÿ≠ÿ¨ŸÖ ÿßŸÑÿ£ŸäŸÇŸàŸÜÿ© ŸÑÿ™ÿ™ŸÜÿßÿ≥ŸÇ ŸÖÿπ ÿßŸÑŸÜÿµ */
    width: 1.6rem !important;
    height: 1.6rem !important;
}

.reminder-item .text {
    font-size: 1.2rem; /* ÿ™ÿµÿ∫Ÿäÿ± ÿ≠ÿ¨ŸÖ ÿßŸÑÿÆÿ∑ */
    font-weight: 600;
    color: rgba(255, 255, 255, 0.7);
    text-align: right; /* ŸÑÿ∂ŸÖÿßŸÜ ŸÖÿ≠ÿßÿ∞ÿßÿ© ÿßŸÑŸÜÿµ ŸÑŸÑŸäŸÖŸäŸÜ */
}

/* ŸÉŸàÿØ ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑŸÜÿ¥ÿ∑ÿ© Ÿäÿ®ŸÇŸâ ŸÉŸÖÿß ŸáŸà ŸÑÿ£ŸÜŸá ŸÖŸÖÿ™ÿßÿ≤ */
.reminder-item.active {
    background-color: rgba(20, 184, 166, 0.3); 
    border-color: rgba(45, 212, 191, 0.7);
    box-shadow: 0 0 20px rgba(20, 184, 166, 0.5);
}

.reminder-item.active .icon {
    color: #5eead4; 
}

.reminder-item.active .text {
    color: #ffffff; 
}

/* NEW: Upcoming reminder glow */
.reminder-item.upcoming {
    background-color: rgba(249, 115, 22, 0.2); /* Orange transparent bg */
    border-color: rgba(251, 146, 60, 0.6);   /* Orange border */
    box-shadow: 0 0 20px rgba(249, 115, 22, 0.4); /* Orange glow */
}
.reminder-item.upcoming .icon {
    color: #fdba74; /* Light orange icon */
}
.reminder-item.upcoming .text {
    color: #ffffff; /* White text for contrast */
}

/* ‚ñº‚ñº‚ñº NEW: Completed reminder style ‚ñº‚ñº‚ñº */
.reminder-item.completed {
    background-color: rgba(107, 114, 128, 0.15); /* Grayish transparent bg */
    border-color: rgba(107, 114, 128, 0.3);
    opacity: 0.7; /* Make it more faded */
}
.reminder-item.completed .icon {
    color: #4ade80; /* Green check icon */
}
.reminder-item.completed .text {
    color: rgba(255, 255, 255, 0.5); /* Faded text */
}


/* ‚ñº‚ñº‚ñº NEW: Missed and Dropdown Styles ‚ñº‚ñº‚ñº */
.reminder-item.missed {
    background-color: rgba(239, 68, 68, 0.2); /* Red transparent bg */
    border-color: rgba(248, 113, 113, 0.6);   /* Red border */
    box-shadow: 0 0 20px rgba(239, 68, 68, 0.4); /* Red glow */
}
.reminder-item.missed .icon {
    color: #fca5a5; /* Light red icon */
}
.reminder-item.missed .text {
    color: #ffffff; /* White text for contrast */
}

/* Dropdown menu for reminders */
.reminder-status-dropdown {
    position: absolute;
    top: 90%; /* Position slightly overlapping the icon */
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(30, 41, 59, 0.9); /* slate-800 with transparency */
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 0.75rem;
    padding: 0.5rem;
    z-index: 50;
    display: none; /* Hidden by default */
    min-width: 120px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
.reminder-status-dropdown.show {
    display: block;
}
.reminder-status-dropdown button {
    display: block; width: 100%; padding: 0.5rem 0.75rem; text-align: right; font-size: 0.9rem; color: white; background-color: transparent; border: none; border-radius: 0.5rem; cursor: pointer; transition: background-color 0.2s;
}
.reminder-status-dropdown button:hover {
    background-color: rgba(71, 85, 105, 0.7); /* slate-600 with transparency */
}
/* ‚ñ≤‚ñ≤‚ñ≤ END: New Styles ‚ñ≤‚ñ≤‚ñ≤ */


/* --- END: Islamic Daily Reminders Styles (MODIFIED) --- */
        /* OBD-II Specific Styles */
        .obd-data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            width: 100%;
        }
        .obd-data-card {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 1rem;
            text-align: center;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }
        .obd-data-card .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #10b981;
            margin-bottom: 0.25rem;
        }
        .obd-data-card .label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        /* ÿßŸÑÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ŸÑŸÑÿ¥ÿßÿ¥ÿßÿ™ ÿßŸÑÿ£Ÿàÿ≥ÿπ */
        @media (min-width: 992px) {

/* Cleaned base body styles - animation and gradient moved to screens */
¬† ¬† ¬† ¬† body {
¬† ¬† ¬† ¬† ¬† ¬† font-family: 'Inter', sans-serif;
¬† ¬† ¬† ¬† ¬† ¬† background: #000000; /* Simple black fallback */
¬† ¬† ¬† ¬† ¬† ¬† background-size: auto; /* Reset size */
¬† ¬† ¬† ¬† ¬† ¬† animation: none; /* Remove body animation */
¬† ¬† ¬† ¬† ¬† ¬† transition: background-image 0.5s ease;
¬† ¬† ¬† ¬† ¬† ¬† min-height: 100vh;
¬† ¬† ¬† ¬† ¬† ¬† display: flex;
¬† ¬† ¬† ¬† ¬† ¬† flex-direction: column;
¬† ¬† ¬† ¬† ¬† ¬† align-items: center;
¬† ¬† ¬† ¬† ¬† ¬† justify-content: center;
¬† ¬† ¬† ¬† ¬† ¬† overflow: hidden;
¬† ¬† ¬† ¬† }

            .carousel-nav-button.prev {
                display: flex;
            }

            div#video-popup-container {
    height: 17rem;
    width: 29rem;
    bottom:8rem;
    right:2rem;
}

  #digital-time .hours { font-size: 3.2rem; }
        #digital-time .minutes { font-size: 3.2rem; }
       #digital-time .seconds { 
    font-size: 2.5rem;
}
           
     .flex.gap-2.mt-2.homebtn {
    display: none;
}
section#screen-Dashboard{
  background: #00000084;   
}
            body{
                      background: url(https://dmusera.netlify.app/tvbgc1.webp) !important;
        background-size: contain !important;
        background-color: black !important;
        background-repeat: no-repeat !important;
        background-position: center !important;
            }

            /* NEW: Date widget styles */
            #full-date-widget-container {
                display: flex !important; /* Make it visible */
                flex-direction: column;
                align-items: center;
                justify-content: center;
                color: white;
                text-shadow: 0 1px 3px rgba(0,0,0,0.5);
                padding: 0.2rem; /* Increased padding */
                background-color: rgba(0,0,0,0.2);
                border-radius: 1rem;
                backdrop-filter: blur(5px);
                -webkit-backdrop-filter: blur(5px);
                margin-bottom: 0.4rem; /* Add some space below it */
                font-family: 'Amiri', serif; /* Apply Thuluth-like font */
            }
            #full-date-widget-container p { margin: 0; }
            #gregorian-date { font-size: 1.6rem; font-weight: 700; } /* Increased font size and made bold */
            #hijri-date { font-size: 1.6rem; opacity: 0.9; font-weight: 700;padding:0px;margin:0px} /* Increased font size and made bold */

            /* NEW: Larger clock on desktop */
            #digital-time {
                font-size: 3rem !important;
            }


            /* --- START: Hide Elements in TV UI --- */

/* ÿ•ÿÆŸÅÿßÿ° ÿßŸÑÿπŸÜÿßÿµÿ± ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ŸÅŸä Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ™ŸÑŸÅÿßÿ≤ */

            .glass-surface.glass-surface--svg.p-2.flex.flex-col.items-center.justify-center.text-center.car-cam-360-container.col-span-1.row-start-1.navigable.grid-item {
    display: none;
}
                              /* ÿ•ÿÆŸÅÿßÿ° ÿ£ŸäŸÇŸàŸÜÿ© ÿÆÿ±Ÿäÿ∑ÿ© ÿßŸÑŸÄ 3D ŸÖŸÜ ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ™ŸÜŸÇŸÑ */
            #car-360-image {
                visibility: hidden;
            }
            div#tv{display:block;background:#00000050}
            


        .car-cam-360-controls.grid-container>button {
    display: none;
}

            .car-cam-360-container {
                background-image: url('https://dmusera.netlify.app/tv-cont.png');
                background-size: cover;
                background-position: center center;
                background-repeat: no-repeat;
            }
            /* ÿ•ÿÆŸÅÿßÿ° ÿ¥ÿπÿßÿ± ŸÑŸÉÿ≤ÿ≥ ÿπŸÑŸâ ÿßŸÑÿ¥ÿßÿ¥ÿßÿ™ ÿßŸÑÿ£Ÿàÿ≥ÿπ */
            img[src*="Lexus-Logo.wine.svg"] {
                display: none !important;
            }
        }
        
        /* NEW: Show next button on even wider screens */
        @media (min-width: 1080px) {
            [data-app="Map"],                  /* ÿ•ÿÆŸÅÿßÿ° ÿ£ŸäŸÇŸàŸÜÿ© ÿÆÿ±Ÿäÿ∑ÿ© ÿßŸÑŸÄ 3D ŸÖŸÜ ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ™ŸÜŸÇŸÑ */
            #car-360-image {
                display:none
            }
            .glass-surface.glass-surface--svg.p-2.flex.flex-col.items-center.justify-center.text-center.car-cam-360-container.col-span-1.row-start-1.navigable.grid-item {
    display: block;
}
       .flex.gap-2.mt-2.homebtn {
    display: block;
}
div#map{display:none}

            div#tv{display:block;background:#00000050}
            .carousel-nav-button.next {
                display: flex;
            }
        }
    </style>
</head>
<body class="animated-bg text-white overflow-hidden theme-gradient-1 animation-paused">
    <!-- SVG Filter Definition for Liquid Glass Effect -->
    <svg style="position: absolute; width: 0; height: 0; overflow: hidden;">
        <defs>
            <filter id="glass-filter" colorInterpolationFilters="sRGB" x="0%" y="0%" width="100%" height="100%">
                <feImage x="0" y="0" width="100%" height="100%" preserveAspectRatio="none" result="map" 
                    href="data:image/svg+xml,%3Csvg viewBox='0 0 400 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3ClinearGradient id='red-grad' x1='100%25' y1='0%25' x2='0%25' y2='0%25'%3E%3Cstop offset='0%25' stop-color='%230000'/%3E%3Cstop offset='100%25' stop-color='red'/%3E%3C/linearGradient%3E%3ClinearGradient id='blue-grad' x1='0%25' y1='0%25' x2='0%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%230000'/%3E%3Cstop offset='100%25' stop-color='blue'/%3E%3C/defs%3E%3Crect x='0' y='0' width='400' height='200' fill='black'/%3E%3Crect x='0' y='0' width='400' height='200' rx='20' fill='url(%23red-grad)'/%3E%3Crect x='0' y='0' width='400' height='200' rx='20' fill='url(%23blue-grad)' style='mix-blend-mode: difference'/%3E%3Crect x='1.4' y='1.4' width='397.2' height='197.2' rx='20' fill='hsl(0 0% 50% / 0.93)' style='filter:blur(11px)'/%3E%3C/svg%3E"/>
                
                <feDisplacementMap in="SourceGraphic" in2="map" id="redchannel" scale="300" xChannelSelector="R" yChannelSelector="G" result="dispRed" />
                <feColorMatrix in="dispRed" type="matrix" values="1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0" result="red" />
                
                <feDisplacementMap in="SourceGraphic" in2="map" id="greenchannel" scale="310" xChannelSelector="R" yChannelSelector="G" result="dispGreen" />
                <feColorMatrix in="dispGreen" type="matrix" values="0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0" result="green" />
                
                <feDisplacementMap in="SourceGraphic" in2="map" id="bluechannel" scale="320" xChannelSelector="R" yChannelSelector="G" result="dispBlue" />
                <feColorMatrix in="blue" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0" result="blue" />
                
                <feBlend in="red" in2="green" mode="screen" result="rg" />
                <feBlend in="rg" in2="blue" mode="screen" result="output" />
                
                <feGaussianBlur in="output" stdDeviation="5" />
            </filter>
        </defs>
    </svg>

    <div class="w-full h-screen flex flex-col items-center justify-center p-4 sm:p-6">
        
        <!-- Top Bar: Wifi, 5G, Current Time -->
        <div class="w-full max-w-7xl flex justify-between items-center text-white/80 text-sm px-4 py-2 absolute top-4 left-1/2 -translate-x-1/2 z-10 top-bar">
            <div class="flex items-center gap-2">
              
            </div>
           
        </div>

        <!-- Lexus Logo Fixed at Top Center -->
        <img src="https://dmusera.netlify.app/Lexus-Logo.wine.svg" width="200px" alt="Lexus Logo" class="fixed top-2 left-1/2 -translate-x-1/2 h-12 z-[1000] opacity-80" style="filter: invert(1) grayscale(100%) brightness(200%);" />

        <!-- Main CarPlay Interface Container -->
        <div id="carplay-main-interface" class="flex flex-row shadow-2xl rounded-3xl overflow-hidden bg-black/20 border border-white/10">
            
            <!-- Main content area for app screens -->
            <main class="flex-1 flex flex-col h-full">
                
                <!-- Dashboard Screen -->
                <section id="screen-Dashboard" class="app-screen p-4 md:p-6 flex-col h-full">
                    <!-- UPDATED: Dashboard layout changed -->
                    <div class="dashboard-main-grid grid grid-cols-1 md:grid-cols-3 grid-rows-[80%_20%] gap-4 md:gap-6 h-full w-full grid-container">
                        <!-- Map Widget (Now first) -->
                        <div id="map" class="rounded-3xl relative overflow-hidden flex items-center justify-center glass-surface glass-surface--svg p-1 col-span-1 row-start-1 navigable grid-item" tabindex="0">
                            <div id="dashboard-google-map" class="full-iframe"></div>
                             <!-- NEW: Geolocation Error Overlay -->
                             <div id="geolocation-error-overlay" class="hidden absolute top-0 left-0 w-full h-full bg-black/70 text-white flex-col items-center justify-center text-center p-4 z-10 rounded-3xl">
                                <i data-lucide="map-pin-off" class="w-12 h-12 text-red-500 mb-4"></i>
                                <h3 class="font-bold text-lg mb-2">ÿÆÿØŸÖÿ© ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàÿßŸÇÿπ ŸÖÿπÿ∑ŸÑÿ©</h3>
                                <p class="text-sm text-white/80">Ÿäÿ±ÿ¨Ÿâ ÿ™ŸÖŸÉŸäŸÜ ÿ£ÿ∞ŸàŸÜÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ ŸÅŸä ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ŸÑŸáÿ∞ÿß ÿßŸÑŸÖŸàŸÇÿπ ŸÑŸÑÿßÿ≥ÿ™ŸÅÿßÿØÿ© ŸÖŸÜ ŸÖŸäÿ≤ÿßÿ™ ÿßŸÑÿÆÿ±Ÿäÿ∑ÿ©.</p>
                            </div>
                            <div class="absolute bottom-4 left-4 flex gap-2">
                                <button id="get-my-location-button-dashboard" class="bg-blue-600 hover:bg-blue-700 text-white p-3 rounded-full transition-colors duration-200 flex items-center justify-center text-sm navigable grid-item" tabindex="0" title="ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸàŸÇÿπ">
                                    <i data-lucide="map-pin" class="w-5 h-5"></i>
                                </button>
                                <button id="go-to-home-1-button" class="bg-purple-600 hover:bg-purple-700 text-white p-3 rounded-full transition-colors duration-200 flex items-center justify-center text-sm navigable grid-item" tabindex="0" title="ÿßŸÑÿ∞Ÿáÿßÿ® ÿßŸÑŸâ ÿßŸÑŸÖŸÜÿ≤ŸÑ 1">
                                    <i data-lucide="home" class="w-5 h-5"></i>
                                </button>
                                <button id="go-to-home-2-button" class="bg-indigo-600 hover:bg-indigo-700 text-white p-3 rounded-full transition-colors duration-200 flex items-center justify-center text-sm navigable grid-item" tabindex="0" title="ÿßŸÑÿ∞Ÿáÿßÿ® ÿßŸÑŸâ ÿßŸÑŸÖŸÜÿ≤ŸÑ 2">
                                    <i data-lucide="building-2" class="w-5 h-5"></i>
                                </button>
                            </div>
                        </div>

                        <!-- 360 Camera View (Stays in middle) -->
                        <div class="glass-surface glass-surface--svg p-2 flex flex-col items-center justify-center text-center car-cam-360-container col-span-1 row-start-1 navigable grid-item" tabindex="0">
                            <img id="car-360-image" src="https://dmusera.netlify.app/es350gb.png" alt="ÿπÿ±ÿ∂ ÿßŸÑŸÉÿßŸÖŸäÿ±ÿß 360 ÿØÿ±ÿ¨ÿ© ŸÑŸÑÿ≥Ÿäÿßÿ±ÿ©" class="w-full h-full object-contain rounded-lg opacity-80">
                            <div class="car-cam-360-controls grid-container">
                                <input type="file" id="upload-360-image-input" accept="image/*" class="hidden" />
                                <button id="upload-360-image-button" class="navigable grid-item" tabindex="0">
                                    <i data-lucide="upload" class="w-4 h-4"></i> ÿ™ÿ≠ŸÖŸäŸÑ ÿµŸàÿ±ÿ©
                                </button>
                                <button id="reset-360-image-button" class="navigable grid-item" tabindex="0">
                                    <i data-lucide="rotate-ccw" class="w-4 h-4"></i> ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ
                                </button>
                            </div>
                        </div>
                        
                        <!-- Weather and Clock/Prayer Widgets (Now third) -->
                        <div class="flex flex-col gap-4 md:gap-6 col-span-1 row-start-1 grid-container">
                             <div id="full-date-widget-container" class="hidden">
        </div>
                            <div class="glass-surface glass-surface--svg p-4 flex-grow flex flex-col items-center justify-center text-center navigable grid-item" tabindex="0">
                        <div id="weather-widget-container" class="w-full h-full flex flex-col items-center justify-center">
    <img id="dashboard-weather-icon" src="" alt="Weather Icon" class="w-20 h-20 text-white mb-2" />
    <p class="text-5xl font-extrabold mb-1" id="dashboard-weather-temp">--¬∞C</p>
    <p class="text-xl font-semibold text-white/80 mb-2" id="dashboard-weather-desc">--</p>
    <div id="dashboard-weather-main-metrics" class="grid grid-cols-3 gap-2 text-sm w-full mt-3">
        <div class="bg-black/20 p-2 rounded-lg text-center">
            <div class="font-bold text-lg" id="dash-metric-temp">--¬∞C</div>
            <div class="text-xs opacity-90">ÿßŸÑÿ≠ÿ±ÿßÿ±ÿ©</div>
        </div>
        <div class="bg-black/20 p-2 rounded-lg text-center">
            <div class="font-bold text-lg" id="dash-metric-uv">--</div>
            <div class="text-xs opacity-90">UV</div>
        </div>
        <div class="bg-black/20 p-2 rounded-lg text-center">
            <div class="font-bold text-lg" id="dash-metric-humidity">--%</div>
            <div class="text-xs opacity-90">ÿßŸÑÿ±ÿ∑Ÿàÿ®ÿ©</div>
        </div>
    </div>
</div>
                            </div>
                            <div class="glass-surface glass-surface--svg p-4 flex-grow flex flex-col items-center justify-center text-center navigable grid-item" tabindex="0">
                                <div id="digital-clock-widget" class="w-full h-full flex flex-col items-center justify-center text-center">
                                    <div id="digital-time">
                                        
                                        <span class="hours">00</span>:<span class="minutes">00</span><span id="time-icon-container"></span>
                                    </div>
                                    <div id="digital-date">
                                        <div id="digital-date-line1">  </div>
                                        <div id="digital-date-line2"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Prayer Times Row (Stays at bottom) -->
                        <div class="glass-surface glass-surface--svg p-4 flex flex-col items-center justify-center text-center col-span-full row-start-2 navigable grid-item" tabindex="0">
                            <div id="prayer-times-container" class="prayer-times-row grid-container">
                                <!-- Prayer times will be loaded here by JavaScript -->
                                <p class="text-white/70 col-span-full">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿµŸÑÿßÿ©...</p>
                            </div>
                        </div>


                        <div id="tv" class="glass-surface glass-surface--svg p-4 flex flex-col items-center justify-center text-center car-cam-360-container col-span-1 row-start-1 navigable grid-item" tabindex="0"></div>


                    </div>
                </section>

                <!-- Media (YouTube) Screen -->
                <section id="screen-Media" class="app-screen p-4 md:p-6 flex-col items-center h-full relative">
                    <button 
        id="fullscreen-screen-Media-btn" 
        onclick="toggleFullscreen('screen-Media')"  class="fullscreen-toggle-button navigable grid-item"
        title="Toggle Fullscreen Map"
    >
        <i class="fas fa-expand"></i> 
    </button><!-- NEW: Floating "Back to Search" Button -->
                    <button id="back-to-search-floating-button" class="fixed bottom-6 left-1/2 -translate-x-1/2 bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-5 rounded-full shadow-lg z-50 flex items-center gap-2 navigable grid-item" tabindex="0" style="display: none;">
                        <i data-lucide="arrow-left" class="w-5 h-5"></i>
                        <span>ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑÿ®ÿ≠ÿ´</span>
                    </button>

                    <div class="w-full flex flex-col gap-4">
                        <!-- Search Row -->
                        <div class="w-full flex flex-row items-center gap-2 grid-container flex-shrink-0">
                            <button id="youtube-search-button" class="bg-purple-600 hover:bg-purple-700 text-white p-3 rounded-full transition-colors duration-200 flex items-center justify-center navigable grid-item" tabindex="0">
                                <i data-lucide="search"></i>
                            </button>
                            <button id="clear-search-button" class="navigable grid-item" tabindex="0">
                                <i data-lucide="x" class="w-5 h-5"></i>
                            </button>
                            <input type="text" id="youtube-search-input" placeholder="ÿßÿ®ÿ≠ÿ´ ŸÅŸä ŸäŸàÿ™ŸäŸàÿ®..." class="flex-grow p-3 rounded-full bg-white/10 text-white placeholder-white/50 focus:outline-none focus:ring-2 focus:ring-purple-500 navigable grid-item" tabindex="0" readonly="true" />
                        </div>
                        
                        <div id="youtube-suggestions" class="w-full flex-grow flex flex-col">
    
    <div id="last-watched-container" class="hidden">
        </div>

    <div id="suggestions-content" class="flex flex-col gap-4 w-full">
        </div>

</div>
                        
                    </div>

                    <div id="youtube-video-list-view" class="hidden flex-col items-center justify-center h-full w-full absolute top-0 left-0 p-4 overflow-y-auto gap-4 flex-grow bg-black/50 backdrop-blur-sm">
                        <button id="back-to-playlists-from-videos" class="absolute top-4 left-4 bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-full transition-colors duration-200 flex items-center gap-2 text-sm navigable grid-item z-10" tabindex="0">
                            <i data-lucide="arrow-left" class="w-4 h-4"></i> ÿßŸÑÿπŸàÿØÿ©
                        </button>
                        <h2 class="text-3xl font-bold mb-4 text-center w-full pt-12">ŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ</h2>
                        <div id="video-list-container" class="flex flex-col gap-4 w-full grid-container"></div>
                        <button id="back-to-playlists-bottom-button" class="mt-4 bg-purple-600 hover:bg-purple-700 text-white px-6 py-3 rounded-full transition-colors duration-200 flex items-center justify-center gap-2 text-base navigable grid-item" tabindex="0">
                            <i data-lucide="arrow-left" class="w-5 h-5"></i> ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑÿ®ÿ≠ÿ´
                        </button>
                    </div> 

                    <div id="youtube-search-results-view" class="hidden flex-col h-full w-full absolute top-0 left-0 bg-black/50 backdrop-blur-sm">
                      
                        <div id="search-results-container" class="flex flex-col gap-4 w-full p-4 overflow-y-auto flex-grow grid-container"></div>
                        
                        <!-- NEW: Bottom navigation container -->
                        <div class="w-full grid grid-cols-3 items-center p-2 sticky bottom-0 bg-black/40 backdrop-blur-sm flex-shrink-0 search-results-nav">
                            <!-- Previous Button container -->
                            <div class="flex justify-start">
                                <button id="previous-item-button" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-3 rounded-full transition-all duration-200 flex items-center justify-center gap-2 text-sm navigable grid-item" style="display: none;" tabindex="0"></button>
                            </div>
                            <!-- Back Button container -->
                            <div class="flex justify-center">
                                <button id="back-to-playlists-bottom-button-search" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-3 rounded-full transition-all duration-200 flex items-center justify-center gap-2 text-sm navigable grid-item" tabindex="0">
                                    <i data-lucide="arrow-left" class="w-5 h-5"></i> ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑÿ®ÿ≠ÿ´
                                </button>
                            </div>
                            <!-- Next Button container -->
                            <div class="flex justify-end">
                                <button id="next-item-button" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-3 rounded-full transition-all duration-200 flex items-center justify-center gap-2 text-sm navigable grid-item" style="display: none;" tabindex="0"></button>
                            </div>
                        </div>
                    </div>
                </section>
                
                <!-- Radio Screen -->
                <section id="screen-Radio" class="app-screen items-center justify-center h-full w-full p-4 md:p-6">
       
                   <iframe id="iframe-Radio" class="full-iframe" title="Quran Reciters" src="https://quran.com/radio" allow="geolocation"></iframe>
                             <button 
        id="fullscreen-radio-iframe-btn" 
        onclick="toggleIframeFullscreen('iframe-Radio')"  class="fullscreen-toggle-button navigable grid-item"
        title="Toggle Fullscreen Map"
    >
        <i class="fas fa-expand"></i> 
    </button>
                </section>

                <!-- Athkar Screen -->
                <section id="screen-Athkar" class="app-screen p-4 md:p-6 flex-col items-center h-full">
                    <div class="tabs-container flex p-1 rounded-full bg-black/20 self-center mb-4">
                        <button id="tab-sabah" class="tab-button navigable grid-item tv-focus active" tabindex="0">ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑÿµÿ®ÿßÿ≠</button>
                        <button id="tab-masaa" class="tab-button navigable grid-item" tabindex="0">ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑŸÖÿ≥ÿßÿ°</button>
                        <button id="tab-monthly" class="tab-button navigable grid-item" tabindex="0">ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™ ÿßŸÑÿ¥Ÿáÿ±Ÿäÿ©</button>
                    </div>
                    <div id="athkar-content-container" class="w-full flex-grow overflow-y-auto">
                                     <button 
        id="fullscreen-athkar-btn" 
        onclick="toggleFullscreen('athkar-content-container')"  class="fullscreen-toggle-button navigable grid-item"
        title="Toggle Fullscreen Map"
    >
        <i class="fas fa-expand"></i> 
    </button>
                        <!-- Morning Athkar Panel -->
                        <div id="athkar-sabah-content" class="tab-content athkar-grid"><div id="ts-1" class="athkar-item navigable grid-item athkar-color-1" tabindex="0"><p>ÿ¢Ÿäÿ© ÿßŸÑŸÉÿ±ÿ≥Ÿä</p><span class="repetition">(ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ©)</span></div><div id="ts-2" class="athkar-item navigable grid-item athkar-color-2" tabindex="0"><p>ÿßŸÑŸÑŸáŸÖ ÿ£ÿπŸÜŸä ÿπŸÑŸâ ÿ∞ŸÉÿ±ŸÉ Ÿàÿ¥ŸÉÿ±ŸÉ Ÿàÿ≠ÿ≥ŸÜ ÿπÿ®ÿßÿØÿ™ŸÉ.</p></div><div id="ts-3" class="athkar-item navigable grid-item athkar-color-3" tabindex="0"><p> ÿ≥Ÿàÿ±ÿ© ÿßŸÑÿ•ÿÆŸÑÿßÿµÿå ÿ≥Ÿàÿ±ÿ© ÿßŸÑŸÅŸÑŸÇÿå ÿ≥Ÿàÿ±ÿ© ÿßŸÑŸÜÿßÿ≥</p><span class="repetition">(Ÿ£ ŸÖÿ±ÿßÿ™)</span></div>
                        <div id="ts-4" class="athkar-item navigable grid-item athkar-color-5" tabindex="0"><p>ÿßŸÑŸÑŸáŸÖ ÿ®ŸÉ ÿ£ÿµÿ®ÿ≠ŸÜÿßÿå Ÿàÿ®ŸÉ ÿ£ŸÖÿ≥ŸäŸÜÿßÿå Ÿàÿ®ŸÉ ŸÜÿ≠Ÿäÿßÿå Ÿàÿ®ŸÉ ŸÜŸÖŸàÿ™ÿå Ÿàÿ•ŸÑŸäŸÉ ÿßŸÑŸÜÿ¥Ÿàÿ±.</p></div>
                        <div id="tm-3" class="athkar-item navigable grid-item athkar-color-4" tabindex="0"><p>ÿ≠ÿ≥ÿ®Ÿä ÿßŸÑŸÑŸá ŸÑÿß ÿ•ŸÑŸá ÿ•ŸÑÿß ŸáŸà ÿπŸÑŸäŸá ÿ™ŸàŸÉŸÑÿ™ ŸàŸáŸà ÿ±ÿ® ÿßŸÑÿπÿ±ÿ¥ ÿßŸÑÿπÿ∏ŸäŸÖ</p><span class="repetition">(Ÿß ŸÖÿ±ÿßÿ™)</span></div>
                        
                        <div id="tm-1" class="athkar-item navigable grid-item athkar-color-1" tabindex="0"><p>ÿ®ÿ≥ŸÖ ÿßŸÑŸÑŸá ÿßŸÑÿ∞Ÿä ŸÑÿß Ÿäÿ∂ÿ± ŸÖÿπ ÿßÿ≥ŸÖŸá ÿ¥Ÿäÿ° ŸÅŸä ÿßŸÑÿ£ÿ±ÿ∂ ŸàŸÑÿß ŸÅŸä ÿßŸÑÿ≥ŸÖÿßÿ° ŸàŸáŸà ÿßŸÑÿ≥ŸÖŸäÿπ ÿßŸÑÿπŸÑŸäŸÖ</p><span class="repetition">(Ÿ£ ŸÖÿ±ÿßÿ™)</span></div>
                        <div id="tm-2" class="athkar-item navigable grid-item athkar-color-2" tabindex="0"><p>Ÿäÿß ÿ≠Ÿä Ÿäÿß ŸÇŸäŸàŸÖ ÿ®ÿ±ÿ≠ŸÖÿ™ŸÉ ÿ£ÿ≥ÿ™ÿ∫Ÿäÿ´ÿå ÿ£ÿµŸÑÿ≠ ŸÑŸä ÿ¥ÿ£ŸÜŸä ŸÉŸÑŸá ŸàŸÑÿß ÿ™ŸÉŸÑŸÜŸä ÿ•ŸÑŸâ ŸÜŸÅÿ≥Ÿä ÿ∑ÿ±ŸÅÿ© ÿπŸäŸÜ.</p></div>
                        <div id="tl-1" class="athkar-item navigable grid-item athkar-color-3 col-span-2" tabindex="0"><p>ÿßŸÑŸÑŸáŸÖ ÿπÿßŸÑŸÖ ÿßŸÑÿ∫Ÿäÿ® ŸàÿßŸÑÿ¥ŸáÿßÿØÿ© ŸÅÿßÿ∑ÿ± ÿßŸÑÿ≥ŸÖÿßŸàÿßÿ™ ŸàÿßŸÑÿ£ÿ±ÿ∂ÿå ÿ±ÿ® ŸÉŸÑ ÿ¥Ÿäÿ° ŸàŸÖŸÑŸäŸÉŸáÿå ÿ£ÿ¥ŸáÿØ ÿ£ŸÜ ŸÑÿß ÿ•ŸÑŸá ÿ•ŸÑÿß ÿ£ŸÜÿ™ÿå ÿ£ÿπŸàÿ∞ ÿ®ŸÉ ŸÖŸÜ ÿ¥ÿ± ŸÜŸÅÿ≥Ÿäÿå ŸàŸÖŸÜ ÿ¥ÿ± ÿßŸÑÿ¥Ÿäÿ∑ÿßŸÜ Ÿàÿ¥ÿ±ŸÉŸáÿå Ÿàÿ£ŸÜ ÿ£ŸÇÿ™ÿ±ŸÅ ÿπŸÑŸâ ŸÜŸÅÿ≥Ÿä ÿ≥Ÿàÿ°ÿßŸã ÿ£Ÿà ÿ£ÿ¨ÿ±Ÿá ÿ•ŸÑŸâ ŸÖÿ≥ŸÑŸÖ.</p></div>
                        <div id="tl-2" class="athkar-item navigable grid-item athkar-color-4 col-span-2" tabindex="0"><p>ÿ≥ŸäÿØ ÿßŸÑÿßÿ≥ÿ™ÿ∫ÿ∫ÿßÿ±: ÿßŸÑŸÑŸáŸÖ ÿ£ŸÜÿ™ ÿ±ÿ®Ÿä ŸÑÿß ÿ•ŸÑŸá ÿ•ŸÑÿß ÿ£ŸÜÿ™ÿå ÿÆŸÑŸÇÿ™ŸÜŸä Ÿàÿ£ŸÜÿß ÿπÿ®ÿØŸÉÿå Ÿàÿ£ŸÜÿß ÿπŸÑŸâ ÿπŸáÿØŸÉ ŸàŸàÿπÿØŸÉ ŸÖÿß ÿßÿ≥ÿ™ÿ∑ÿπÿ™ÿå ÿ£ÿπŸàÿ∞ ÿ®ŸÉ ŸÖŸÜ ÿ¥ÿ± ŸÖÿß ÿµŸÜÿπÿ™ÿå ÿ£ÿ®Ÿàÿ° ŸÑŸÉ ÿ®ŸÜÿπŸÖÿ™ŸÉ ÿπŸÑŸäÿå Ÿàÿ£ÿ®Ÿàÿ° ÿ®ÿ∞ŸÜÿ®Ÿä ŸÅÿßÿ∫ŸÅÿ± ŸÑŸäÿå ŸÅÿ•ŸÜŸá ŸÑÿß Ÿäÿ∫ŸÅÿ± ÿßŸÑÿ∞ŸÜŸàÿ® ÿ•ŸÑÿß ÿ£ŸÜÿ™.</p></div>
                        <div id="tsl-1" class="athkar-item navigable grid-item athkar-color-5 col-span-4" tabindex="0"><p>ÿßŸÑŸÑŸáŸÖ ÿ•ŸÜŸä ÿ£ÿ≥ÿ£ŸÑŸÉ ÿßŸÑÿπŸÅŸà ŸàÿßŸÑÿπÿßŸÅŸäÿ© ŸÅŸä ÿßŸÑÿØŸÜŸäÿß ŸàÿßŸÑÿ¢ÿÆÿ±ÿ©ÿå ÿßŸÑŸÑŸáŸÖ ÿ•ŸÜŸä ÿ£ÿ≥ÿ£ŸÑŸÉ ÿßŸÑÿπŸÅŸà ŸàÿßŸÑÿπÿßŸÅŸäÿ© ŸÅŸä ÿØŸäŸÜŸä ŸàÿØŸÜŸäÿßŸä Ÿàÿ£ŸáŸÑŸä ŸàŸÖÿßŸÑŸäÿå ÿßŸÑŸÑŸáŸÖ ÿßÿ≥ÿ™ÿ± ÿπŸàÿ±ÿßÿ™Ÿä Ÿàÿ¢ŸÖŸÜ ÿ±Ÿàÿπÿßÿ™Ÿäÿå ÿßŸÑŸÑŸáŸÖ ÿßÿ≠ŸÅÿ∏ŸÜŸä ŸÖŸÜ ÿ®ŸäŸÜ ŸäÿØŸä ŸàŸÖŸÜ ÿÆŸÑŸÅŸä ŸàÿπŸÜ ŸäŸÖŸäŸÜŸä ŸàÿπŸÜ ÿ¥ŸÖÿßŸÑŸä ŸàŸÖŸÜ ŸÅŸàŸÇŸäÿå Ÿàÿ£ÿπŸàÿ∞ ÿ®ÿπÿ∏ŸÖÿ™ŸÉ ÿ£ŸÜ ÿ£ÿ∫ÿ™ÿßŸÑ ŸÖŸÜ ÿ™ÿ≠ÿ™Ÿä.</p></div>
                        <div id="tsl-2" class="athkar-item navigable grid-item athkar-color-1 col-span-4" tabindex="0"><p>ÿ£ÿµÿ®ÿ≠ŸÜÿß Ÿàÿ£ÿµÿ®ÿ≠ ÿßŸÑŸÖŸÑŸÉ ŸÑŸÑŸáÿå ŸàÿßŸÑÿ≠ŸÖÿØ ŸÑŸÑŸáÿå ŸÑÿß ÿ•ŸÑŸá ÿ•ŸÑÿß ÿßŸÑŸÑŸá Ÿàÿ≠ÿØŸá ŸÑÿß ÿ¥ÿ±ŸäŸÉ ŸÑŸáÿå ŸÑŸá ÿßŸÑŸÖŸÑŸÉ ŸàŸÑŸá ÿßŸÑÿ≠ŸÖÿØ ŸàŸáŸà ÿπŸÑŸâ ŸÉŸÑ ÿ¥Ÿäÿ° ŸÇÿØŸäÿ±. ÿ±ÿ® ÿ£ÿ≥ÿ£ŸÑŸÉ ÿÆŸäÿ± ŸÖÿß ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑŸäŸàŸÖ ŸàÿÆŸäÿ± ŸÖÿß ÿ®ÿπÿØŸáÿå Ÿàÿ£ÿπŸàÿ∞ ÿ®ŸÉ ŸÖŸÜ ÿ¥ÿ± ŸÖÿß ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑŸäŸàŸÖ Ÿàÿ¥ÿ± ŸÖÿß ÿ®ÿπÿØŸáÿå ÿ±ÿ® ÿ£ÿπŸàÿ∞ ÿ®ŸÉ ŸÖŸÜ ÿßŸÑŸÉÿ≥ŸÑ Ÿàÿ≥Ÿàÿ° ÿßŸÑŸÉÿ®ÿ±ÿå ÿ±ÿ® ÿ£ÿπŸàÿ∞ ÿ®ŸÉ ŸÖŸÜ ÿπÿ∞ÿßÿ® ŸÅŸä ÿßŸÑŸÜÿßÿ± Ÿàÿπÿ∞ÿßÿ® ŸÅŸä ÿßŸÑŸÇÿ®ÿ±.</p></div>
                         <div id="tsl-3" class="athkar-item navigable grid-item athkar-color-1 col-span-4" tabindex="0"><p></p></div>

                        </div>
                        
                        <!-- Evening Athkar Panel -->
                        <div id="athkar-masaa-content" class="tab-content athkar-grid hidden">
                         
                            <div id="ts-1" class="athkar-item navigable grid-item athkar-color-1" tabindex="0"><p>ÿ¢Ÿäÿ© ÿßŸÑŸÉÿ±ÿ≥Ÿä</p><span class="repetition">(ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ©)</span></div>
                            <div id="ts-2" class="athkar-item navigable grid-item athkar-color-2" tabindex="0"><p>ÿßŸÑŸÑŸáŸÖ ÿ£ÿπŸÜŸä ÿπŸÑŸâ ÿ∞ŸÉÿ±ŸÉ Ÿàÿ¥ŸÉÿ±ŸÉ Ÿàÿ≠ÿ≥ŸÜ ÿπÿ®ÿßÿØÿ™ŸÉ.</p></div
                            ><div id="ts-3" class="athkar-item navigable grid-item athkar-color-3" tabindex="0"><p>ÿßŸÑŸÖÿπŸàÿ∞ÿßÿ™: ÿ≥Ÿàÿ±ÿ© ÿßŸÑÿ•ÿÆŸÑÿßÿµÿå ÿ≥Ÿàÿ±ÿ© ÿßŸÑŸÅŸÑŸÇÿå ÿ≥Ÿàÿ±ÿ© ÿßŸÑŸÜÿßÿ≥</p><span class="repetition">(Ÿ£ ŸÖÿ±ÿßÿ™)</span></div>
                            <div id="ts-4" class="athkar-item navigable grid-item athkar-color-4" tabindex="0"><p>ÿ≠ÿ≥ÿ®Ÿä ÿßŸÑŸÑŸá ŸÑÿß ÿ•ŸÑŸá ÿ•ŸÑÿß ŸáŸà ÿπŸÑŸäŸá ÿ™ŸàŸÉŸÑÿ™ ŸàŸáŸà ÿ±ÿ® ÿßŸÑÿπÿ±ÿ¥ ÿßŸÑÿπÿ∏ŸäŸÖ</p><span class="repetition">(Ÿß ŸÖÿ±ÿßÿ™)</span>
                            </div><div id="tm-1" class="athkar-item navigable grid-item athkar-color-5" tabindex="0"><p>ÿßŸÑŸÑŸáŸÖ ÿ®ŸÉ ÿ£ŸÖÿ≥ŸäŸÜÿßÿå Ÿàÿ®ŸÉ ÿ£ÿµÿ®ÿ≠ŸÜÿßÿå Ÿàÿ®ŸÉ ŸÜÿ≠Ÿäÿßÿå Ÿàÿ®ŸÉ ŸÜŸÖŸàÿ™ÿå Ÿàÿ•ŸÑŸäŸÉ ÿßŸÑŸÖÿµŸäÿ±.</p></div>
                            <div id="tm-2" class="athkar-item navigable grid-item athkar-color-1" tabindex="0"><p>ÿ®ÿ≥ŸÖ ÿßŸÑŸÑŸá ÿßŸÑÿ∞Ÿä ŸÑÿß Ÿäÿ∂ÿ± ŸÖÿπ ÿßÿ≥ŸÖŸá ÿ¥Ÿäÿ° ŸÅŸä ÿßŸÑÿ£ÿ±ÿ∂ ŸàŸÑÿß ŸÅŸä ÿßŸÑÿ≥ŸÖÿßÿ° ŸàŸáŸà ÿßŸÑÿ≥ŸÖŸäÿπ ÿßŸÑÿπŸÑŸäŸÖ</p><span class="repetition">(Ÿ£ ŸÖÿ±ÿßÿ™)</span></div>
                            <div id="tm-3" class="athkar-item navigable grid-item athkar-color-2" tabindex="0"><p>Ÿäÿß ÿ≠Ÿä Ÿäÿß ŸÇŸäŸàŸÖ ÿ®ÿ±ÿ≠ŸÖÿ™ŸÉ ÿ£ÿ≥ÿ™ÿ∫Ÿäÿ´ÿå ÿ£ÿµŸÑÿ≠ ŸÑŸä ÿ¥ÿ£ŸÜŸä ŸÉŸÑŸá ŸàŸÑÿß ÿ™ŸÉŸÑŸÜŸä ÿ•ŸÑŸâ ŸÜŸÅÿ≥Ÿä ÿ∑ÿ±ŸÅÿ© ÿπŸäŸÜ.</p></div>
                            <div id="tl-1" class="athkar-item navigable grid-item athkar-color-3" tabindex="0"><p>ÿßŸÑŸÑŸáŸÖ ŸÖÿß ÿ£ŸÖÿ≥Ÿâ ÿ®Ÿä ŸÖŸÜ ŸÜÿπŸÖÿ© ÿ£Ÿà ÿ®ÿ£ÿ≠ÿØ ŸÖŸÜ ÿÆŸÑŸÇŸÉ ŸÅŸÖŸÜŸÉ Ÿàÿ≠ÿØŸÉ ŸÑÿß ÿ¥ÿ±ŸäŸÉ ŸÑŸÉÿå ŸÅŸÑŸÉ ÿßŸÑÿ≠ŸÖÿØ ŸàŸÑŸÉ ÿßŸÑÿ¥ŸÉÿ±.</p></div>
                            <div id="tl-2" class="athkar-item navigable grid-item athkar-color-4 col-span-2" tabindex="0"><p>ÿ≥ŸäÿØ ÿßŸÑÿßÿ≥ÿ™ÿ∫ÿ∫ÿßÿ±: ÿßŸÑŸÑŸáŸÖ ÿ£ŸÜÿ™ ÿ±ÿ®Ÿä ŸÑÿß ÿ•ŸÑŸá ÿ•ŸÑÿß ÿ£ŸÜÿ™ÿå ÿÆŸÑŸÇÿ™ŸÜŸä Ÿàÿ£ŸÜÿß ÿπÿ®ÿØŸÉÿå Ÿàÿ£ŸÜÿß ÿπŸÑŸâ ÿπŸáÿØŸÉ ŸàŸàÿπÿØŸÉ ŸÖÿß ÿßÿ≥ÿ™ÿ∑ÿπÿ™ÿå ÿ£ÿπŸàÿ∞ ÿ®ŸÉ ŸÖŸÜ ÿ¥ÿ± ŸÖÿß ÿµŸÜÿπÿ™ÿå ÿ£ÿ®Ÿàÿ° ŸÑŸÉ ÿ®ŸÜÿπŸÖÿ™ŸÉ ÿπŸÑŸäÿå Ÿàÿ£ÿ®Ÿàÿ° ÿ®ÿ∞ŸÜÿ®Ÿä ŸÅÿßÿ∫ŸÅÿ± ŸÑŸäÿå ŸÅÿ•ŸÜŸá ŸÑÿß Ÿäÿ∫ŸÅÿ± ÿßŸÑÿ∞ŸÜŸàÿ® ÿ•ŸÑÿß ÿ£ŸÜÿ™.</p></div>
                            <div id="tsl-1" class="athkar-item navigable grid-item athkar-color-5 col-span-4" tabindex="0"><p>ÿßŸÑŸÑŸáŸÖ ÿ•ŸÜŸä ÿ£ÿ≥ÿ£ŸÑŸÉ ÿßŸÑÿπŸÅŸà ŸàÿßŸÑÿπÿßŸÅŸäÿ© ŸÅŸä ÿßŸÑÿØŸÜŸäÿß ŸàÿßŸÑÿ¢ÿÆÿ±ÿ©ÿå ÿßŸÑŸÑŸáŸÖ ÿ•ŸÜŸä ÿ£ÿ≥ÿ£ŸÑŸÉ ÿßŸÑÿπŸÅŸà ŸàÿßŸÑÿπÿßŸÅŸäÿ© ŸÅŸä ÿØŸäŸÜŸä ŸàÿØŸÜŸäÿßŸä Ÿàÿ£ŸáŸÑŸä ŸàŸÖÿßŸÑŸäÿå ÿßŸÑŸÑŸáŸÖ ÿßÿ≥ÿ™ÿ± ÿπŸàÿ±ÿßÿ™Ÿä Ÿàÿ¢ŸÖŸÜ ÿ±Ÿàÿπÿßÿ™Ÿäÿå ÿßŸÑŸÑŸáŸÖ ÿßÿ≠ŸÅÿ∏ŸÜŸä ŸÖŸÜ ÿ®ŸäŸÜ ŸäÿØŸä ŸàŸÖŸÜ ÿÆŸÑŸÅŸä ŸàÿπŸÜ ŸäŸÖŸäŸÜŸä ŸàÿπŸÜ ÿ¥ŸÖÿßŸÑŸä ŸàŸÖŸÜ ŸÅŸàŸÇŸäÿå Ÿàÿ£ÿπŸàÿ∞ ÿ®ÿπÿ∏ŸÖÿ™ŸÉ ÿ£ŸÜ ÿ£ÿ∫ÿ™ÿßŸÑ ŸÖŸÜ ÿ™ÿ≠ÿ™Ÿä.</p></div>
                            <div id="tsl-2" class="athkar-item navigable grid-item athkar-color-1 col-span-4" tabindex="0"><p>ÿ£ŸÖÿ≥ŸäŸÜÿß Ÿàÿ£ŸÖÿ≥Ÿâ ÿßŸÑŸÖŸÑŸÉ ŸÑŸÑŸáÿå ŸàÿßŸÑÿ≠ŸÖÿØ ŸÑŸÑŸáÿå ŸÑÿß ÿ•ŸÑŸá ÿ•ŸÑÿß ÿßŸÑŸÑŸá Ÿàÿ≠ÿØŸá ŸÑÿß ÿ¥ÿ±ŸäŸÉ ŸÑŸáÿå ŸÑŸá ÿßŸÑŸÖŸÑŸÉ ŸàŸÑŸá ÿßŸÑÿ≠ŸÖÿØ ŸàŸáŸà ÿπŸÑŸâ ŸÉŸÑ ÿ¥Ÿäÿ° ŸÇÿØŸäÿ±. ÿ±ÿ® ÿ£ÿ≥ÿ£ŸÑŸÉ ÿÆŸäÿ± ŸÖÿß ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÑŸäŸÑÿ© ŸàÿÆŸäÿ± ŸÖÿß ÿ®ÿπÿØŸáÿßÿå Ÿàÿ£ÿπŸàÿ∞ ÿ®ŸÉ ŸÖŸÜ ÿ¥ÿ± ŸÖÿß ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÑŸäŸÑÿ© Ÿàÿ¥ÿ± ŸÖÿß ÿ®ÿπÿØŸáÿßÿå ÿ±ÿ® ÿ£ÿπŸàÿ∞ ÿ®ŸÉ ŸÖŸÜ ÿßŸÑŸÉÿ≥ŸÑ Ÿàÿ≥Ÿàÿ° ÿßŸÑŸÉÿ®ÿ±ÿå ÿ±ÿ® ÿ£ÿπŸàÿ∞ ÿ®ŸÉ ŸÖŸÜ ÿπÿ∞ÿßÿ® ŸÅŸä ÿßŸÑŸÜÿßÿ± Ÿàÿπÿ∞ÿßÿ® ŸÅŸä ÿßŸÑŸÇÿ®ÿ±.</p></div>
                            <div id="tsl-4" class="athkar-item navigable grid-item athkar-color-1 col-span-4" tabindex="0"><p></p></div>

                            </div> <!-- NEW: Monthly Reminders Panel -->
                        <div id="athkar-monthly-content" class="tab-content athkar-grid-monthly hidden">
                            <div class="athkar-item navigable grid-item header col-span-5" tabindex="0"><p>ÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™ Ÿàÿ£ÿπŸÖÿßŸÑ ÿ¥Ÿáÿ±Ÿäÿ©</p></div>
                            <div class="athkar-item navigable grid-item athkar-color-1" tabindex="0"><p>ÿßŸÑÿµÿØŸÇÿ© ÿßŸÑÿ¥Ÿáÿ±Ÿäÿ©</p></div>
                            <div class="athkar-item navigable grid-item athkar-color-2" tabindex="0"><p>ÿµŸäÿßŸÖ ÿßŸÑÿ£ŸäÿßŸÖ ÿßŸÑÿ®Ÿäÿ∂</p><span class="repetition">(Ÿ°Ÿ£ÿå Ÿ°Ÿ§ÿå Ÿ°Ÿ•)</span></div>
                            <div class="athkar-item navigable grid-item athkar-color-3" tabindex="0"><p>ŸÇÿ±ÿßÿ°ÿ© ÿ≥Ÿàÿ±ÿ© ÿßŸÑŸÉŸáŸÅ</p><span class="repetition">(ŸÉŸÑ ÿ¨ŸÖÿπÿ©)</span></div>
                            <div class="athkar-item navigable grid-item athkar-color-4" tabindex="0"><p>ÿµŸÑÿ© ÿßŸÑÿ±ÿ≠ŸÖ</p></div>
                            <div class="athkar-item navigable grid-item athkar-color-5" tabindex="0"><p> ÿ≠ŸÅÿ∏ ÿßŸÑŸÇÿ±ÿ£ŸÜ </p></div>
                            <div class="athkar-item navigable grid-item athkar-color-1 col-span-2" tabindex="0"><p>ÿ¨ŸÑÿ≥ÿ© ŸÖÿ≠ÿßÿ≥ÿ®ÿ© ŸÑŸÑŸÜŸÅÿ≥</p></div>
                            <div class="athkar-item navigable grid-item athkar-color-2" tabindex="0"><p>ÿßŸÑÿ™ÿÆÿ∑Ÿäÿ∑ ŸÑŸÑÿ¥Ÿáÿ± ÿßŸÑÿ¨ÿØŸäÿØ</p></div>
                            <div class="athkar-item navigable grid-item athkar-color-3 col-span-2" tabindex="0"><p>ÿ™ÿπŸÑŸÖ ŸÖÿ≥ÿ£ŸÑÿ© ŸÅŸÇŸáŸäÿ© ÿ¨ÿØŸäÿØÿ©</p></div>
                            <div id="tsl-5" class="athkar-item navigable grid-item athkar-color-1 col-span-4" tabindex="0"><p></p></div>

                        </div>
                    </div>
                </section>

                <!-- Reciters Screen -->
               
                <section id="screen-Reciters" class="app-screen p-4 md:p-6 flex-col items-center justify-center h-full w-full">
<button 
        id="fullscreen-reciters-iframe-btn" 
        onclick="toggleIframeFullscreen('reciters-iframe')"  class="fullscreen-toggle-button navigable grid-item"
        title="Toggle Fullscreen Map"
    >
        
    </button>
<iframe id="reciters-iframe"
            class="full-iframe flex-grow"
            onclick="toggleIframeFullscreen('reciters-iframe')"  class="fullscreen-toggle-button navigable grid-item"
            title="Reciters/TV"
            src="https://www.bein-live.com/"
            allow="geolocation; fullscreen"  allowfullscreen="true"          webkitallowfullscreen="true"    mozallowfullscreen="true">  
            <i class="fas fa-expand"></i> 
                </iframe>
    
    <div class="mb-4 flex flex-wrap justify-center gap-2 flex-shrink-0 grid-container" style="
    transform: scale(1.1);
">
        <button data-src="https://www.bein-live.com/" class="iframe-src-button bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-full transition-colors duration-200 text-sm navigable grid-item active" tabindex="0">
            ŸÖÿ®ÿßÿ±Ÿäÿßÿ™
        </button>
        <button data-src="https://tgyh.kora1goal.com/albaplayer/sports-c1/" class="iframe-src-button bg-black-600 hover:bg-black-700 text-white px-4 py-2 rounded-full transition-colors duration-200 text-sm navigable grid-item" tabindex="0">
            ÿ´ŸÖÿßŸÜŸäÿ© 1
        </button>
         <button data-src="https://direct.aflam4you.net/zremb472.php?vid=68&aflam_s=1&aflam_w=360&aflam_h=250&aflam_k=1831551111111" class="iframe-src-button bg-purple-700 hover:bg-purple-800 text-white px-4 py-2 rounded-full transition-colors duration-200 text-sm navigable grid-item" tabindex="0">
            beIN 1
        </button>
        <button data-src="hhttps://direct.aflam4you.net/playeraf.php?vid=2&aflam_s=1&aflam_k=345543234455" class="iframe-src-button bg-purple-700 hover:bg-purple-800 text-white px-4 py-2 rounded-full transition-colors duration-200 text-sm navigable grid-item" tabindex="0">
            beIN 2
        </button>

        <button data-src="https://tgyh.kora1goal.com/albaplayer/sports-3/" class="iframe-src-button bg-purple-700 hover:bg-purple-800 text-white px-4 py-2 rounded-full transition-colors duration-200 text-sm navigable grid-item" tabindex="0">
            beIN 3
        </button>
        <button data-src="https://player.mangomolo.com/v1/live?id=MTY4&channelid=MTYx&countries=Q0M=&w=100%25&h=100%25&filter=DENY&signature=3fd1e8dd84138a41bf33d93afd4a7f09&language=en&app_id=&fullscreen=yes&player_profile=&base_url=aHR0cHM6Ly9heW4ub20vbGl2ZS8xNjEvJUQ5JTgyJUQ5JTg2JUQ4JUE3JUQ4JUE5LSVEOCVCOSVEOSU4NSVEOCVBNyVEOSU4Ni0lRDklODUlRDglQTglRDglQTclRDglQjQlRDglQjE=&autoplay=true&vast=true" class="iframe-src-button bg-red-800 hover:bg-red-900 text-white px-4 py-2 rounded-full transition-colors duration-200 text-sm navigable grid-item" tabindex="0">
            ÿπŸÖÿßŸÜ ŸÖÿ®ÿßÿ¥ÿ±
        </button>
        <button data-src="https://play.arab-stream.live/p/mbc-1-ksa.html" class="iframe-src-button bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-full transition-colors duration-200 text-sm navigable grid-item" tabindex="0">
            MBC 1
        </button>
        <button data-src="https://www.youtube.com/embed/Vs5yyRNUY2Q?rel=0&autoplay=1" class="iframe-src-button bg-yellow-800 hover:bg-yellow-900 text-white px-4 py-2 rounded-full transition-colors duration-200 text-sm navigable grid-item" tabindex="0">
            ÿßŸÑŸÇÿ±ÿßŸÜ ÿßŸÑŸÉÿ±ŸäŸÖ
        </button>
    
        <button data-src="https://tgyh.kora1goal.com/albaplayer/sports-c2/" class="iframe-src-button bg-green-700 hover:bg-green-800 text-white px-4 py-2 rounded-full transition-colors duration-200 text-sm navigable grid-item" tabindex="0">
            ÿ´ŸÖÿßŸÜŸäÿ© 2
        </button>
        <button data-src="https://tgyh.kora1goal.com/albaplayer/sports-c3/" class="iframe-src-button bg-green-700 hover:bg-green-800 text-white px-4 py-2 rounded-full transition-colors duration-200 text-sm navigable grid-item" tabindex="0">
            ÿ´ŸÖÿßŸÜŸäÿ© 3
        </button>
       
        <button data-src="https://direct.aflam4you.net/zremb472.php?vid=500&aflam_s=1&aflam_w=360&aflam_h=250&aflam_k=1831551111111" class="iframe-src-button bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-2 rounded-full transition-colors duration-200 text-sm navigable grid-item" tabindex="0">
            MBC ACTION
        </button>
        <button data-src="https://direct.aflam4you.net/browse-watch-koora_live-tv-live-videos-1-date.html" class="iframe-src-button bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-full transition-colors duration-200 text-sm navigable grid-item" tabindex="0">
           OTHERS 
        </button>
        </div>

</section>

                <!-- Weather Screen -->
                <section id="screen-Weather" class="app-screen p-4 md:p-6 flex-col items-center justify-start h-full">
                  
                    <div class="w-full h-full flex flex-col gap-4 flex-grow">
                        <!-- Hourly Forecast -->
                        <div id="hourly-forecast-container" class="grid grid-cols-7 gap-2 w-full glass-surface glass-surface--svg p-3 rounded-3xl">
                            <!-- JS will populate this -->
                            <div class="text-center text-white/70 col-span-7">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ™ŸàŸÇÿπÿßÿ™...</div>
                        </div>
                        <!-- Location Temperatures -->
                        <div id="location-temps-container" class="grid grid-cols-2 sm:grid-cols-4 gap-4 w-full flex-grow">
                            <!-- JS will populate this -->
                            <div class="text-center text-white/70 col-span-full">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¨ÿØŸäÿØÿ©...</div>
                        </div>
                    </div>
                </section>

                <!-- 3D Screen (Formerly Map Screen) -->
                <section id="screen-Map" class="app-screen p-4 md:p-6 flex-col h-full items-center justify-center relative">
                    <button 
        id="fullscreen-map-btn" 
        onclick="toggleIframeFullscreen('screen-Map')"  class="fullscreen-toggle-button navigable grid-item"
        title="Toggle Fullscreen Map"
    >
        <i class="fas fa-expand"></i> 
    </button>
                    <div class="w-full h-full bg-black2 rounded-3xl flex items-center justify-center p-1 overflow:hidden">
                        <iframe id="cardash" title="LEXSUS ES" frameborder="0" allowfullscreen mozallowfullscreen="true" webkitallowfullscreen="true" allow="autoplay; fullscreen; xr-spatial-tracking" xr-spatial-tracking execution-while-out-of-viewport execution-while-not-rendered web-share WIDTH="80%" HEIGHT="80%" src="https://sketchfab.com/models/17ed331fd31f491fa3907156f0b0b55e/embed?autostart=1&preload=1&annotations_visible=0&annotation=0&annotation_cycle=6&transparent=1&ui_theme=dark"> </iframe>
                    </div>
                    <!-- Right side widget -->
                    <div id="3d-screen-weather-widget" class="absolute top-8 right-8 p-4 rounded-2xl text-center flex items-center gap-3 z-10 navigable grid-item" tabindex="0">
                        <!-- MODIFIED: Replaced icon with user-provided SVG -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-lucide="thermometer" class="lucide lucide-thermometer w-8 h-8 text-red-400"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"></path></svg>
                        <span class="text-3xl font-bold" id="3d-screen-weather-temp">--¬∞C</span>
                    </div>
                    <!-- NEW: Left side widgets -->
                    <div id="3d-screen-info-widgets" class="absolute top-8 left-8 flex flex-col gap-3 z-10">
                        <div class="p-3 rounded-2xl text-center flex items-center gap-3 navigable grid-item" tabindex="0">
                            <i data-lucide="moon" class="w-7 h-7 text-cyan-300"></i>
                            <div>
                                <div class="text-sm text-white/70">ÿßŸÑÿµŸÑÿßÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©</div>
                                <div class="text-xl font-bold" id="3d-screen-next-prayer">--</div>
                            </div>
                        </div>
                        <div class="p-3 rounded-2xl text-center flex items-center gap-3 navigable grid-item" tabindex="0">
                            <i data-lucide="gauge-circle" class="w-7 h-7 text-green-400"></i>
                            <div>
                                <div class="text-sm text-white/70">ÿßŸÑÿ≥ÿ±ÿπÿ©</div>
                                <div class="text-xl font-bold" id="3d-screen-speed">-- km/h</div>
                            </div>
                        </div>
                         <div id="geares" class="p-3 rounded-2xl text-center flex items-center gap-3 navigable grid-item" tabindex="0">
                            <i data-lucide="parking-circle" class="w-7 h-7 text-orange-400"></i>
                            <div>
                                <div class="text-sm text-white/70">ÿßŸÑŸÇŸäÿ±</div>
                                <div class="text-xl font-bold" id="3d-screen-gear">--</div>
                            </div>
                        </div>
                        <!-- NEW: Direction Widget -->
                        <div class="p-3 rounded-2xl text-center flex items-center gap-3 navigable grid-item" tabindex="0">
                            <i data-lucide="compass" class="w-7 h-7 text-blue-300"></i>
                            <div>
                                <div class="text-sm text-white/70">ÿßŸÑÿßÿ™ÿ¨ÿßŸá</div>
                                <div class="text-xl font-bold" id="3d-screen-dir">--</div>
                            </div>
                        </div>
                    </div>
                    <!-- NEW: Sticky Directional Controls -->
                    <div id="direction-controls-3d" class="absolute top-1/2 -translate-y-1/2 right-8 grid grid-cols-3 gap-2 w-[120px] z-10">
                        <button class="glass-surface glass-surface--svg p-2 rounded-full w-10 h-10 flex items-center justify-center text-sm font-bold navigable grid-item" tabindex="0">NW</button>
                        <button class="glass-surface glass-surface--svg p-2 rounded-full w-10 h-10 flex items-center justify-center text-sm font-bold navigable grid-item" tabindex="0">N</button>
                        <button class="glass-surface glass-surface--svg p-2 rounded-full w-10 h-10 flex items-center justify-center text-sm font-bold navigable grid-item" tabindex="0">NE</button>
                        <button class="glass-surface glass-surface--svg p-2 rounded-full w-10 h-10 flex items-center justify-center text-sm font-bold navigable grid-item" tabindex="0">W</button>
                        <div class="w-10 h-10"></div> <!-- Spacer -->
                        <button class="glass-surface glass-surface--svg p-2 rounded-full w-10 h-10 flex items-center justify-center text-sm font-bold navigable grid-item" tabindex="0">E</button>
                        <button class="glass-surface glass-surface--svg p-2 rounded-full w-10 h-10 flex items-center justify-center text-sm font-bold navigable grid-item" tabindex="0">SW</button>
                        <button class="glass-surface glass-surface--svg p-2 rounded-full w-10 h-10 flex items-center justify-center text-sm font-bold navigable grid-item" tabindex="0">S</button>
                        <button class="glass-surface glass-surface--svg p-2 rounded-full w-10 h-10 flex items-center justify-center text-sm font-bold navigable grid-item" tabindex="0">SE</button>
                    </div>
                </section>

                <!-- Electronic Quran App Screen -->
                <section id="screen-Quran" class="app-screen flex-col items-center justify-center h-full relative">
                               <button 
        id="fullscreen-screen-Quran-btn" 
        onclick="toggleIframeFullscreen('quran-iframe')"  class="fullscreen-toggle-button navigable grid-item"
        title="Toggle Fullscreen Map"
    >
        <i class="fas fa-expand"></i> 
    </button>
                   <div id="quran-quick-access" class="mt-4 bg-black/30 p-4 rounded-xl flex flex-col gap-3 items-end z-20 glass-surface glass-surface--svg w-full max-w-md">
                        <button id="quran-go-button" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-full transition-colors duration-200 flex items-center gap-2 text-sm self-center navigable grid-item" tabindex="0"></button>
                    </div>
                    <div class="w-full h-full glass-surface glass-surface--svg p-4 rounded-xl flex flex-col items-center flex-grow" style="height: 100%!important;">
                        <iframe id="quran-iframe" class="full-iframe" src="https://quran.com/?lang=ar" lang="ar" title="ÿßŸÑŸÇÿ±ÿ¢ŸÜ ÿßŸÑŸÉÿ±ŸäŸÖ" frameborder="0" allow="fullscreen; picture-in-picture"></iframe>
                    </div>
                </section>

            </main>

            <!-- Navigation Dock (Left Sidebar) -->
            <nav class="w-20 sm:w-24 bg-black/20 flex flex-col items-center justify-start pt-8 p-2 space-y-4 border-l border-white/10 flex-shrink-0 transition-opacity 0.3s ease grid-container">
                <button data-app="Dashboard" class="app-icon navigable grid-item" tabindex="0">
                    <i data-lucide="layout-grid"></i>
                </button>
                <button data-app="Media" class="app-icon navigable grid-item" tabindex="0">
                    <i data-lucide="play-circle"></i>
                </button>
                 <button data-app="Radio" class="app-icon navigable grid-item" tabindex="0">
                    <i data-lucide="radio"></i>
                </button>
                <button data-app="Athkar" class="app-icon navigable grid-item" tabindex="0">
                    <i data-lucide="book-heart"></i>
                </button>
                <button data-app="Reciters" class="app-icon navigable grid-item" tabindex="0"> 
                    <i data-lucide="tv"></i> 
                </button>
                <button data-app="Weather" class="app-icon navigable grid-item" tabindex="0"> 
                    <i data-lucide="cloud-sun"></i> 
                </button>
                <button data-app="Map" class="app-icon navigable grid-item" tabindex="0">
                    <i data-lucide="map"></i> 
                </button>
                <button data-app="Quran" class="app-icon navigable grid-item" tabindex="0">
                    <i data-lucide="book-open"></i>
                </button>
            </nav>
        </div>
    </div>

    <!-- Floating UI Elements -->
    <button id="floating-media-button" class="glass-surface glass-surface--svg rounded-full navigable grid-item" tabindex="0">
        <i data-lucide="youtube" class="w-6 h-6"></i>
    </button>
    <button id="floating-keyboard-button" class="glass-surface glass-surface--svg rounded-full navigable grid-item" tabindex="0">
        <i data-lucide="keyboard" class="w-6 h-6"></i>
    </button>
    <button id="start-trip-floating-button" class="glass-surface glass-surface--svg rounded-full navigable grid-item" tabindex="0">
        <i data-lucide="map-pin" class="w-6 h-6"></i> ÿ®ÿØÿ° ÿßŸÑÿ±ÿ≠ŸÑÿ©
    </button>

    <!-- NEW: Minimized Video Button -->
    <button id="floating-minimized-video-button" class="navigable grid-item" tabindex="0">
        <i data-lucide="arrow-up-right" class="w-5 h-5 flex-shrink-0"></i>
        <span class="minimized-title">...</span>
    </button>

    <!-- NEW: Bottom Left Controls -->
    <div id="bottom-left-controls" class="fixed bottom-4 left-4 flex flex-row gap-2 z-[100] grid-container">
        <button id="pause-animation-button" class="glass-surface glass-surface--svg rounded-full p-3 navigable grid-item" tabindex="0" title="ÿ•ŸäŸÇÿßŸÅ/ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ≠ÿ±ŸÉÿ©">
            <i data-lucide="play" class="w-5 h-5"></i>
            <i data-lucide="pause" class="w-5 h-5 hidden"></i>
        </button>
        <button id="zoom-in-button" class="glass-surface glass-surface--svg rounded-full p-3 navigable grid-item" tabindex="0" title="ÿ™ŸÉÿ®Ÿäÿ±">
            <i data-lucide="zoom-in" class="w-5 h-5"></i>
        </button>
        <button id="zoom-out-button" class="glass-surface glass-surface--svg rounded-full p-3 navigable grid-item" tabindex="0" title="ÿ™ÿµÿ∫Ÿäÿ±">
            <i data-lucide="zoom-out" class="w-5 h-5"></i>
        </button>
        <button id="remove-cache-button" class="glass-surface glass-surface--svg rounded-full p-3 navigable grid-item" tabindex="0" title="ŸÖÿ≥ÿ≠ ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™">
            <i data-lucide="trash-2" class="w-5 h-5"></i>
        </button>
    </div>

    <!-- Video Pop-up Container -->
    <div id="video-popup-container">
        <div id="video-popup-player-container"></div>
        <div class="video-popup-controls grid-container">
            <button id="video-popup-close-button" title="ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑŸÅŸäÿØŸäŸà" class="navigable grid-item" tabindex="0">
                <i data-lucide="x" class="w-4 h-4"></i>
            </button>
        </div>
    </div>

    <script>
        /**
 * Toggles a section element between its normal state and fullscreen mode.
 * * @param {string} sectionId - The ID of the section element (e.g., 'screen-Dashboard').
 */
/**
 * Function 2: Toggles fullscreen mode specifically for an IFRAME element.
 * (This function is generic and will work on 'reciters-iframe')
 * @param {string} targetId - The ID of the IFRAME element.
 */
/**
 * Converts a 24-hour time string (HH:MM) to a 12-hour time string (H:MM ÿµ/ŸÖ).
 *
 * @param {string} time24h - Time in 24-hour format (e.g., "15:36").
 * @returns {string} Time in 12-hour format with 'ÿµ' or 'ŸÖ' (e.g., "3:36 ŸÖ").
 */
function convertTo12HourWithAmPm(time24h) {
    if (!time24h || typeof time24h !== 'string' || time24h === '--:--') {
        return time24h; 
    }

    // Split the time string into hours and minutes
    const [hours24, minutes] = time24h.split(':').map(str => parseInt(str, 10));
    
    // Determine AM/PM (ÿµ/ŸÖ)
    const suffix = hours24 >= 12 ? 'ŸÖ' : 'ÿµ';
    
    // Convert to 12-hour format (0 = 12 AM, 13 = 1 PM)
    let hours12 = hours24 % 12;
    hours12 = hours12 ? hours12 : 12; // The hour '0' (midnight) should be '12'

    // Return the formatted string
    return `${hours12}:${minutes.toString().padStart(2, '0')} ${suffix}`;
}
// -------------------------------------------------------------
// --- NEW updateTimerDisplay function ---
// -------------------------------------------------------------
/**
 * UPDATED: Updates the digital clock countdown/count-up display separately.
 * Runs every 2 seconds ONLY IF THE VIDEO POPUP IS NOT ACTIVE.
 */
function updateTimerDisplay() {
    // üõë ÿßŸÑÿ¥ÿ±ÿ∑ ÿßŸÑÿ≠ÿßÿ≥ŸÖ: ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ¥ÿ∫ŸÑ ÿßŸÑŸÖŸÜÿ®ÿ´ŸÇ ŸÜÿ¥ÿ∑ÿßŸãÿå ŸÇŸÖ ÿ®ÿßŸÑÿÆÿ±Ÿàÿ¨ ŸÅŸàÿ±ÿßŸã ŸÑÿ™ÿ¨ŸÜÿ® ÿßŸÑÿ™ŸÇÿ∑Ÿäÿπ
    if (videoPopupContainer.classList.contains('active')) {
        return;
    }
    
    const now = new Date();
    // ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ determineNextPrayer ŸÇÿØ ÿπŸÖŸÑÿ™ ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ
    if (!appState.prayerTimes.nextPrayerIqamaTime) {
        return;
    }

    const diff = appState.prayerTimes.nextPrayerIqamaTime - now;
    const totalSecs = Math.floor(diff / 1000);
    
    // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿ£ŸÜŸÖÿßÿ∑ ÿßŸÑÿ£ŸÑŸàÿßŸÜ ŸÇÿ®ŸÑ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´
    digitalDateLine1.classList.remove('countdown-azan', 'countdown-iqama', 'countdown-up');
    digitalDateLine2.classList.remove('countdown-azan', 'countdown-iqama', 'countdown-up');

    // 1. Logic for COUNT UP (after Iqama)
    if (appState.prayerTimes.currentPrayer && appState.prayerTimes.currentPrayerIqamaTime && now > appState.prayerTimes.currentPrayerIqamaTime) {
        const diffUp = now - appState.prayerTimes.currentPrayerIqamaTime;
        const upSecs = Math.floor(diffUp / 1000);
        const secs = upSecs % 60;
        const mins = Math.floor(upSecs / 60);

        digitalDateLine1.textContent = `ÿßŸÜÿ™Ÿáÿ™ ÿßŸÇÿßŸÖÿ© ÿßŸÑÿµŸÑÿßÿ© ${appState.prayerTimes.currentPrayer} ŸÖŸÜÿ∞:`;
        digitalDateLine2.textContent = `+${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        digitalDateLine1.classList.add('countdown-up');
        digitalDateLine2.classList.add('countdown-up');
        return;
    }

    // 2. Logic for COUNT DOWN (to Azan or Iqama)
    if (totalSecs >= 0) {
        const secs = totalSecs % 60;
        const mins = Math.floor((totalSecs / 60) % 60);
        const hrs = Math.floor(totalSecs / 3600);
        
        const isCountdownToIqama = (appState.prayerTimes.currentPrayer === appState.prayerTimes.nextPrayer);

        if (isCountdownToIqama) {
            digitalDateLine1.textContent = `ÿ•ŸÇÿßŸÖÿ© ÿµŸÑÿßÿ© ${appState.prayerTimes.currentPrayer} ŸÅŸä:`;
            digitalDateLine2.textContent = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            digitalDateLine1.classList.add('countdown-iqama');
            digitalDateLine2.classList.add('countdown-iqama');
        } else {
            digitalDateLine1.textContent = `ÿßŸÑÿ£ÿ∞ÿßŸÜ ÿßŸÑŸÇÿßÿØŸÖ: ${appState.prayerTimes.nextPrayer}`;
            digitalDateLine2.textContent = hrs > 0 ? `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}` : `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            digitalDateLine1.classList.add('countdown-azan');
            digitalDateLine2.classList.add('countdown-azan');
        }
    }
}

function toggleIframeFullscreen(targetId) {
    const targetElement = document.getElementById(targetId);
    const body = document.body;

    if (targetElement) {
        // We toggle the is-fullscreen class on the target element (the iframe)
        targetElement.classList.toggle('is-fullscreen');
        
        // We toggle fullscreen-mode on the body to hide global elements
        body.classList.toggle('fullscreen-mode');

        // Optional: Icon update logic here (using a generic button ID if possible)
        const buttonId = `fullscreen-btn-${targetId}`;
        const icon = document.querySelector(`#${buttonId} .fas`); 
        
        if (icon) {
            if (targetElement.classList.contains('is-fullscreen')) {
                icon.classList.remove('fa-expand');
                icon.classList.add('fa-compress');
            } else {
                icon.classList.remove('fa-compress');
                icon.classList.add('fa-expand');
            }
        }
    } else {
        console.error(`Error: Element with ID ${targetId} not found.`);
    }
}
        
function toggleFullscreen(sectionId) {
    const section = document.getElementById(sectionId);
    const body = document.body;

    if (section) {
        // Toggle the fullscreen class on the section
        section.classList.toggle('is-fullscreen');
        
        // Toggle a class on the body to handle hiding global elements like the navigation bar
        body.classList.toggle('fullscreen-mode');

        // Optional: Update the button icon to indicate the state
        const icon = document.querySelector(`#fullscreen-${sectionId}-btn .fas`);
        if (icon) {
            if (section.classList.contains('is-fullscreen')) {
                // Change to exit fullscreen icon
                icon.classList.remove('fa-expand');
                icon.classList.add('fa-compress');
            } else {
                // Change back to expand icon
                icon.classList.remove('fa-compress');
                icon.classList.add('fa-expand');
            }
        }

        console.log(`${sectionId} is now in fullscreen mode: ${section.classList.contains('is-fullscreen')}`);
    } else {
        console.error(`Error: Section with ID ${sectionId} not found.`);
    }
}
/**
 * ÿØÿßŸÑÿ© JavaScript ŸÑŸÖŸÜÿπ ÿßŸÑŸÜŸàÿßŸÅÿ∞ ÿßŸÑŸÖŸÜÿ®ÿ´ŸÇÿ© ŸàÿßŸÑÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿØÿßÿÆŸÑ
 * 
 * 
 *  ÿßŸÑÿµŸÅÿ≠ÿ©.
 * ÿ™ÿ≥ÿ™ŸáÿØŸÅ ÿßŸÑÿπŸÜÿßÿµÿ± ÿ∞ÿßÿ™ ÿßŸÑÿÆÿµÿßÿ¶ÿµ ÿßŸÑÿ¥ÿßÿ¶ÿπÿ© ŸÑŸÑÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿßŸÑŸÖŸÜÿ®ÿ´ŸÇÿ© (ŸÖÿ´ŸÑ ÿßŸÑÿ™ÿ´ÿ®Ÿäÿ™ ÿπŸÑŸâ ÿßŸÑÿ¥ÿßÿ¥ÿ©).
 */
function blockInPagePopups() {
    // 1. ŸÇÿßÿ¶ŸÖÿ© ÿ®ŸÅÿ¶ÿßÿ™ CSS (classes) ÿßŸÑÿ¥ÿßÿ¶ÿπÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ≥ÿ™ÿÆÿØŸÖŸáÿß ÿßŸÑÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿßŸÑŸÖŸÜÿ®ÿ´ŸÇÿ©
    const adClasses = [
        '.ad-container',         // ÿ≠ÿßŸàŸäÿßÿ™ ÿßŸÑÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿßŸÑÿπÿßŸÖÿ©
        '.popup-ad-wrapper',     // ŸÖÿ∫ŸÑŸÅÿßÿ™ ÿßŸÑÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿßŸÑŸÖŸÜÿ®ÿ´ŸÇÿ©
        '#div-gpt-ad',           // ŸÖŸèÿπÿ±ŸÅÿßÿ™ (IDs) ÿ¥ÿßÿ¶ÿπÿ© ŸÑÿ£ŸÜÿ∏ŸÖÿ© ÿ•ÿπŸÑÿßŸÜÿßÿ™ ŸÖÿπŸäŸÜÿ©
        '.fixed-ad',             // ÿ•ÿπŸÑÿßŸÜÿßÿ™ ŸÖŸèÿ´ÿ®ÿ™ÿ© (Fixed) ÿ∫ÿßŸÑÿ®Ÿãÿß ŸÖÿß ÿ™ŸÉŸàŸÜ ŸÖÿ≤ÿπÿ¨ÿ©
        // ŸäŸÖŸÉŸÜŸÉ ÿ•ÿ∂ÿßŸÅÿ© ÿ£Ÿä ŸÅÿ¶ÿßÿ™ ÿ£Ÿà ŸÖŸèÿπÿ±ŸÅÿßÿ™ ÿ™ŸÑÿßÿ≠ÿ∏Ÿáÿß ŸÅŸä ÿ•ÿπŸÑÿßŸÜÿßÿ™ ŸÖŸàŸÇÿπŸÉ ŸáŸÜÿß
    ];

    // 2. ŸÖÿ≠ÿØÿØÿßÿ™ (Selectors) ÿ™ÿ≥ÿ™ŸáÿØŸÅ ÿßŸÑÿπŸÜÿßÿµÿ± ÿ∞ÿßÿ™ ÿßŸÑŸÜŸÖÿ∑ ÿßŸÑÿ´ÿßÿ®ÿ™ ŸàÿßŸÑÿ¥ŸÅÿßŸÅŸäÿ© ÿßŸÑÿπÿßŸÑŸäÿ© (ŸÇÿØ ÿ™ŸÉŸàŸÜ ÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿ£Ÿà ÿ£ÿ∫ÿ∑Ÿäÿ© ŸÑÿ•ÿπŸÑÿßŸÜÿßÿ™)
    const fixedSelectors = [
        'div[style*="position: fixed"]',      // ÿ£Ÿä ÿπŸÜÿµÿ± div ÿ∞Ÿà ÿ™ÿ´ÿ®Ÿäÿ™ ŸÖÿ∑ŸÑŸÇ
        'div[style*="z-index: 9999"]',        // ÿ£Ÿä ÿπŸÜÿµÿ± ÿ∞Ÿà ŸÇŸäŸÖÿ© z-index ÿπÿßŸÑŸäÿ© ÿ¨ÿØŸãÿß
        'div[id*="ad-"]'                      // ÿ£Ÿä ÿπŸÜÿµÿ± Ÿäÿ≠ÿ™ŸàŸä ID ÿπŸÑŸâ ŸÉŸÑŸÖÿ© 'ad-'
    ];

    // ÿØŸÖÿ¨ ÿ¨ŸÖŸäÿπ ŸÖÿ≠ÿØÿØÿßÿ™ ÿßŸÑÿ•ÿπŸÑÿßŸÜÿßÿ™ ŸÅŸä ŸÖÿ≠ÿØÿØ Ÿàÿßÿ≠ÿØ
    const allAdSelectors = adClasses.join(', ') + ', ' + fixedSelectors.join(', ');

    // 3. ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÜÿßÿµÿ± ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ© ŸÑŸÑŸÖÿ≠ÿØÿØÿßÿ™
    const adElements = document.querySelectorAll(allAdSelectors);

    if (adElements.length > 0) {
        console.log(`Coding Partner: ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ${adElements.length} ÿπŸÜÿßÿµÿ± ÿ•ÿπŸÑÿßŸÜŸäÿ© ŸÖÿ¥ÿ™ÿ®Ÿá ÿ®Ÿáÿß. ÿ¨ÿßÿ±Ÿä ÿ•ÿÆŸÅÿßÿ§Ÿáÿß...`);
        
        // 4. ÿßŸÑŸÖÿ±Ÿàÿ± ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÜÿßÿµÿ± ÿßŸÑŸÖÿÆÿßŸÑŸÅÿ© Ÿàÿ•ÿÆŸÅÿßÿ§Ÿáÿß
        adElements.forEach(element => {
            // ŸÇŸÖ ÿ®ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿπŸÜÿµÿ± ÿ®ÿßŸÑŸÉÿßŸÖŸÑ ŸÖŸÜ DOM (ÿ£ŸÉÿ´ÿ± ŸÅÿπÿßŸÑŸäÿ©)
            element.remove(); 
            
            // ÿ£Ÿà ŸÇŸÖ ŸÅŸÇÿ∑ ÿ®ÿ•ÿÆŸÅÿßÿ¶Ÿá (ÿ•ÿ∞ÿß ŸÉŸÜÿ™ ÿ™ÿÆÿ¥Ÿâ ŸÖŸÜ ÿ™ÿ£ÿ´Ÿäÿ± ÿßŸÑÿ•ÿ≤ÿßŸÑÿ© ÿπŸÑŸâ ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿµŸÅÿ≠ÿ©)
            // element.style.display = 'none'; 
        });
    } else {
        // console.log("Coding Partner: ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿØÿßÿÆŸÑŸäÿ© ŸÅŸä ÿßŸÑŸÅÿ≠ÿµ ÿßŸÑÿ≠ÿßŸÑŸä.");
    }
}

// 5. ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ MutationObserver ŸÑŸÖÿ±ÿßŸÇÿ®ÿ© DOM (ÿßŸÑŸáŸäŸÉŸÑ) ŸÑÿ∂ŸÖÿßŸÜ ÿßŸÑÿπŸÖŸÑ ÿ≠ÿ™Ÿâ ÿ®ÿπÿØ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿ®ÿßŸÑŸÄ AJAX
// ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿ™Ÿèÿ≠ŸÖŸëŸÑ ÿ®ÿπÿØ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ© (ŸàŸáŸà ÿ£ŸÖÿ± ÿ¥ÿßÿ¶ÿπ)ÿå ŸÅŸáÿ∞ÿß Ÿäÿ∂ŸÖŸÜ ÿßŸÑÿ™ŸÇÿßÿ∑Ÿáÿß.
const observer = new MutationObserver(blockInPagePopups);

// ÿßÿ®ÿØÿ£ ÿßŸÑŸÖÿ±ÿßŸÇÿ®ÿ© ÿπŸÜÿØ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ©
// ÿ±ÿßŸÇÿ® ÿ¨ŸÖŸäÿπ ÿßŸÑÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ ŸÅŸä ÿßŸÑÿ¨ÿ≥ŸÖ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä (body) ŸàÿßŸÑŸÄ subtree (ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÜÿßÿµÿ± ÿßŸÑŸÅÿ±ÿπŸäÿ©)
document.addEventListener('DOMContentLoaded', () => {
    // ŸÜŸÅÿ∞ ÿßŸÑÿØÿßŸÑÿ© ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ© ÿπŸÜÿØ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ£ŸàŸÑŸä
    blockInPagePopups(); 

    // ÿßÿ®ÿØÿ£ ÿßŸÑŸÖÿ±ÿßŸÇÿ®ÿ© ÿßŸÑŸÖÿ≥ÿ™ŸÖÿ±ÿ© ŸÑŸÑÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ ÿßŸÑŸÑÿßÿ≠ŸÇÿ©
    observer.observe(document.body, { 
        childList: true, 
        subtree: true, 
        attributes: true 
    });
});

// ŸäŸÖŸÉŸÜŸÉ ÿ£Ÿäÿ∂Ÿãÿß ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿØÿßŸÑÿ© ÿ®ÿ¥ŸÉŸÑ ÿØŸàÿ±Ÿä ŸÉŸÑ 5 ÿ´ŸàÿßŸÜŸç ŸÉÿ∑ÿ®ŸÇÿ© ÿ≠ŸÖÿßŸäÿ© ÿ•ÿ∂ÿßŸÅŸäÿ©
// setInterval(blockInPagePopups, 5000);
// ÿØÿßŸÑÿ© ÿ¨ÿØŸäÿØÿ© ŸÑÿ™ÿ≠ÿØŸäÿ´ ŸàÿØÿ¨ÿ™ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸÉÿßŸÖŸÑ ŸÅŸä ÿ¥ÿßÿ¥ÿ© ÿßŸÑÿ≠ÿßÿ≥Ÿàÿ®/ÿßŸÑÿ™ŸÑŸÅÿßÿ≤
function updateFullDateWidget() {
    const dateWidgetContainer = document.getElementById('full-date-widget-container');
    if (!dateWidgetContainer) return;

    const today = new Date();
    // ŸÜÿ¨ÿπŸÑ ÿßŸÑÿ≥ŸÜÿ© 2025 ŸÑÿ™ÿ™ŸàÿßŸÅŸÇ ŸÖÿπ ÿ®ŸäÿßŸÜÿßÿ™ ÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿµŸÑÿßÿ© ŸÑÿØŸäŸÉ
    today.setFullYear(2025);
const yesterday = new Date(today);
yesterday.setDate(today.getDate() - 1);

// Format Gregorian date (optional, if you still want to show today's Gregorian)
const gregorianDate = new Intl.DateTimeFormat('ar-GB', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
}).format(today);

// Format Hijri date for *yesterday*
const hijriDateYesterday = new Intl.DateTimeFormat('ar-SA-u-ca-islamic', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
}).format(yesterday);

// Update the DOM
dateWidgetContainer.innerHTML = `
    <p id="gregorian-date">${gregorianDate}</p>
    <p id="hijri-date">${hijriDateYesterday}</p>
`;
}

// REPLACE the current displayLastWatchedVideo function with this one
async function displayLastWatchedVideo() {
    const lastWatchedContainer = document.getElementById('last-watched-container');
    const history = getWatchedHistory();
    
    // Sort by timestamp to show the most recently watched videos first
    const videoIds = Object.keys(history)
        .sort((a, b) => (history[b].lastWatchedTimestamp || 0) - (history[a].lastWatchedTimestamp || 0))
        .slice(0, 3);

    if (videoIds.length === 0) {
        lastWatchedContainer.classList.add('hidden');
        return;
    }

    try {
        const videoDetails = await fetchVideosDetails(videoIds);
        if (!videoDetails || videoDetails.length === 0) {
            lastWatchedContainer.classList.add('hidden');
            return;
        }

        // REVERSE the array so the most recent video is last in the list, ready to be scrolled to.
        videoDetails.reverse();

        const slidesHTML = videoDetails.map(video => {
            const videoData = {
                id: video.id,
                title: video.snippet.title,
                thumbnail: video.snippet.thumbnails.medium.url,
                channelTitle: video.snippet.channelTitle
            };
            const lastVideoInfo = history[videoData.id];
            const progressPercent = (lastVideoInfo && lastVideoInfo.progress > 0 && lastVideoInfo.duration > 0) 
                ? (lastVideoInfo.progress / lastVideoInfo.duration) * 100 
                : 0;

            return `
                <div class="last-watched-slide">
                    <div class="glass-surface glass-surface--svg p-3 rounded-2xl w-full">
                        <div class="flex items-center gap-4">
                            <img src="${videoData.thumbnail}" class="w-28 h-auto rounded-lg flex-shrink-0">
                            <div class="flex flex-col gap-2 flex-grow min-w-0">
                                <h3 class="font-bold text-lg leading-tight">${videoData.title}</h3>
                                <p class="text-sm text-white/70">${videoData.channelTitle}</p>
                                <div class="w-full bg-white/20 rounded-full h-1.5 mt-1">
                                    <div class="bg-red-500 h-1.5 rounded-full" style="width: ${progressPercent}%"></div>
                                </div>
                                <button class="resume-play-button self-start navigable grid-item" onclick="showVideoPopup('${videoData.id}')">
                                    <i data-lucide="play" class="w-4 h-4"></i>
                                    ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }).join('');

        const viewAllCardHTML = `
            <div class="last-watched-slide">
                <div class="glass-surface glass-surface--svg p-3 rounded-2xl w-full h-full flex flex-col items-center justify-center text-center cursor-pointer navigable grid-item" id="view-all-history-card">
                    <div class="w-16 h-16 rounded-full bg-white/10 flex items-center justify-center mb-3">
                        <i data-lucide="history" class="w-8 h-8 text-white"></i>
                    </div>
                    <h3 class="font-bold text-lg">ÿπÿ±ÿ∂ ÿßŸÑŸÉŸÑ</h3>
                    <p class="text-sm text-white/70">ŸÖÿ¥ÿßŸáÿØÿ© ŸÉŸÑ ÿßŸÑÿ≥ÿ¨ŸÑ</p>
                </div>
            </div>
        `;

        // Simplified structure for the new scroll-snap container
        lastWatchedContainer.innerHTML = `
            <h2 class="text-xl font-bold mb-3 text-white/90 text-center">ŸÖÿ™ÿßÿ®ÿπÿ© ÿßŸÑŸÖÿ¥ÿßŸáÿØÿ©</h2>
            <div class="last-watched-carousel-wrapper">
                 <div class="last-watched-slides-container">
                   
                     <div class="last-watched-slide">
                <div class="glass-surface glass-surface--svg p-3 rounded-2xl w-full h-full flex flex-col items-center justify-center text-center cursor-pointer navigable grid-item" id="istory-card">
                    <div class="w-16 h-16 rounded-full bg-white/10 flex items-center justify-center mb-3">
                       
                    </div>
                  
                </div>
            </div>
             ${slidesHTML}
             ${viewAllCardHTML}
                   
                </div>
                <button id="last-watched-prev" class="carousel-nav-button prev navigable grid-item" tabindex="0"><i data-lucide="chevron-left" class="w-8 h-8"></i></button>
                <button id="last-watched-next" class="carousel-nav-button next navigable grid-item" tabindex="0"><i data-lucide="chevron-right" class="w-8 h-8"></i></button>
            </div>
        `;

        

        lastWatchedContainer.classList.remove('hidden');
        lucide.createIcons();
        
        // NEW: Add event listener for the view all card
        const viewAllCard = document.getElementById('view-all-history-card');
        if (viewAllCard) {
            viewAllCard.addEventListener('click', showAllWatchedHistory);
        }
        
        // Scroll to the last item on load
        setTimeout(() => {
            const slidesContainer = document.querySelector('.last-watched-slides-container');
            if (slidesContainer) {
                // To show the last item (most recent) in an LTR container, scroll all the way to the right.
                slidesContainer.scrollLeft = slidesContainer.scrollWidth;
            }
        }, 0); // Use a timeout of 0 to run this after the browser has rendered the elements

        // NEW: Event listeners for carousel navigation
        const slidesContainer = lastWatchedContainer.querySelector('.last-watched-slides-container');
        const prevButton = lastWatchedContainer.querySelector('#last-watched-prev');
        const nextButton = lastWatchedContainer.querySelector('#last-watched-next');

        if (slidesContainer && prevButton && nextButton && slidesContainer.querySelector('.last-watched-slide')) {
            const scrollAmount = slidesContainer.querySelector('.last-watched-slide').offsetWidth + 16; // 16 is the gap

            prevButton.addEventListener('click', () => {
                slidesContainer.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
            });

            nextButton.addEventListener('click', () => {
                slidesContainer.scrollBy({ left: scrollAmount, behavior: 'smooth' });
            });
        }

    } catch (error) {
        console.error("Error fetching details for last watched videos:", error);
        lastWatchedContainer.classList.add('hidden');
    }
}

        // Initialize Lucide icons after they are loaded
        lucide.createIcons();

        // --- API Keys ---
        const YOUTUBE_API_KEY = 'AIzaSyBYThRM6tVnzgFgdHOUAN6DN8jQd54OKeg'; 
        const AI_ASSISTANT_API_KEY = 'AIzaSyBMmtON9ww4dJxMHrl1wKyWTvI0ipJXJws'; 
        const WEATHER_API_KEY = '7acefc26deee4904a2393917252207'; 
        const GOOGLE_MAPS_API_KEY = 'AIzaSyBRqAHJ2elbE_Z7NXXYC50XZpqi6HbG6Rk';

const JSONBIN_API_KEY = '$2a$10$SYrYv.ct8hiMU9YeUxEQ.ecRkOrTqs.TDchJRV3wW.aKJnDXy2oVy';
const JSONBIN_BIN_ID_REMINDERS = '68e3800cae596e708f07cf32';
const JSONBIN_ACCESS_KEY_REMINDERS = '$2a$10$J8o3WrPtnqmKAd///uDw6.BOWnGIBekHFOImbeEZZwsJ/h/XPbVUy';

// NEW: JSONBin IDs for Favorites
const JSONBIN_BIN_ID_FAV_M = '68e4ac20d0ea881f4098138c';
const JSONBIN_BIN_ID_FAV_D = '68e4ac2e43b1c97be95d24af';

// NEW: JSONBin IDs for Channels List
const JSONBIN_BIN_ID_CHANNELS = '68ef1b3dd0ea881f40a38bd1';
const JSONBIN_ACCESS_KEY_CHANNELS = '$2a$10$J8o3WrPtnqmKAd///uDw6.BOWnGIBekHFOImbeEZZwsJ/h/XPbVUy';
let localChannelsCache = []; // To store the list locally

let favoritesD = [];
let favoritesM = [];

        
        // --- Global App State Management ---
        let appState = {
            currentTime: '',
            mapLocation: { lat: 17.081667, lon: 54.159722, zoom: 19 },
            weather: { temperature: null, description: null, uvIndex: null, iconUrl: '', location: 'Salalah, Oman' },
            car: { speed: 0, rpm: 0, fuel: 0, temp: 0, gear: 'P', direction: '--' }, // Added direction
            prayerTimes: { Fajr: '--:--', Dhuhr: '--:--', Asr: '--:--', Maghrib: '--:--', Isha: '--:--', nextPrayer: null, nextPrayerIqamaTime: null, currentPrayer: null },
            hasShownGeolocationError: false,
            mapZoomChangedByUser: false,
            dashboardReturnCounter: 0,
            custom360Image: localStorage.getItem('custom360Image') || null,
            currentLocation: null,
            previousLocation: null, // For tracking movement
            destinationSet: false,
            isVideoPlayerMinimized: false // NEW state for minimized player
        };
        let googleMapsPromise = null;
        let currentFontSize = 16; // Base size in pixels
        const fontSizeStep = 1; // Change by 1px
        const maxFontSize = 20; // Max size (125%)
        const minFontSize = 12; // Min size (75%)

        // --- Home Locations ---
        // UPDATED: Coordinates for Home 1 and Home 2
        const HOME1_COORDS = { lat: 17.0, lng: 54.159722 }; // 17¬∞04'54.0"N 54¬∞09'35.0"E
        const HOME2_COORDS = { lat: 17.048560, lng: 54.159616 };

        // --- DOM Element References ---
        const appButtons = document.querySelectorAll('button[data-app]');
        const appScreens = document.querySelectorAll('.app-screen');
        const sidebarIcons = document.querySelectorAll('.app-icon');
        const quranQuickAccess = document.getElementById('quran-quick-access');
        const youtubeSearchInput = document.getElementById('youtube-search-input');
        const youtubeSearchButton = document.getElementById('youtube-search-button');
        const youtubeSuggestionsDiv = document.getElementById('youtube-suggestions');
        const youtubeVideoListView = document.getElementById('youtube-video-list-view'); 
        const videoListContainer = document.getElementById('video-list-container'); 
        const youtubeSearchResultsView = document.getElementById('youtube-search-results-view');
        const searchResultsContainer = document.getElementById('search-results-container');
        const backToPlaylistsFromVideosButton = document.getElementById('back-to-playlists-from-videos'); 
        const backToPlaylistsBottomButton = document.getElementById('back-to-playlists-bottom-button');
        const backToPlaylistsBottomButtonSearch = document.getElementById('back-to-playlists-bottom-button-search');
        const previousItemButton = document.getElementById('previous-item-button');
        const nextItemButton = document.getElementById('next-item-button');
        const videoPopupContainer = document.getElementById('video-popup-container');
        const videoPopupPlayerContainer = document.getElementById('video-popup-player-container');
        const videoPopupCloseButton = document.getElementById('video-popup-close-button');
        const quranIframe = document.getElementById('quran-iframe');
        const floatingMediaButton = document.getElementById('floating-media-button');
        const floatingKeyboardButton = document.getElementById('floating-keyboard-button');
        const floatingMinimizedVideoButton = document.getElementById('floating-minimized-video-button');
        const backToSearchFloatingButton = document.getElementById('back-to-search-floating-button'); // NEW
        const clearSearchButton = document.getElementById('clear-search-button');
        const startTripFloatingButton = document.getElementById('start-trip-floating-button');
        const prayerTimesContainer = document.getElementById('prayer-times-container');
        const digitalHoursSpan = document.querySelector('#digital-time .hours');
        const digitalMinutesSpan = document.querySelector('#digital-time .minutes');
        const digitalSecondsSpan = document.querySelector('#digital-time .seconds');
        const digitalDateLine1 = document.getElementById('digital-date-line1');
        const digitalDateLine2 = document.getElementById('digital-date-line2');
        let dashboardGoogleMap, dashboardGoogleMarker, directionsService, directionsRenderer;
        let watchId;
        const getMyLocationButtonDashboard = document.getElementById('get-my-location-button-dashboard');
        const goToHome1Button = document.getElementById('go-to-home-1-button');
        const goToHome2Button = document.getElementById('go-to-home-2-button');
        const car360Image = document.getElementById('car-360-image');
        const upload360ImageInput = document.getElementById('upload-360-image-input');
        const upload360ImageButton = document.getElementById('upload-360-image-button');
        const reset360ImageButton = document.getElementById('reset-360-image-button');
        const carplayMainInterface = document.getElementById('carplay-main-interface');
        const pauseAnimationButton = document.getElementById('pause-animation-button');
        const zoomInButton = document.getElementById('zoom-in-button');
        const zoomOutButton = document.getElementById('zoom-out-button');
        const removeCacheButton = document.getElementById('remove-cache-button');
        const default360ImageSrc = "https://dmusera.netlify.app/es350gb.png";
        let currentPlayingPlaylistId = '', activeMediaView = 'suggestions', currentPlayingVideoId = '', selectedReaderName = '', popupPlayer, isYouTubeApiReady = false, searchMode = 'reciter_surah', progressInterval = null;
        let lastSuccessfulSearchQuery = null; // NEW: To store the last search query
        let initialLocationFetched = false;

        const juzArabicNames = ["ÿßŸÑÿ£ŸàŸÑ", "ÿßŸÑÿ´ÿßŸÜŸä", "ÿßŸÑÿ´ÿßŸÑÿ´", "ÿßŸÑÿ±ÿßÿ®ÿπ", "ÿßŸÑÿÆÿßŸÖÿ≥", "ÿßŸÑÿ≥ÿßÿØÿ≥", "ÿßŸÑÿ≥ÿßÿ®ÿπ", "ÿßŸÑÿ´ÿßŸÖŸÜ", "ÿßŸÑÿ™ÿßÿ≥ÿπ", "ÿßŸÑÿπÿßÿ¥ÿ±", "ÿßŸÑÿ≠ÿßÿØŸä ÿπÿ¥ÿ±", "ÿßŸÑÿ´ÿßŸÜŸä ÿπÿ¥ÿ±", "ÿßŸÑÿ´ÿßŸÑÿ´ ÿπÿ¥ÿ±", "ÿßŸÑÿ±ÿßÿ®ÿπ ÿπÿ¥ÿ±", "ÿßŸÑÿÆÿßŸÖÿ≥ ÿπÿ¥ÿ±", "ÿßŸÑÿ≥ÿßÿØÿ≥ ÿπÿ¥ÿ±", "ÿßŸÑÿ≥ÿßÿ®ÿπ ÿπÿ¥ÿ±", "ÿßŸÑÿ´ÿßŸÖŸÜ ÿπÿ¥ÿ±", "ÿßŸÑÿ™ÿßÿ≥ÿπ ÿπÿ¥ÿ±", "ÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"];

        // --- Utility Functions ---
        function showMessageBox(message) { const box = document.createElement('div'); box.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); z-index: 1000; text-align: center; max-width: 80%; font-size: 1.1rem;`; box.innerHTML = `<p>${message}</p><button style="margin-top: 15px; padding: 8px 15px; background-color: #9333ea; border: none; border-radius: 5px; color: white; cursor: pointer;">ÿ•ÿ∫ŸÑÿßŸÇ</button>`; document.body.appendChild(box); box.querySelector('button').addEventListener('click', () => document.body.removeChild(box)); }

        async function showAllWatchedHistory() {
            const history = getWatchedHistory();
            const videoIds = Object.keys(history)
                .sort((a, b) => (history[b].lastWatchedTimestamp || 0) - (history[a].lastWatchedTimestamp || 0));

            if (videoIds.length === 0) {
                showMessageBox('ŸÑÿß ŸäŸàÿ¨ÿØ ÿ≥ÿ¨ŸÑ ŸÖÿ¥ÿßŸáÿØÿ©.');
                return;
            }

            try {
                // Fetch details in chunks to avoid long URLs
                const allVideoDetails = [];
                for (let i = 0; i < videoIds.length; i += 50) {
                    const chunk = videoIds.slice(i, i + 50);
                    const details = await fetchVideosDetails(chunk);
                    if(details) {
                        allVideoDetails.push(...details);
                    }
                }
                
                if (allVideoDetails.length > 0) {
                    searchResultsContainer.innerHTML = '<h2 class="text-3xl font-bold mb-4 text-center w-full text-white col-span-full">ÿ≥ÿ¨ŸÑ ÿßŸÑŸÖÿ¥ÿßŸáÿØÿ©</h2>'; // Add a title
                    
                    // NEW: Fetch channel thumbnails for all videos
                    const channelIds = [...new Set(allVideoDetails.map(video => video.snippet.channelId))];
                    const channelThumbnails = await fetchChannelsDetails(channelIds);

                    // Sort details according to original sorted videoIds
                const sortedDetails = allVideoDetails.sort((a, b) => {
                    const aTimestamp = history[a.id]?.lastWatchedTimestamp || 0;
                    const bTimestamp = history[b.id]?.lastWatchedTimestamp || 0;
                    return bTimestamp - aTimestamp;
                });
                
                sortedDetails.forEach(video => {
                    const videoData = {
                        id: video.id,
                        title: video.snippet.title,
                        thumbnail: video.snippet.thumbnails.medium.url,
                        channelTitle: video.snippet.channelTitle,
                        channelId: video.snippet.channelId,
                        channelThumbnail: channelThumbnails[video.snippet.channelId], // Add thumbnail
                        viewCount: formatViewCount(video.statistics.viewCount),
                        publishedAt: formatTimeAgo(video.snippet.publishedAt),
                        duration: formatDuration(video.contentDetails.duration)
                    };
                    searchResultsContainer.appendChild(createVideoCard(videoData));
                });

                youtubeSuggestionsDiv.style.display = 'none';
                youtubeVideoListView.classList.add('hidden');
                    youtubeSearchResultsView.classList.remove('hidden');
                    activeMediaView = 'searchResults'; // Reuse this view
                    backToPlaylistsBottomButton.style.display = 'none';
                    backToPlaylistsBottomButtonSearch.style.display = 'flex';
                    previousItemButton.style.display = 'none'; // No next/prev for history
                    nextItemButton.style.display = 'none';

                    lucide.createIcons();
                    updateNavigableElements();
                    setTimeout(() => {
                        const firstResult = searchResultsContainer.querySelector('.grid-item');
                        if (firstResult) setFocus(firstResult);
                    }, 100);
                } else {
                     showMessageBox('ŸÑÿß ŸäŸàÿ¨ÿØ ÿ≥ÿ¨ŸÑ ŸÖÿ¥ÿßŸáÿØÿ©.');
                }

            } catch (error) {
                console.error("Error fetching all history details:", error);
                showMessageBox('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ŸÖŸäŸÑ ÿ≥ÿ¨ŸÑ ÿßŸÑŸÖÿ¥ÿßŸáÿØÿ©.');
            }
        }
        
        // --- NEW: Watched History Helpers ---
        function getWatchedHistory() {
            return JSON.parse(localStorage.getItem('youtubeWatchedHistory')) || {};
        }

        async function updateVideoProgress(videoId, currentTime, duration) {
            if (!videoId || !duration || !isFinite(currentTime) || !isFinite(duration)) return;
        
            // 1. Update local history (localStorage)
            const history = getWatchedHistory();
            history[videoId] = { progress: currentTime, duration: duration, lastWatchedTimestamp: Date.now() };
            localStorage.setItem('youtubeWatchedHistory', JSON.stringify(history));
        
            // 2. Check and update favorites in JSONBin.io
            const favDIndex = favoritesD.findIndex(fav => fav.id === videoId);
            const favMIndex = favoritesM.findIndex(fav => fav.id === videoId);
        
            // If the video is not in any favorites list, we don't need to proceed further.
            if (favDIndex === -1 && favMIndex === -1) {
                return;
            }
        
            const updatePromises = [];
        
            if (favDIndex > -1) {
                // To ensure state changes are handled correctly, create a new array using .map
                const updatedFavoritesD = favoritesD.map((fav, index) => {
                    if (index === favDIndex) {
                        // Return a new object with the updated progress
                        return { ...fav, progress: currentTime };
                    }
                    return fav; // Return the original object if it's not the one we're updating
                });
                favoritesD = updatedFavoritesD; // Re-assign the global variable to the newly created array
                updatePromises.push(updateFavorites('D', favoritesD));
            }
        
            if (favMIndex > -1) {
                // Repeat the same immutable update pattern for the 'M' list
                const updatedFavoritesM = favoritesM.map((fav, index) => {
                    if (index === favMIndex) {
                        return { ...fav, progress: currentTime };
                    }
                    return fav;
                });
                favoritesM = updatedFavoritesM; // Re-assign the global variable
                updatePromises.push(updateFavorites('M', favoritesM));
            }
            
            if (updatePromises.length > 0) {
                try {
                    await Promise.all(updatePromises);
                } catch (error) {
                    console.error(`Failed to update favorite progress for video ${videoId}:`, error);
                }
            }
        }

        function markVideoAsWatched(videoId) {
            if (!videoId) return;
            const history = getWatchedHistory();
            // Using a special value to indicate fully watched
            history[videoId] = { progress: -1, duration: 1, lastWatchedTimestamp: Date.now() };
            localStorage.setItem('youtubeWatchedHistory', JSON.stringify(history));
            // Also update the card in the UI if it's visible
            const card = document.querySelector(`.youtube-video-card[data-video-id="${videoId}"]`);
            if(card) {
                // Remove progress bar if it exists
                const progressBar = card.querySelector('.watched-progress-bar-container');
                if(progressBar) progressBar.remove();
                // Add watched badge if it doesn't exist
                if(!card.querySelector('.watched-badge')) {
                    const badge = document.createElement('div');
                    badge.className = 'watched-badge';
                    badge.textContent = 'ÿ™ŸÖÿ™ ÿßŸÑŸÖÿ¥ÿßŸáÿØÿ©';
                    card.querySelector('.thumbnail-container').appendChild(badge);
                }
            }
        }
        
        function updateUI() {
    // --- Dashboard Weather Widget Updates ---
    const tempEl = document.getElementById('dashboard-weather-temp');
    const descEl = document.getElementById('dashboard-weather-desc');
    const iconEl = document.getElementById('dashboard-weather-icon');
    const locationEl = document.getElementById('dashboard-weather-location');
    
    // NEW METRICS REFERENCES
    const dashMetricTemp = document.getElementById('dash-metric-temp');
    const dashMetricUV = document.getElementById('dash-metric-uv');
    const dashMetricHumidity = document.getElementById('dash-metric-humidity');
    
    const tempValue = appState.weather.temperature;
    const uvValue = appState.weather.uvIndex;
    const humidityValue = appState.weather.humidity;


    // Update main display
    if (tempEl) {
        tempEl.textContent = tempValue !== null ? `${tempValue.toFixed(1)}¬∞C` : '--¬∞C';
    }
    if (descEl) {
        descEl.textContent = appState.weather.description || '--';
    }
    if (iconEl) {
        iconEl.src = appState.weather.iconUrl || 'https://placehold.co/64x64/000000/FFFFFF?text=X';
    }
    if (locationEl) {
        locationEl.textContent = appState.weather.location;
    }

    // --- NEW: Update Main Dashboard Metrics Grid ---
    if (dashMetricTemp && tempValue !== null) {
        dashMetricTemp.textContent = `${Math.round(tempValue)}¬∞C`;
        // Apply color class using a helper function (assumed defined elsewhere)
        dashMetricTemp.className = `font-bold text-lg ${getTempTextColor(tempValue)}`;
    } else if (dashMetricTemp) { dashMetricTemp.textContent = '--¬∞C'; dashMetricTemp.className = 'font-bold text-lg text-white/70'; }

    if (dashMetricUV && uvValue !== null) {
        dashMetricUV.textContent = `${uvValue}`;
        dashMetricUV.className = `font-bold text-lg ${getUvTextColor(uvValue)}`;
    } else if (dashMetricUV) { dashMetricUV.textContent = '--'; dashMetricUV.className = 'font-bold text-lg text-white/70'; }

    if (dashMetricHumidity && humidityValue !== null) {
        dashMetricHumidity.textContent = `${Math.round(humidityValue)}%`;
        dashMetricHumidity.className = `font-bold text-lg ${getHumidityTextColor(humidityValue)}`;
    } else if (dashMetricHumidity) { dashMetricHumidity.textContent = '--%'; dashMetricHumidity.className = 'font-bold text-lg text-white/70'; }
    // --- END NEW METRICS GRID UPDATE ---


    // --- 3D Screen Weather Temp Update ---
    const temp3dEl = document.getElementById('3d-screen-weather-temp');
    if (temp3dEl) {
        temp3dEl.textContent = tempValue !== null ? `${tempValue.toFixed(1)}¬∞C` : '--¬∞C';
    }

    // --- Weather Screen UV Update (If element exists) ---
    const uvWeatherScreenEl = document.getElementById('weather-uv');
    if (uvWeatherScreenEl) {
        uvWeatherScreenEl.textContent = uvValue !== null ? uvValue : '--';
        uvWeatherScreenEl.style.color = getUvIndexColor(uvValue);
    }

    // --- 360 Image Update ---
    if (car360Image) { 
        car360Image.src = appState.custom360Image || default360ImageSrc;
    }

    // --- Start Trip Button Visibility ---
    const startTripFloatingButton = document.getElementById('start-trip-floating-button');
    if (startTripFloatingButton) { 
        startTripFloatingButton.style.display = appState.destinationSet ? 'flex' : 'none';
    }
}

// Make sure appState includes humidity (it should already if fetchWeatherData is correct)
// Inside fetchWeatherData, ensure humidity is stored:
// appState.weather.humidity = data.current.humidity; // Add this line if missing

        // --- App Switching and Navigation Logic ---
        const appOrder = ['Dashboard', 'Media', 'Radio', 'Athkar', 'Reciters', 'Weather', 'Map', 'Quran'];
        let currentAppIndex = 0;

        function switchApp(appName) {
            const newIndex = appOrder.indexOf(appName);
            if (newIndex === -1) return;
            currentAppIndex = newIndex;

            appScreens.forEach(s => s.classList.remove('active'));
            sidebarIcons.forEach(i => i.classList.remove('active'));
            const screen = document.getElementById(`screen-${appName}`);
            if (screen) screen.classList.add('active');
            const icon = document.querySelector(`.app-icon[data-app="${appName}"]`);
            if (icon) icon.classList.add('active');

            if (appName === 'Dashboard' && appState.mapZoomChangedByUser) {
                appState.dashboardReturnCounter++;
                if (appState.dashboardReturnCounter >= 2 && dashboardGoogleMap) {
                    dashboardGoogleMap.setZoom(appState.mapLocation.zoom);
                    appState.mapZoomChangedByUser = false;
                    appState.dashboardReturnCounter = 0;
                    showMessageBox('ÿ™ŸÖ ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿ™ŸÉÿ®Ÿäÿ± ÿßŸÑÿÆÿ±Ÿäÿ∑ÿ© ÿ•ŸÑŸâ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä.');
                }
            } else if (appName !== 'Dashboard' && !appState.mapZoomChangedByUser) {
                appState.dashboardReturnCounter = 0;
            }
            handleMediaViewSwitch(appName);
            quranQuickAccess.style.display = (appName === 'Quran') ? 'flex' : 'none';
            startTripFloatingButton.style.display = (appName === 'Map' && appState.destinationSet) ? 'flex' : 'none';
            if (document.activeElement && document.activeElement.closest('nav')) {
                setTimeout(() => {
                    const firstItem = screen.querySelector('.grid-item');
                    if (firstItem) setFocus(firstItem);
                }, 100);
            }
        }

        function navigateToNextApp() {
            currentAppIndex = (currentAppIndex + 1) % appOrder.length;
            switchApp(appOrder[currentAppIndex]);
        }

        function navigateToPrevApp() {
            currentAppIndex = (currentAppIndex - 1 + appOrder.length) % appOrder.length;
            switchApp(appOrder[currentAppIndex]);
        }

        function handleMediaViewSwitch(appName) {
            floatingMediaButton.style.display = (appName === 'Media') ? 'none' : 'flex';
            floatingKeyboardButton.style.display = (appName === 'Media') ? 'flex' : 'none';
            clearSearchButton.style.display = (appName === 'Media') ? 'flex' : 'none';
            
            if (appName === 'Media') {
                floatingKeyboardButton.classList.toggle('active-keyboard', !youtubeSearchInput.readOnly);
                floatingKeyboardButton.classList.toggle('inactive-keyboard', youtubeSearchInput.readOnly);
                
                // Logic to show the correct view
                youtubeVideoListView.classList.add('hidden');
                youtubeSearchResultsView.classList.add('hidden');
                youtubeSuggestionsDiv.style.display = 'flex'; // Make suggestions visible

                if (activeMediaView === 'videoList' && currentPlayingPlaylistId) {
                    youtubeVideoListView.classList.remove('hidden');
                } else if (activeMediaView === 'searchResults') {
                    youtubeSearchResultsView.classList.remove('hidden');
                } else {
                    // Default to suggestions view
                    resetYoutubeSearchUI();
                }
            } else {
                 youtubeSuggestionsDiv.style.display = 'none';
            }
        }
        appButtons.forEach(b => b.addEventListener('click', () => switchApp(b.dataset.app)));
        sidebarIcons.forEach(el => el.classList.add('w-16', 'h-16', 'rounded-2xl', 'flex', 'items-center', 'justify-center', 'transition-all', 'duration-300', 'ease-in-out'));
        
        // --- YouTube/Media Functions (REFACTORED) ---
        function onYouTubeIframeAPIReady() { isYouTubeApiReady = true; }
        
        function createVideoCard(video) {
            const card = document.createElement('div');
            card.className = 'glass-surface glass-surface--svg youtube-video-card navigable grid-item';
            card.tabIndex = 0;
            card.dataset.videoId = video.id;

            // Get watched history for this video
            const history = getWatchedHistory();
            const watchedInfo = history[video.id];
            let progressHTML = '';

            if (watchedInfo) {
                if (watchedInfo.progress === -1) { // Fully watched
                    progressHTML = `<div class="watched-badge">ÿ™ŸÖÿ™ ÿßŸÑŸÖÿ¥ÿßŸáÿØÿ©</div>`;
                } else if (watchedInfo.progress > 0 && watchedInfo.duration > 0) {
                    const progressPercent = (watchedInfo.progress / watchedInfo.duration) * 100;
                    progressHTML = `<div class="watched-progress-bar-container"><div class="watched-progress-bar" style="width: ${progressPercent}%"></div></div>`;
                }
            }
            
            const isSavedD = favoritesD.some(fav => fav.id === video.id);
            const isSavedM = favoritesM.some(fav => fav.id === video.id);
            let bookmarkClass = '';
            if (isSavedD && isSavedM) bookmarkClass = 'saved-both';
            else if (isSavedD) bookmarkClass = 'saved-d';
            else if (isSavedM) bookmarkClass = 'saved-m';

            const isLive = video.duration === 'ŸÖÿ®ÿßÿ¥ÿ±';

            card.innerHTML = `
                <div class="video-details">
                    <h3 class="video-title">${video.title}</h3>
                    <div class="video-meta">
                        <div class="flex items-center justify-between w-full gap-2">
                            <div class="flex items-center gap-2 cursor-pointer channel-link min-w-0" data-channel-id="${video.channelId}" data-channel-title="${video.channelTitle}">
                               <img src="${video.channelThumbnail || 'https://placehold.co/24x24/334155/ffffff?text=?'}" alt="${video.channelTitle}" class="w-6 h-6 rounded-full object-cover flex-shrink-0">
                               <span class="hover:underline truncate">${video.channelTitle}</span>
                            </div>
                            <button class="add-channel-from-search-btn p-1 rounded-full hover:bg-white/20 transition-colors flex-shrink-0 navigable grid-item" data-channel-id="${video.channelId}" data-channel-title="${video.channelTitle}" data-channel-thumbnail="${video.channelThumbnail || ''}" title="ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÇŸÜÿßÿ© ŸÑŸÑŸÇÿßÿ¶ŸÖÿ©" tabindex="0">
                                <i data-lucide="plus-circle" class="w-5 h-5 text-green-400"></i>
                            </button>
                        </div>
                        <span class="text-xs text-white/60">${video.viewCount} ŸÖÿ¥ÿßŸáÿØÿ© ‚Ä¢ ${video.publishedAt}</span>
                    </div>
                </div>
                <div class="thumbnail-container relative">
                    <img src="${video.thumbnail}" alt="${video.title}" class="w-[180px] h-[101.25px] object-cover rounded-md ml-4 flex-shrink-0" onerror="this.onerror=null;this.src='https://placehold.co/180x101';">
                    <span class="video-duration ${isLive ? 'bg-red-600 font-bold' : ''}">${video.duration}</span>
                    ${progressHTML}
                    <button class="bookmark-button ${bookmarkClass}" data-video-id="${video.id}"><i data-lucide="bookmark" class="w-5 h-5"></i></button>
                </div>
            `;
            card.addEventListener('click', () => showVideoPopup(video.id));
             card.querySelector('.bookmark-button').addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent card click event from firing
                showFavoritesMenu(e.currentTarget, video);
            });

            const channelLink = card.querySelector('.channel-link');
            if (channelLink) {
                channelLink.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const channelId = e.currentTarget.dataset.channelId;
                    const channelTitle = e.currentTarget.dataset.channelTitle;
                    if(channelId && channelTitle) {
                        searchVideosByChannel(channelId, channelTitle);
                    }
                });
            }

            // NEW: Event listener for the add channel button
            const addChannelBtn = card.querySelector('.add-channel-from-search-btn');
            if (addChannelBtn) {
                // Check if channel is already in the list and disable button
                if (localChannelsCache.some(c => c.channelid === video.channelId)) {
                    addChannelBtn.disabled = true;
                    addChannelBtn.innerHTML = `<i data-lucide="check-circle" class="w-5 h-5 text-green-400"></i>`;
                } else {
                    addChannelBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent card click
                        const btn = e.currentTarget;
                        const channelId = btn.dataset.channelId;
                        const channelTitle = btn.dataset.channelTitle;
                        const channelThumbnail = btn.dataset.channelThumbnail;
                        addChannelFromSearchResult(channelId, channelTitle, channelThumbnail, btn);
                    });
                }
            }

            lucide.createIcons();
            return card;
        }

        async function fetchVideosDetails(videoIds) {
            if (!videoIds || videoIds.length === 0) return [];
            try {
                const response = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails,statistics&id=${videoIds.join(',')}&key=${YOUTUBE_API_KEY}`);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error("YouTube API error (videos):", errorData?.error?.message || response.status);
                    return null; // Indicate failure
                }
                const data = await response.json();
                return data.items;
            } catch (error) {
                console.error("Network error in fetchVideosDetails:", error);
                return null; // Indicate failure
            }
        }

        async function fetchChannelsDetails(channelIds) {
            if (!channelIds || channelIds.length === 0) return {};
            const uniqueIds = [...new Set(channelIds)];
            try {
                const response = await fetch(`https://www.googleapis.com/youtube/v3/channels?part=snippet&id=${uniqueIds.join(',')}&key=${YOUTUBE_API_KEY}`);
                if (!response.ok) {
                    console.error("YouTube API error (channels):", response.status);
                    return {};
                }
                const data = await response.json();
                const channelMap = {};
                if (data.items) {
                    data.items.forEach(channel => {
                        channelMap[channel.id] = channel.snippet.thumbnails.default.url;
                    });
                }
                return channelMap;
            } catch (error) {
                console.error("Network error in fetchChannelsDetails:", error);
                return {};
            }
        }

        function formatDuration(isoDuration) {
            const regex = /PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/;
            const matches = isoDuration.match(regex);
            const hours = matches[1] ? parseInt(matches[1]) : 0;
            const minutes = matches[2] ? parseInt(matches[2]) : 0;
            const seconds = matches[3] ? parseInt(matches[3]) : 0;
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function formatViewCount(views) {
            if (views >= 1000000) return `${(views / 1000000).toFixed(1)} ŸÖŸÑŸäŸàŸÜ`;
            if (views >= 1000) return `${(views / 1000).toFixed(0)} ÿ£ŸÑŸÅ`;
            return views;
        }

        function formatTimeAgo(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const seconds = Math.floor((now - date) / 1000);
            let interval = seconds / 31536000;
            if (interval > 1) return `ŸÇÿ®ŸÑ ${Math.floor(interval)} ÿ≥ŸÜŸàÿßÿ™`;
            interval = seconds / 2592000;
            if (interval > 1) return `ŸÇÿ®ŸÑ ${Math.floor(interval)} ÿ£ÿ¥Ÿáÿ±`;
            interval = seconds / 86400;
            if (interval > 1) return `ŸÇÿ®ŸÑ ${Math.floor(interval)} ÿ£ŸäÿßŸÖ`;
            interval = seconds / 3600;
            if (interval > 1) return `ŸÇÿ®ŸÑ ${Math.floor(interval)} ÿ≥ÿßÿπÿßÿ™`;
            interval = seconds / 60;
            if (interval > 1) return `ŸÇÿ®ŸÑ ${Math.floor(interval)} ÿØŸÇÿßÿ¶ŸÇ`;
            return `ŸÇÿ®ŸÑ ${Math.floor(seconds)} ÿ´ŸàÿßŸÜ`;
        }
        
        // --- START: NEW Channel List Functions (JSONBin.io) ---
        async function fetchChannelsList() {
            try {
                const res = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID_CHANNELS}/latest`, {
                    headers: { 'X-Access-Key': JSONBIN_ACCESS_KEY_CHANNELS }
                });
                if (res.status === 404) return []; // Bin is new/empty
                if (!res.ok) throw new Error(`HTTP error ${res.status}`);
                const data = await res.json();
                localChannelsCache = Array.isArray(data.record) ? data.record : [];
                return localChannelsCache;
            } catch (error) {
                console.error(`Error fetching channels list:`, error);
                return []; // Return empty on error
            }
        }

        async function updateChannelsList(newChannelsList) {
            try {
                const res = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID_CHANNELS}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': JSONBIN_API_KEY
                    },
                    body: JSON.stringify(newChannelsList)
                });
                if (!res.ok) throw new Error(`Failed to update channels list: ${res.status}`);
                localChannelsCache = newChannelsList; // Update local cache
                return true;
            } catch (error) {
                console.error(`Error updating channels list:`, error);
                showMessageBox(`ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ÿØŸäÿ´ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™`);
                return false;
            }
        }

        // --- ADD THIS NEW FUNCTION ---
¬† ¬† function incrementChannelClick(channelId) {
¬† ¬† ¬† ¬† ¬† ¬† if (!channelId || !localChannelsCache) return;
¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† let channelFound = false;
¬† ¬† ¬† ¬† ¬† ¬† const updatedList = localChannelsCache.map(channel => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (channel && channel.channelid === channelId) { // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ 'channel' ŸÖŸàÿ¨ŸàÿØ
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† channelFound = true;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const currentClicks = parseInt(channel.clickschannel, 10) || 0; // ÿ™ÿ≠ŸàŸäŸÑ ÿ¢ŸÖŸÜ ÿ•ŸÑŸâ ÿ±ŸÇŸÖ
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return { ...channel, clickschannel: currentClicks + 1 };
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return channel;
¬† ¬† ¬† ¬† ¬† ¬† });

¬† ¬† ¬† ¬† ¬† ¬† if (channelFound) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† localChannelsCache = updatedList; // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑŸÖÿ§ŸÇÿ™ÿ© ŸÅŸàÿ±Ÿãÿß
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ ÿ•ŸÑŸâ ÿßŸÑÿÆÿßÿØŸÖ ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ©
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† updateChannelsList(updatedList).catch(err => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.error("Failed to update channel clicks in background:", err);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† // --- 2. ÿ£ÿ∂ŸÅ Ÿáÿ∞Ÿá ÿßŸÑÿØÿßŸÑÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ© ---
¬† ¬† ¬† ¬† // (Ÿáÿ∞Ÿá ÿßŸÑÿØÿßŸÑÿ© ÿ™ÿµŸÑÿ≠ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿßŸÑŸÇÿØŸäŸÖÿ© ŸÅŸä JSONBin ÿ®ÿ•ÿ∂ÿßŸÅÿ© clickschannel: 0)
¬† ¬† ¬† ¬† async function migrateChannelData() {
¬† ¬† ¬† ¬† ¬† ¬† if (localStorage.getItem('channelMigrationDone')) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return; // ÿ™ŸÖ ÿßŸÑÿ™ŸÜŸÅŸäÿ∞ ŸÖŸÜ ŸÇÿ®ŸÑ
¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† console.log("Running channel data migration (one time only)...");
¬† ¬† ¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† let currentList = await fetchChannelsList(); // ÿ¨ŸÑÿ® ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† let needsUpdate = false;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const updatedList = currentList.map(channel => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (channel && typeof channel === 'object' && channel.channelid) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑÿÆÿßÿµŸäÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (typeof channel.clickschannel === 'undefined') {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† needsUpdate = true;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return { ...channel, clickschannel: 0 }; // ÿ£ÿ∂ŸÅŸáÿß ÿ®ŸÇŸäŸÖÿ© 0
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return channel;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† });

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (needsUpdate) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("Updating channels in JSONBin with default clickschannel: 0...");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† await updateChannelsList(updatedList);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† localChannelsCache = updatedList; // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑŸÖÿ§ŸÇÿ™ÿ©
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("Migration complete.");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("No channel data migration needed.");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† localStorage.setItem('channelMigrationDone', 'true'); // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸÜŸá ÿ™ŸÖ
¬† ¬† ¬† ¬† ¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.error("Error during channel data migration:", error);
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }

        function showAddChannelPrompt() {
            const existingPrompt = document.getElementById('add-channel-prompt');
            if (existingPrompt) existingPrompt.remove();

            const promptHTML = `
                <div id="add-channel-prompt" class="fixed inset-0 bg-black/70 flex items-center justify-center z-[9999]">
                    <div id="add-channel-prompt-content" class="glass-surface glass-surface--svg p-6 rounded-2xl w-full max-w-lg flex flex-col gap-4 transition-all duration-300">
                        <h3 class="text-xl font-bold text-center">ÿ•ÿ∂ÿßŸÅÿ© ŸÇŸÜÿßÿ© ŸäŸàÿ™ŸäŸàÿ® ÿ¨ÿØŸäÿØÿ©</h3>
                        <p class="text-sm text-white/70 text-center">ÿßÿ®ÿ≠ÿ´ ÿ®ÿßÿ≥ŸÖ ÿßŸÑŸÇŸÜÿßÿ© ŸÑÿ•ÿ∂ÿßŸÅÿ™Ÿáÿß ÿ•ŸÑŸâ ŸÇÿßÿ¶ŸÖÿ™ŸÉ.</p>
                        <div class="flex gap-2">
                            <input type="text" id="new-channel-search-input" placeholder="ÿßÿ≥ŸÖ ÿßŸÑŸÇŸÜÿßÿ©..." class="flex-grow p-3 rounded-full bg-white/10 text-white placeholder-white/50 focus:outline-none focus:ring-2 focus:ring-purple-500 navigable grid-item" tabindex="0" />
                            <button id="search-channel-confirm" class="bg-purple-600 hover:bg-purple-700 text-white font-bold p-3 rounded-full navigable grid-item" tabindex="0">
                                <i data-lucide="search" class="w-5 h-5"></i>
                            </button>
                        </div>
                        <div id="channel-search-results" class="mt-4 max-h-[50vh] overflow-y-auto flex flex-col gap-3">
                            <!-- Search results will appear here -->
                        </div>
                         <button id="add-channel-cancel" class="mt-2 bg-red-600/80 hover:bg-red-700/80 text-white font-bold py-2 px-4 rounded-full navigable grid-item self-center" tabindex="0">ÿ•ÿ∫ŸÑÿßŸÇ</button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', promptHTML);
            lucide.createIcons();

            const promptEl = document.getElementById('add-channel-prompt');
            const inputEl = document.getElementById('new-channel-search-input');
            const confirmBtn = document.getElementById('search-channel-confirm');
            const cancelBtn = document.getElementById('add-channel-cancel');

            const closePrompt = () => promptEl.remove();

            confirmBtn.addEventListener('click', handleSearchForChannel);
            cancelBtn.addEventListener('click', closePrompt);
            inputEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleSearchForChannel();
                }
            });
            
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closePrompt();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);

            inputEl.focus();
            setFocus(inputEl);
        }

        async function handleSearchForChannel() {
            const inputEl = document.getElementById('new-channel-search-input');
            const resultsContainer = document.getElementById('channel-search-results');
            const confirmBtn = document.getElementById('search-channel-confirm');
            const query = inputEl.value.trim();

            if (!query) {
                showMessageBox("ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿßÿ≥ŸÖ ŸÇŸÜÿßÿ© ŸÑŸÑÿ®ÿ≠ÿ´.");
                return;
            }

            confirmBtn.disabled = true;
            confirmBtn.innerHTML = `<i data-lucide="loader-2" class="w-5 h-5 animate-spin"></i>`;
            lucide.createIcons();
            resultsContainer.innerHTML = '<p class="text-center text-white/70">...ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ®ÿ≠ÿ´</p>';

            try {
                const response = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=channel&key=${YOUTUBE_API_KEY}&maxResults=10`);
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();
                displayChannelSearchResults(data.items);
            } catch (error) {
                console.error("Error searching for channel:", error);
                resultsContainer.innerHTML = '<p class="text-center text-red-400">ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ®ÿ≠ÿ´. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.</p>';
            } finally {
                confirmBtn.disabled = false;
                confirmBtn.innerHTML = `<i data-lucide="search" class="w-5 h-5"></i>`;
                lucide.createIcons();
            }
        }

        function displayChannelSearchResults(channels) {
            const resultsContainer = document.getElementById('channel-search-results');
            resultsContainer.innerHTML = '';

            if (!channels || channels.length === 0) {
                resultsContainer.innerHTML = '<p class="text-center text-white/70">ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÇŸÜŸàÿßÿ™ ÿ®Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ŸÖ.</p>';
                return;
            }

            channels.forEach(channel => {
                const isSaved = localChannelsCache.some(c => c.channelid === channel.id.channelId);
                const resultCard = document.createElement('div');
                resultCard.className = 'flex items-center gap-4 p-3 rounded-xl bg-white/5';
                resultCard.innerHTML = `
                    <img src="${channel.snippet.thumbnails.default.url}" alt="${channel.snippet.title}" class="w-16 h-16 rounded-full object-cover">
                    <div class="flex-grow min-w-0">
                        <h4 class="font-bold truncate">${channel.snippet.title}</h4>
                        <p class="text-sm text-white/60 truncate">${channel.snippet.description || 'ŸÑÿß ŸäŸàÿ¨ÿØ ŸàÿµŸÅ'}</p>
                    </div>
                    <button 
                        class="add-channel-from-modal-btn p-2 rounded-full transition-colors flex-shrink-0 navigable grid-item ${isSaved ? 'bg-green-600' : 'bg-blue-600 hover:bg-blue-700'}" 
                        data-channel-id="${channel.id.channelId}" 
                        data-channel-title="${channel.snippet.title}" 
                        data-channel-thumbnail="${channel.snippet.thumbnails.default.url}"
                        ${isSaved ? 'disabled' : ''}
                        tabindex="0"
                    >
                        <i data-lucide="${isSaved ? 'check' : 'plus'}" class="w-5 h-5 text-white"></i>
                    </button>
                `;
                resultsContainer.appendChild(resultCard);

                if (!isSaved) {
                    resultCard.querySelector('.add-channel-from-modal-btn').addEventListener('click', (e) => {
                        const btn = e.currentTarget;
                        const channelId = btn.dataset.channelId;
                        const channelTitle = btn.dataset.channelTitle;
                        const channelThumbnail = btn.dataset.channelThumbnail;
                        handleAddChannelFromModal(channelId, channelTitle, channelThumbnail);
                    });
                }
            });
            lucide.createIcons();
            updateNavigableElements();
        }
// --- REPLACE THIS FUNCTION ---
¬† ¬† ¬† ¬† async function handleAddChannelFromModal(channelId, channelTitle, channelThumbnail) {
¬† ¬† ¬† ¬† ¬† ¬† const modalButton = document.querySelector(`.add-channel-from-modal-btn[data-channel-id="${channelId}"]`);
¬† ¬† ¬† ¬† ¬† ¬† if (modalButton) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† modalButton.disabled = true;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† modalButton.innerHTML = `<i data-lucide="loader-2" class="w-5 h-5 text-yellow-400 animate-spin"></i>`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† lucide.createIcons();
¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (localChannelsCache.some(c => c.channelid === channelId)) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†showMessageBox("Ÿáÿ∞Ÿá ÿßŸÑŸÇŸÜÿßÿ© ŸÖŸàÿ¨ŸàÿØÿ© ÿ®ÿßŸÑŸÅÿπŸÑ ŸÅŸä ŸÇÿßÿ¶ŸÖÿ™ŸÉ.");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†if (modalButton) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†modalButton.innerHTML = `<i data-lucide="check" class="w-5 h-5 text-white"></i>`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†modalButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†modalButton.classList.add('bg-green-600');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†lucide.createIcons();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†}
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†return;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // [FIX] ÿ•ÿ∂ÿßŸÅÿ© ÿÆÿßÿµŸäÿ© clickschannel: 0
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const newChannel = { 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† name: channelTitle, 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† image: channelThumbnail, 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† channelid: channelId, 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† channeltitle: channelTitle,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† clickschannel: 0 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† };
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const updatedList = [...localChannelsCache, newChannel];
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const success = await updateChannelsList(updatedList);

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (success) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showMessageBox(`ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ© ŸÇŸÜÿßÿ© "${newChannel.name}" ÿ®ŸÜÿ¨ÿßÿ≠.`);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (modalButton) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†modalButton.innerHTML = `<i data-lucide="check" class="w-5 h-5 text-white"></i>`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†modalButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†modalButton.classList.add('bg-green-600');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†lucide.createIcons();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // ... (ÿßŸÑŸÉŸàÿØ ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ ŸÑÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸàÿßÿ¨Ÿáÿ©) ...
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const suggestionsContent = document.getElementById('suggestions-content');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if(suggestionsContent) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const activeTabId = document.querySelector('#screen-Media .tab-button.active')?.id;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† suggestionsContent.innerHTML = '';
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† await populateYoutubeSuggestions();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (activeTabId) { document.getElementById(activeTabId)?.click(); } 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† else { document.getElementById('tab-channels')?.click(); }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.error("Error adding channel from modal:", error);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showMessageBox("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÇŸÜÿßÿ©.");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (modalButton) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†modalButton.disabled = false;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†modalButton.innerHTML = `<i data-lucide="plus" class="w-5 h-5 text-white"></i>`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†lucide.createIcons();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }

       async function addChannelFromSearchResult(channelId, channelTitle, channelThumbnail, buttonElement) {
¬† ¬† ¬† ¬† ¬† ¬† if (!channelId || !channelTitle) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showMessageBox("ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÇŸÜÿßÿ© ÿ∫Ÿäÿ± ŸÉÿßŸÖŸÑÿ©.");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† if (buttonElement) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† buttonElement.disabled = true;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† buttonElement.innerHTML = `<i data-lucide="check-circle" class="w-5 h-5 text-green-400"></i>`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† lucide.createIcons();
¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (localChannelsCache.some(c => c.channelid === channelId)) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†showMessageBox("Ÿáÿ∞Ÿá ÿßŸÑŸÇŸÜÿßÿ© ŸÖŸàÿ¨ŸàÿØÿ© ÿ®ÿßŸÑŸÅÿπŸÑ ŸÅŸä ŸÇÿßÿ¶ŸÖÿ™ŸÉ.");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†return;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const newChannel = {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† name: channelTitle,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† image: channelThumbnail,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† channelid: channelId,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† channeltitle: channelTitle,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† clickschannel: 0 // [ÿ™ÿπÿØŸäŸÑ] ÿ•ÿ∂ÿßŸÅÿ© ÿπÿØŸëÿßÿØ ÿßŸÑŸÜŸÇÿ±ÿßÿ™
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† };

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const updatedList = [...localChannelsCache, newChannel];
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const success = await updateChannelsList(updatedList);

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (success) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showMessageBox(`ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ© ŸÇŸÜÿßÿ© "${newChannel.name}" ÿ®ŸÜÿ¨ÿßÿ≠.`);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (buttonElement) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† buttonElement.disabled = false;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† buttonElement.innerHTML = `<i data-lucide="plus-circle" class="w-5 h-5 text-green-400"></i>`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† lucide.createIcons();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.error("Error adding channel from search result:", error);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showMessageBox("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÇŸÜÿßÿ©.");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (buttonElement) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† buttonElement.disabled = false;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† buttonElement.innerHTML = `<i data-lucide="plus-circle" class="w-5 h-5 text-green-400"></i>`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† lucide.createIcons();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }

        async function removeChannelFromList(channelId, channelName) {
            if (!channelId) return;

            // This function directly removes the channel. A confirmation modal would be a good addition later.
            try {
                const updatedList = localChannelsCache.filter(c => c.channelid !== channelId);
                const success = await updateChannelsList(updatedList);
                
                if (success) {
                    showMessageBox(`ÿ™ŸÖÿ™ ÿ•ÿ≤ÿßŸÑÿ© ŸÇŸÜÿßÿ© "${channelName}" ÿ®ŸÜÿ¨ÿßÿ≠.`);
                    // Refresh the entire suggestions view to reflect the deletion
                    const suggestionsContent = document.getElementById('suggestions-content');
                    if(suggestionsContent) {
                       suggestionsContent.innerHTML = '';
                       await populateYoutubeSuggestions(); // await to ensure it completes
                       // After refresh, focus might be lost, so let's refocus on the tab
                       const activeTab = document.querySelector('#screen-Media .tab-button.active');
                       if(activeTab) setFocus(activeTab);
                    }
                }
            } catch (error) {
                console.error("Error removing channel from list:", error);
                showMessageBox("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸÇŸÜÿßÿ©.");
            }
        }
        // --- END: NEW Channel List Functions ---
        
        async function searchYouTubeVideos(query) {
            try {
                const res = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&key=${YOUTUBE_API_KEY}&maxResults=50`);
                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({}));
                    console.error("YouTube API error (search):", errorData?.error?.message || res.status);
                    throw new Error("API search request failed.");
                }
                const data = await res.json();
                if (data.items && data.items.length > 0) {
                    const videoIds = data.items.map(item => item.id.videoId);
                    const videoDetails = await fetchVideosDetails(videoIds);

                    if (videoDetails === null) {
                        throw new Error("Failed to fetch details for search results.");
                    }
                    
                    // NEW: Fetch channel thumbnails
                    const channelIds = [...new Set(videoDetails.map(video => video.snippet.channelId))];
                    const channelThumbnails = await fetchChannelsDetails(channelIds);

                    lastSuccessfulSearchQuery = query; // NEW: Save the last successful query
                    searchResultsContainer.innerHTML = '';
                    videoDetails.forEach(video => {
                        const isLive = video.snippet.liveBroadcastContent === 'live';
                        const durationString = video.contentDetails.duration;

                        if (!isLive) {
                            const durationSeconds = durationString.match(/\d+/g)?.map(Number).reduce((acc, time, i, arr) => acc + time * (arr.length === 3 ? [3600, 60, 1][i] : (arr.length === 2 ? [60, 1][i] : 1)), 0) || 0;
                            if (durationSeconds <= 61) return;
                        }

                        const videoData = {
                            id: video.id,
                            title: video.snippet.title,
                            thumbnail: video.snippet.thumbnails.medium.url,
                            channelTitle: video.snippet.channelTitle,
                            channelId: video.snippet.channelId,
                            channelThumbnail: channelThumbnails[video.snippet.channelId],
                            viewCount: formatViewCount(video.statistics.viewCount),
                            publishedAt: formatTimeAgo(video.snippet.publishedAt),
                            duration: isLive ? 'ŸÖÿ®ÿßÿ¥ÿ±' : formatDuration(durationString)
                        };
                        searchResultsContainer.appendChild(createVideoCard(videoData));
                    });
                    
                    youtubeSuggestionsDiv.style.display = 'none';
                    youtubeVideoListView.classList.add('hidden');
                    youtubeSearchResultsView.classList.remove('hidden');
                    activeMediaView = 'searchResults';
                    backToPlaylistsBottomButton.style.display = 'none';
                    backToPlaylistsBottomButtonSearch.style.display = 'flex';
                    backToSearchFloatingButton.style.display = 'flex'; // NEW: Show the floating button
                    // The back button is now inside a container, so we don't hide/show it directly
                    updateNavigationButtons(query); // NEW: Update navigation buttons
                    setTimeout(() => { const firstResult = searchResultsContainer.querySelector('.grid-item'); if (firstResult) setFocus(firstResult); }, 100);
                } else {
                    showMessageBox('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÜÿ™ÿßÿ¶ÿ¨ ÿ®ÿ≠ÿ´ ŸÑŸÄ: ' + query);
                }
            } catch (err) {
                console.error('Error searching YouTube videos:', err);
                showMessageBox('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ŸäŸàÿ™ŸäŸàÿ®. ŸÇÿØ ÿ™ŸÉŸàŸÜ ŸáŸÜÿßŸÉ ŸÖÿ¥ŸÉŸÑÿ© ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ£Ÿà ŸÖŸÅÿ™ÿßÿ≠ API.');
            }
        }
        
        async function searchVideosByChannel(channelId, channelTitle) {
            if (!channelId) return;

            searchResultsContainer.innerHTML = `<h2 class="text-3xl font-bold mb-4 text-center w-full text-white col-span-full">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÖŸÜ ${channelTitle}...</h2>`;
            youtubeSuggestionsDiv.style.display = 'none';
            youtubeVideoListView.classList.add('hidden');
            youtubeSearchResultsView.classList.remove('hidden');
            activeMediaView = 'searchResults';

            try {
                // Step 1: Get the uploads playlist ID from the channel ID
                const channelRes = await fetch(`https://www.googleapis.com/youtube/v3/channels?part=contentDetails,snippet&id=${channelId}&key=${YOUTUBE_API_KEY}`);
                if (!channelRes.ok) {
                    throw new Error("Failed to fetch channel details to find uploads playlist.");
                }
                const channelData = await channelRes.json();
                const uploadsPlaylistId = channelData?.items?.[0]?.contentDetails?.relatedPlaylists?.uploads;
                const channelThumbnail = channelData?.items?.[0]?.snippet?.thumbnails?.default?.url;

                if (!uploadsPlaylistId) {
                    throw new Error("Could not find the uploads playlist for this channel.");
                }

                // Step 2: Get the video items from the uploads playlist
                const playlistRes = await fetch(`https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=${uploadsPlaylistId}&key=${YOUTUBE_API_KEY}&maxResults=50`);
                 if (!playlistRes.ok) {
                    throw new Error("Failed to fetch videos from the channel's playlist.");
                }
                const playlistData = await playlistRes.json();

                if (playlistData.items && playlistData.items.length > 0) {
                    const videoIds = playlistData.items.map(item => item.snippet.resourceId.videoId).filter(id => id);
                    const videoDetails = await fetchVideosDetails(videoIds);

                    if (videoDetails === null) {
                        throw new Error("Failed to fetch details for channel videos.");
                    }

                    searchResultsContainer.innerHTML = `<h2 class="text-3xl font-bold mb-4 text-center w-full text-white col-span-full"> ŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÖŸÜ ${channelTitle}</h2>`;

                    videoDetails.forEach(video => {
                        const isLive = video.snippet.liveBroadcastContent === 'live';
                        const durationString = video.contentDetails.duration;
                        
                        if (!isLive) {
                            const durationSeconds = durationString.match(/\d+/g)?.map(Number).reduce((acc, time, i, arr) => acc + time * (arr.length === 3 ? [3600, 60, 1][i] : (arr.length === 2 ? [60, 1][i] : 1)), 0) || 0;
                            if (durationSeconds <= 61) return;
                        }

                        const videoData = {
                            id: video.id,
                            title: video.snippet.title,
                            thumbnail: video.snippet.thumbnails.medium.url,
                            channelTitle: video.snippet.channelTitle,
                            channelId: video.snippet.channelId,
                            channelThumbnail: channelThumbnail,
                            viewCount: formatViewCount(video.statistics.viewCount),
                            publishedAt: formatTimeAgo(video.snippet.publishedAt),
                            duration: isLive ? 'ŸÖÿ®ÿßÿ¥ÿ±' : formatDuration(durationString)
                        };
                        searchResultsContainer.appendChild(createVideoCard(videoData));
                    });

                    lucide.createIcons();
                    updateNavigableElements();
                    backToPlaylistsBottomButton.style.display = 'none';
                    backToPlaylistsBottomButtonSearch.style.display = 'flex';
                    backToSearchFloatingButton.style.display = 'flex';
                    previousItemButton.style.display = 'none';
                    nextItemButton.style.display = 'none';

                    setTimeout(() => {
                        const firstResult = searchResultsContainer.querySelector('.grid-item');
                        if (firstResult) setFocus(firstResult);
                    }, 100);

                } else {
                    searchResultsContainer.innerHTML = `<h2 class="text-3xl font-bold mb-4 text-center w-full text-white col-span-full">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÅŸä ŸÇŸÜÿßÿ© ${channelTitle}</h2>`;
                }
            } catch (err) {
                console.error('Error searching videos by channel:', err);
                searchResultsContainer.innerHTML = `<h2 class="text-3xl font-bold mb-4 text-center w-full text-white col-span-full text-red-400">ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ŸÖŸäŸÑ ŸÅŸäÿØŸäŸàŸáÿßÿ™ ÿßŸÑŸÇŸÜÿßÿ©. ŸÇÿØ ÿ™ŸÉŸàŸÜ ŸáŸÜÿßŸÉ ŸÖÿ¥ŸÉŸÑÿ© ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ£Ÿà ŸÖŸÅÿ™ÿßÿ≠ API.</h2>`;
            }
        }
        
        async function showVideoPopup(videoId, startOverride = null) {
            const start = startOverride !== null ? startOverride : (() => {
                const history = getWatchedHistory();
                const watchedInfo = history[videoId];
                // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÇÿØ ÿ¥ÿßŸáÿØ ÿ£ŸÉÿ´ÿ± ŸÖŸÜ 5 ÿ´ŸàÿßŸÜŸçÿå ÿßÿ≥ÿ™ÿ£ŸÜŸÅ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑÿå Ÿàÿ•ŸÑÿß ÿßÿ®ÿØÿ£ ŸÖŸÜ ÿßŸÑÿµŸÅÿ±
                return (watchedInfo && watchedInfo.progress > 5) ? watchedInfo.progress : 0;
            })();
    
            // UPDATED: Pause background animations and update control button icon
            document.body.classList.add('animation-paused');
            const playIcon = pauseAnimationButton.querySelector('[data-lucide="play"]');
            const pauseIcon = pauseAnimationButton.querySelector('[data-lucide="pause"]');
            if (playIcon && pauseIcon) {
                playIcon.classList.remove('hidden'); // Show play icon (indicating animations are paused)
                pauseIcon.classList.add('hidden');
            }

            if (!isYouTubeApiReady) return setTimeout(() => showVideoPopup(videoId, start), 100);
            currentPlayingVideoId = videoId;
            videoPopupContainer.style.display = 'flex'; // Ensure it's visible
            videoPopupContainer.classList.add('active');
            // Hide the minimized button when showing the main player
            floatingMinimizedVideoButton.style.display = 'none';
            appState.isVideoPlayerMinimized = false;

            // --- START: NEW BOOKMARK BUTTON LOGIC ---
            const controlsContainer = videoPopupCloseButton.parentElement;
            if (controlsContainer && !document.getElementById('video-popup-bookmark-button')) {
                const bookmarkBtn = document.createElement('button');
                bookmarkBtn.id = 'video-popup-bookmark-button';
                bookmarkBtn.className = 'navigable grid-item p-3 rounded-full glass-surface glass-surface--svg hover:bg-white/20 transition-colors';
                bookmarkBtn.innerHTML = `<i data-lucide="bookmark" class="w-6 h-6"></i>`;
                bookmarkBtn.tabIndex = 0;

                // Set initial state
                const isSavedD = favoritesD.some(fav => fav.id === videoId);
                const isSavedM = favoritesM.some(fav => fav.id === videoId);
                if (isSavedD && isSavedM) bookmarkBtn.classList.add('saved-both');
                else if (isSavedD) bookmarkBtn.classList.add('saved-d');
                else if (isSavedM) bookmarkBtn.classList.add('saved-m');

                // Add click listener to fetch details and show menu
                bookmarkBtn.onclick = async (e) => {
                    e.stopPropagation();
                    const currentVideoId = currentPlayingVideoId; // Use the stored ID
                    if (!currentVideoId) return;

                    // Fetch details on demand
                    const videoDetailsList = await fetchVideosDetails([currentVideoId]);
                    if (!videoDetailsList || videoDetailsList.length === 0) {
                        showMessageBox("ÿÆÿ∑ÿ£: ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸà.");
                        return;
                    }
                    const videoDetails = videoDetailsList[0];
                    const channelThumbnails = await fetchChannelsDetails([videoDetails.snippet.channelId]);

                    // Reconstruct the videoData object
                    const videoData = {
                        id: videoDetails.id,
                        title: videoDetails.snippet.title,
                        thumbnail: videoDetails.snippet.thumbnails.medium.url,
                        channelTitle: videoDetails.snippet.channelTitle,
                        channelId: videoDetails.snippet.channelId,
                        channelThumbnail: channelThumbnails[videoDetails.snippet.channelId],
                        viewCount: formatViewCount(videoDetails.statistics.viewCount),
                        publishedAt: formatTimeAgo(videoDetails.snippet.publishedAt),
                        duration: formatDuration(videoDetails.contentDetails.duration)
                    };

                    // Show the menu
                    showFavoritesMenu(bookmarkBtn, videoData);
                };

                // Insert the button before the close button
                controlsContainer.insertBefore(bookmarkBtn, videoPopupCloseButton);
                lucide.createIcons();
            }
            // --- END: NEW BOOKMARK BUTTON LOGIC ---

            if (popupPlayer) {
                popupPlayer.loadVideoById({ videoId, startSeconds: start });
            } else {
                videoPopupPlayerContainer.innerHTML = '<div id="video-popup-player"></div>';
                popupPlayer = new YT.Player('video-popup-player', {
                    height: '100%', width: '100%', videoId,
                    playerVars: { 
                        'autoplay': 1, 
                        'controls': 1, 
                        'start': Math.floor(start),
                        'origin': 'https://dmusera.netlify.app'
                    },
                    events: { 
                        'onReady': (e) => e.target.playVideo(),
                        'onStateChange': onPlayerStateChange 
                    }
                });
            }
            setTimeout(() => setFocus(videoPopupCloseButton), 100);
        }
async function hideVideoPopup() {
            if (progressInterval) clearInterval(progressInterval);

            // 1. Get all necessary data from the player BEFORE destroying it
            let videoId, currentTime, duration;
            if (popupPlayer && typeof popupPlayer.getCurrentTime === 'function' && popupPlayer.getVideoData) {
                const videoData = popupPlayer.getVideoData();
                videoId = videoData ? videoData.video_id : null;
                currentTime = popupPlayer.getCurrentTime();
                duration = popupPlayer.getDuration();
            }

            // 2. Destroy the player immediately
            if (popupPlayer) {
                popupPlayer.destroy();
                popupPlayer = null;
            }

            // 3. NOW, update the progress using the stored data
            if (videoId) {
                await updateVideoProgress(videoId, currentTime, duration);
            }
            
            // 4. Handle all other UI updates
            document.body.classList.remove('animation-paused');
            const playIcon = pauseAnimationButton.querySelector('[data-lucide="play"]');
            const pauseIcon = pauseAnimationButton.querySelector('[data-lucide="pause"]');
            if (playIcon && pauseIcon) {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            }
            
            videoPopupContainer.classList.remove('active');
            videoPopupContainer.style.display = 'none';
            floatingMinimizedVideoButton.style.display = 'none';
            appState.isVideoPlayerMinimized = false;

            // --- START: NEW CLEANUP LOGIC ---
            // Remove the bookmark button so it can be re-created fresh next time
            const bookmarkBtn = document.getElementById('video-popup-bookmark-button');
            if (bookmarkBtn) {
                bookmarkBtn.remove();
            }
            // --- END: NEW CLEANUP LOGIC ---
            
            const screen = document.querySelector('.app-screen.active');
            if (screen) {
                const item = screen.querySelector('.grid-item');
                if (item) setFocus(item);
            }
        }
        
        // NEW: Functions to minimize and restore the video popup
        function minimizeVideoPopup() {
            if (!videoPopupContainer.classList.contains('active')) return;
            videoPopupContainer.style.display = 'none';
            floatingMinimizedVideoButton.style.display = 'flex';
            
            const videoData = popupPlayer.getVideoData();
            const titleElement = floatingMinimizedVideoButton.querySelector('.minimized-title');
            if(titleElement) titleElement.textContent = videoData.title || '...';

            appState.isVideoPlayerMinimized = true;
            // Focus the restore button for accessibility
            setFocus(floatingMinimizedVideoButton);
        }

        function restoreVideoPopup() {
            if (!appState.isVideoPlayerMinimized) return;
            videoPopupContainer.style.display = 'flex';
            floatingMinimizedVideoButton.style.display = 'none';
            appState.isVideoPlayerMinimized = false;
             // Return focus to the close button inside the player
            setFocus(videoPopupCloseButton);
        }

        function onPlayerStateChange(event) {
            if (event.data == YT.PlayerState.PLAYING) {
                // When video starts playing, set quality to 144p ('tiny')
                popupPlayer.setPlaybackQuality('tiny');

                // Start tracking progress
                progressInterval = setInterval(() => {
                    const videoId = popupPlayer.getVideoData().video_id;
                    const currentTime = popupPlayer.getCurrentTime();
                    const duration = popupPlayer.getDuration();
                    updateVideoProgress(videoId, currentTime, duration);
                }, 5000); // Save progress every 5 seconds

            } else if (event.data == YT.PlayerState.ENDED) {
                if (progressInterval) clearInterval(progressInterval);
                const videoId = popupPlayer.getVideoData().video_id;
                markVideoAsWatched(videoId);
            } else {
                 if (progressInterval) {
                    clearInterval(progressInterval);
                    progressInterval = null;
                }
            }
        }

        function handleFullScreenChange() {
            if (popupPlayer && typeof popupPlayer.getPlayerState === 'function' && popupPlayer.getPlayerState() === YT.PlayerState.PLAYING) {
                const isFullScreen = document.fullscreenElement === popupPlayer.getIframe() || document.webkitFullscreenElement === popupPlayer.getIframe();
                if (isFullScreen) {
                    popupPlayer.setPlaybackQuality('hd720');
                } else {
                    popupPlayer.setPlaybackQuality('large'); // 'large' for 480p
                }
            }
        }

        // This function is duplicated, removing one instance.
        
        // NEW: Function to handle next/previous navigation buttons
        function updateNavigationButtons(currentQuery) {
            // Reset and hide buttons by default
            previousItemButton.style.display = 'none';
            nextItemButton.style.display = 'none';
            previousItemButton.onclick = null;
            nextItemButton.onclick = null;

            // --- Case 1: Surah Navigation ---
            const surahMatch = currentQuery.match(/ÿ≥Ÿàÿ±ÿ© (.+)/);
            if (surahMatch && surahMatch[1]) {
                const currentSurah = surahMatch[1].trim();
                const currentIndex = youtubeSurahSuggestions.indexOf(currentSurah);

                if (currentIndex !== -1) {
                    const baseQuery = currentQuery.substring(0, currentQuery.indexOf('ÿ≥Ÿàÿ±ÿ©'));

                    // Previous Surah Button
                    if (currentIndex > 0) {
                        const prevSurah = youtubeSurahSuggestions[currentIndex - 1];
                        previousItemButton.innerHTML = `<i data-lucide="arrow-left"></i> ${prevSurah}`;
                        previousItemButton.style.display = 'flex';
                        previousItemButton.onclick = () => searchYouTubeVideos(`${baseQuery} ÿ≥Ÿàÿ±ÿ© ${prevSurah}`);
                    }

                    // Next Surah Button
                    if (currentIndex < youtubeSurahSuggestions.length - 1) {
                        const nextSurah = youtubeSurahSuggestions[currentIndex + 1];
                        nextItemButton.innerHTML = `${nextSurah} <i data-lucide="arrow-right"></i>`;
                        nextItemButton.style.display = 'flex';
                        nextItemButton.onclick = () => searchYouTubeVideos(`${baseQuery} ÿ≥Ÿàÿ±ÿ© ${nextSurah}`);
                    }
                    lucide.createIcons();
                    return;
                }
            }

            // --- Case 2: Juz Navigation ---
            const juzMatch = currentQuery.match(/ÿßŸÑÿ¨ÿ≤ÿ° (.+)/);
            if (juzMatch && juzMatch[1]) {
                const currentJuz = juzMatch[1].trim();
                const currentIndex = juzArabicNames.indexOf(currentJuz);

                if (currentIndex !== -1) {
                    const baseQuery = currentQuery.substring(0, currentQuery.indexOf('ÿßŸÑÿ¨ÿ≤ÿ°')).trim();

                    // Previous Juz Button
                    if (currentIndex > 0) {
                        const prevJuz = juzArabicNames[currentIndex - 1];
                        previousItemButton.innerHTML = `<i data-lucide="arrow-left"></i> ÿßŸÑÿ¨ÿ≤ÿ° ${prevJuz}`;
                        previousItemButton.style.display = 'flex';
                        previousItemButton.onclick = () => searchYouTubeVideos(`${baseQuery} ÿßŸÑÿ¨ÿ≤ÿ° ${prevJuz}`.trim());
                    }

                    // Next Juz Button
                    if (currentIndex < juzArabicNames.length - 1) {
                        const nextJuz = juzArabicNames[currentIndex + 1];
                        nextItemButton.innerHTML = `ÿßŸÑÿ¨ÿ≤ÿ° ${nextJuz} <i data-lucide="arrow-right"></i>`;
                        nextItemButton.style.display = 'flex';
                        nextItemButton.onclick = () => searchYouTubeVideos(`${baseQuery} ÿßŸÑÿ¨ÿ≤ÿ° ${nextJuz}`.trim());
                    }
                    lucide.createIcons();
                    return;
                }
            }

            // --- Case 3: Reciter-Only Navigation ---
            const reciters = youtubeReaderSuggestions.filter(r => r.name !== "ÿ±ÿ®ÿ∑ ÿßŸÑÿ¢Ÿäÿßÿ™").map(r => r.name);
            const reciterIndex = reciters.indexOf(currentQuery.trim());

            if (reciterIndex !== -1) {
                // Previous Reciter Button
                if (reciterIndex > 0) {
                    const prevReciter = reciters[reciterIndex - 1];
                    previousItemButton.innerHTML = `<i data-lucide="arrow-left"></i> ${prevReciter}`;
                    previousItemButton.style.display = 'flex';
                    previousItemButton.onclick = () => {
                        searchMode = 'reciter_only'; // Preserve mode
                        searchYouTubeVideos(prevReciter);
                    };
                }

                // Next Reciter Button
                if (reciterIndex < reciters.length - 1) {
                    const nextReciter = reciters[reciterIndex + 1];
                    nextItemButton.innerHTML = `${nextReciter} <i data-lucide="arrow-right"></i>`;
                    nextItemButton.style.display = 'flex';
                    nextItemButton.onclick = () => {
                        searchMode = 'reciter_only'; // Preserve mode
                        searchYouTubeVideos(nextReciter);
                    };
                }
                lucide.createIcons();
                return;
            }
        }

         const youtubeReaderSuggestions = [             {"name":"ÿßŸÑÿ±ŸÇŸäÿ©", "image":"https://imgs.search.brave.com/afZfY6pdMu-EfuTtrt2hNKEW9TsUAnPOX2QnIlIFi1c/rs:fit:860:0:0:0/g:ce/aHR0cHM6Ly9jZG4u/YXJhYnNzdG9jay5j/b20vdXBsb2Fkcy92/ZWN0b3JzLzIzMDQx/L3J1cWF5YS1hbi1h/cmFiaWMtbmFtZS1m/b3ItcHJldmlldy0y/MzA0MS53ZWJw"},
{"name":"ŸÖÿ≠ŸÖÿØ ÿßŸäŸàÿ®","image":"https://dmusera.netlify.app/512px-Muhammad_Ayyub.webp"},{"name":"ÿπŸÑŸä ÿ¨ÿßÿ®ÿ±","image":"https://dmusera.netlify.app/ali-jaber.webp"},{"name":"ŸÖÿ≠ŸÖÿØ ÿßŸÑÿ∫ÿ≤ÿßŸÑŸä","image":"https://imgs.search.brave.com/QWUpKrFCLEvXilcNhgSRM6xKPjTlBtGA-BAsH9sN-Tc/rs:fit:200:200:1:0/g:ce/aHR0cHM6Ly9hci5p/c2xhbXdheS5uZXQv/dXBsb2Fkcy9hdXRo/b3JzLzUwNjEuanBn"},{"name":"ŸÖÿ¥ÿßÿ±Ÿä ÿßŸÑÿπŸÅÿßÿ≥Ÿä","image":"https://dmusera.netlify.app/512px-%D0%9C%D0%B8%D1%88%D0%B0%D1%80%D0%B8_%D0%A0%D0%B0%D1%88%D0%B8%D0%B4.webp"},{"name":"ÿπÿ®ÿØÿßŸÑŸÑŸá ÿßŸÑŸÇÿ±ÿßŸÅŸä","image":"https://yt3.googleusercontent.com/mHTg3RIX-a3NAR22lAnOvSq3-U_KBcL_Ax4FTNirc3flsb5OU8RWksKu6X8Ush9JhO0EOxxAwQY=s160-c-k-c0x00ffffff-no-rj"},{"name":"ÿßÿ≥ŸÑÿßŸÖ ÿµÿ®ÿ≠Ÿä","image":"https://imgs.search.brave.com/Sq4qNywnl1HmDjSuxWTshlQ8yV9fplcVnUoiErGC-38/rs:fit:860:0:0:0/g:ce/aHR0cHM6Ly9tZWRp/YS51bml0ZWRtdXNs/aW13b3JsZC5jb20v/aW1nLzIzLzEyLzIz/LzEyNDk1LmpwZw"},{"name":"ÿßÿ≠ŸÖÿØ ÿßŸÑŸÜŸÅŸäÿ≥","image":"https://dmusera.netlify.app/ahmednafes.jpg"},{"name":"Ÿäÿßÿ≥ÿ± ÿßŸÑÿØŸàÿ≥ÿ±Ÿä","image":"https://dmusera.netlify.app/Yasser_Al-Dosari.jpg"},
{"name":"ÿ±ÿ®ÿ∑ ÿßŸÑÿ¢Ÿäÿßÿ™","image":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggZD0iTTEwIDEzYTUgNSAwIDAgMCA3LjU0LjU0bD MtM2E1IDUgMCAwIDAtNy4wNy03LjA3bC0xLjcyIDEuNzIiLz48cGF0aCBkPSJNMTQgMTFhNSA1IDAgMCAwLTcuNTQtLjU0bC0zIDNhNSA1IDAgMCAwIDcuMDcgNy4wN2wxLjcyLTEuNzIiLz48L3N2Zz4="}, {"name":"ÿ±ÿ®ÿ∑ ÿßŸÑÿ¢Ÿäÿßÿ™","image":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggZD0iTTEwIDEzYTUgNSAwIDAgMCA3LjU0LjU0bDMtM2E1IDUgMCAwIDAtNy4wNy03LjA3bC0xLjcyIDEuNzIiLz48cGF0aCBkPSJNMTQgMTFhNSA1IDAgMCAwLTcuNTQtLjU0bC0zIDNhNSA1IDAgMCAwIDcuMDcgNy4wN2wxLjcyLTEuNzIiLz48L3N2Zz4="}
        ];
          const youtubeReaderSuggestions2 = [
            {"name":"ÿßŸÑÿ±ŸÇŸäÿ©", "image":"https://imgs.search.brave.com/afZfY6pdMu-EfuTtrt2hNKEW9TsUAnPOX2QnIlIFi1c/rs:fit:860:0:0:0/g:ce/aHR0cHM6Ly9jZG4u/YXJhYnNzdG9jay5j/b20vdXBsb2Fkcy92/ZWN0b3JzLzIzMDQx/L3J1cWF5YS1hbi1h/cmFiaWMtbmFtZS1m/b3ItcHJldmlldy0y/MzA0MS53ZWJw", "channelid": "", "channeltitle": ""},
            {"name":"ŸÖÿ≠ŸÅŸàŸÅ -BYMAHFOOF", "image":"https://yt3.googleusercontent.com/obc8dOfYmoZe50tvHCJNZgbLAnJAKb-YPSUnguahWqJ-Jm12At_lV8CjfPPuhAsM9i2K26QK=s160-c-k-c0x00ffffff-no-rj", "channelid": "UCABzsyFLLA-fKu05lR-49RA", "channeltitle": "ŸÖÿ≠ŸÅŸàŸÅ"},
            {"name":"ÿ™ŸÑÿßŸàÿßÿ™ Ÿäÿßÿ≥ÿ± ÿßŸÑÿØŸàÿ≥ÿ±Ÿä", "image":"https://yt3.googleusercontent.com/ytc/AIdro_k1n9v-3Z3x-v6Q2wY5kX1c8z-G4xQ6X1X5Xw=s176-c-k-c0x00ffffff-no-rj-mo", "channelid": "UClncV9OLPto_MinRzGfjr2g", "channeltitle": "ÿ™ŸÑÿßŸàÿßÿ™ Ÿäÿßÿ≥ÿ± ÿßŸÑÿØŸàÿ≥ÿ±Ÿä ÿ•ŸÖÿßŸÖ ÿßŸÑÿ≠ÿ±ŸÖ ÿßŸÑŸÖŸÉŸä"},
            {"name":"ŸÖÿ≤ÿßŸÖŸäÿ± ÿßŸÑŸÅÿ±ŸÇÿßŸÜ - Ÿäÿßÿ≥ÿ± ÿßŸÑÿØŸàÿ≥ÿ±Ÿä", "image":"https://yt3.googleusercontent.com/ATOVX4RIsbt20_VS0Ly0bNkm5NPCoseg-S28jEEFsMBhHxBRUGXWW1dFOSuKG5p1_Sx8C8fMqFs=s160-c-k-c0x00ffffff-no-rj", "channelid": "UCCoB7Hf8gjQzpAyzhvx7Ktg", "channeltitle": "ŸÖÿ≤ÿßŸÖŸäÿ± ÿßŸÑŸÅÿ±ŸÇÿßŸÜ - Ÿäÿßÿ≥ÿ± ÿßŸÑÿØŸàÿ≥ÿ±Ÿä"},
            {"name":"ÿπÿ®ÿØÿßŸÑŸÑŸá ÿßŸÑÿ¥ÿ≠ÿ±Ÿä", "image":"https://yt3.ggpht.com/KZblM_WDIfUaDyB0wmNZOfVDogOhHThprmFyzLL3AkvnLcKqFmhoJ00nsKHKCXizM94hGy1DSdo=s176-c-k-c0x00ffffff-no-rj-mo", "channelid": "UCyXm7QL-vmBIZcYCoPfmXgw", "channeltitle": "ÿπÿ®ÿØÿßŸÑŸÑŸá ÿßŸÑÿ¥ÿ≠ÿ±Ÿä"},
            {"name":"ÿ™ÿ±ÿ™ŸäŸÑ-@TarteelArabic", "image":"https://yt3.googleusercontent.com/pUYEmNtUgk7zmyKXVwzTyYCfli0AavVRgAomZITpyh3i6HT0mk35CCJv32Ra79-gKk276qSeYfw=s900-c-k-c0x00ffffff-no-rj", "channelid": "UCHVX6sawuLNAuRbJdfruXVA", "channeltitle": "ÿ™ÿ±ÿ™ŸäŸÑ"},
            {"name":"ŸÇŸÜÿßÿ© ÿßÿÆÿ∂ÿ±", "image":"https://yt3.ggpht.com/CNJHtl9UOLJwzpGI6_8meaFK6-nWkaXABqu4cXfx2oZnTZmvYgHANXoOY-IpGlNk2U9I5nbIX9I=s176-c-k-c0x00ffffff-no-rj-mo", "channelid": "UCtUor2SqesPS3b_SMFtLT_w", "channeltitle": "ÿ£ÿÆÿ∂ÿ±"},
            {"name":"ÿßÿ∞ÿßÿπÿ© ŸÖÿÆÿ™ŸÑŸÅ", "image":"https://yt3.ggpht.com/73c3-iw_Lubnz8tI6uxN17s1p8kOvwwsF5tatPe3JYAw_SRKeJfjprdH2wxHGPz3UHBM9NDxzs0=s176-c-k-c0x00ffffff-no-rj-mo", "channelid": "UC8vdjzu_0QMQlG9qNT5D_AQ", "channeltitle": "ÿ•ÿ∞ÿßÿπÿ© ŸÖÿÆÿ™ŸÑŸÅ"},
            {"name":"Qtratel", "image":"https://yt3.googleusercontent.com/4op5oT580d20t3w4i4dWjZmfT1YkVSDok-MVlx-c1--EaYt-wZuw1tebFOc-iQ_XRMfUIO0gYA=s160-c-k-c0x00ffffff-no-rj", "channelid": "", "channeltitle": ""},
            {"name":"Mohamed abubakr", "image":"https://yt3.ggpht.com/yp7xPPh1JotsxKkOMos1KWumw7UFFibydMnoPzhP100gsUGWnDXRTAhdV88gd6coAPkXQ5n1Rw=s176-c-k-c0x00ffffff-no-rj-mo", "channelid": "UC9i6gCxiph_aBj68Xs9Iqng", "channeltitle": "Mohamed Aboubakr"},
            {"name":"ÿ®ŸàÿØŸÉÿßÿ≥ÿ™", "image":"https://yt3.googleusercontent.com/0Vs32Zwp0qjXovZuV0kCCxCkKkCdTpAn_9_tky7mxQUM69EIrWK_oJawKy_fKpzL1KZN0LG7=s160-c-k-c0x00ffffff-no-rj", "channelid": "", "channeltitle": ""},
            {"name":"ÿ±ÿ®ÿ∑ ÿßŸÑÿ¢Ÿäÿßÿ™","image":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggZD0iTTEwIDEzYTUgNSAwIDAgMCA3LjU0LjU0bDMtM2E1IDUgMCAwIDAtNy4wNy03LjA3bC0xLjcyIDEuNzIiLz48cGF0aCBkPSJNMTQgMTFhNSA1IDAgMCAwLTcuNTQtLjU0bC0zIDNhNSA1IDAgMCAwIDcuMDcgNy4wN2wxLjcyLTEuNzIiLz48L3N2Zz4=", "channelid": "", "channeltitle": ""}
        ];
        
        const youtubeSurahSuggestions = ["ÿßŸÑŸÅÿßÿ™ÿ≠ÿ©","ÿßŸÑÿ®ŸÇÿ±ÿ©","ÿ¢ŸÑ ÿπŸÖÿ±ÿßŸÜ","ÿßŸÑŸÜÿ≥ÿßÿ°","ÿßŸÑŸÖÿßÿ¶ÿØÿ©","ÿßŸÑÿ£ŸÜÿπÿßŸÖ","ÿßŸÑÿ£ÿπÿ±ÿßŸÅ","ÿßŸÑÿ£ŸÜŸÅÿßŸÑ","ÿßŸÑÿ™Ÿàÿ®ÿ©","ŸäŸàŸÜÿ≥","ŸáŸàÿØ","ŸäŸàÿ≥ŸÅ","ÿßŸÑÿ±ÿπÿØ","ÿ•ÿ®ÿ±ÿßŸáŸäŸÖ","ÿßŸÑÿ≠ÿ¨ÿ±","ÿßŸÑŸÜÿ≠ŸÑ","ÿßŸÑÿ•ÿ≥ÿ±ÿßÿ°","ÿßŸÑŸÉŸáŸÅ","ŸÖÿ±ŸäŸÖ","ÿ∑Ÿá","ÿßŸÑÿ£ŸÜÿ®Ÿäÿßÿ°","ÿßŸÑÿ≠ÿ¨","ÿßŸÑŸÖÿ§ŸÖŸÜŸàŸÜ","ÿßŸÑŸÜŸàÿ±","ÿßŸÑŸÅÿ±ŸÇÿßŸÜ","ÿßŸÑÿ¥ÿπÿ±ÿßÿ°","ÿßŸÑŸÜŸÖŸÑ","ÿßŸÑŸÇÿµÿµ","ÿßŸÑÿπŸÜŸÉÿ®Ÿàÿ™","ÿßŸÑÿ±ŸàŸÖ","ŸÑŸÇŸÖÿßŸÜ","ÿßŸÑÿ≥ÿ¨ÿØÿ©","ÿßŸÑÿ£ÿ≠ÿ≤ÿßÿ®","ÿ≥ÿ®ÿ£","ŸÅÿßÿ∑ÿ±","Ÿäÿ≥","ÿßŸÑÿµÿßŸÅÿßÿ™","ÿµ","ÿßŸÑÿ≤ŸÖÿ±","ÿ∫ÿßŸÅÿ±","ŸÅÿµŸÑÿ™","ÿßŸÑÿ¥Ÿàÿ±Ÿâ","ÿßŸÑÿ≤ÿÆÿ±ŸÅ","ÿßŸÑÿØÿÆÿßŸÜ","ÿßŸÑÿ¨ÿßÿ´Ÿäÿ©","ÿßŸÑÿ£ÿ≠ŸÇÿßŸÅ","ŸÖÿ≠ŸÖÿØ","ÿßŸÑŸÅÿ™ÿ≠","ÿßŸÑÿ≠ÿ¨ÿ±ÿßÿ™","ŸÇ","ÿßŸÑÿ∞ÿßÿ±Ÿäÿßÿ™","ÿßŸÑÿ∑Ÿàÿ±","ÿßŸÑŸÜÿ¨ŸÖ","ÿßŸÑŸÇŸÖÿ±","ÿßŸÑÿ±ÿ≠ŸÖŸÜ","ÿßŸÑŸàÿßŸÇÿπÿ©","ÿßŸÑÿ≠ÿØŸäÿØ","ÿßŸÑŸÖÿ¨ÿßÿØŸÑÿ©","ÿßŸÑÿ≠ÿ¥ÿ±","ÿßŸÑŸÖŸÖÿ™ÿ≠ŸÜÿ©","ÿßŸÑÿµŸÅ","ÿßŸÑÿ¨ŸÖÿπÿ©","ÿßŸÑŸÖŸÜÿßŸÅŸÇŸàŸÜ","ÿßŸÑÿ™ÿ∫ÿßÿ®ŸÜ","ÿßŸÑÿ∑ŸÑÿßŸÇ","ÿßŸÑÿ™ÿ≠ÿ±ŸäŸÖ","ÿßŸÑŸÖŸÑŸÉ","ÿßŸÑŸÇŸÑŸÖ","ÿßŸÑÿ≠ÿßŸÇÿ©","ÿßŸÑŸÖÿπÿßÿ±ÿ¨","ŸÜŸàÿ≠","ÿßŸÑÿ¨ŸÜ","ÿßŸÑŸÖÿ≤ŸÖŸÑ","ÿßŸÑŸÖÿØÿ´ÿ±","ÿßŸÑŸÇŸäÿßŸÖÿ©","ÿßŸÑÿ•ŸÜÿ≥ÿßŸÜ","ÿßŸÑŸÖÿ±ÿ≥ŸÑÿßÿ™","ÿßŸÑŸÜÿ®ÿ£","ÿßŸÑŸÜÿßÿ≤ÿπÿßÿ™","ÿπÿ®ÿ≥","ÿßŸÑÿ™ŸÉŸàŸäÿ±","ÿßŸÑÿßŸÜŸÅÿ∑ÿßÿ±","ÿßŸÑÿßŸÜÿ¥ŸÇÿßŸÇ","ÿßŸÑŸÖÿ∑ŸÅŸÅŸäŸÜ","ÿßŸÑÿ®ÿ±Ÿàÿ¨","ÿßŸÑÿ∑ÿßÿ±ŸÇ","ÿßŸÑÿ£ÿπŸÑŸâ"];
        const surahToJuzMap = {"ÿßŸÑŸÅÿßÿ™ÿ≠ÿ©":1,"ÿßŸÑÿ®ŸÇÿ±ÿ©":1,"ÿ¢ŸÑ ÿπŸÖÿ±ÿßŸÜ":3,"ÿßŸÑŸÜÿ≥ÿßÿ°":4,"ÿßŸÑŸÖÿßÿ¶ÿØÿ©":6,"ÿßŸÑÿ£ŸÜÿπÿßŸÖ":7,"ÿßŸÑÿ£ÿπÿ±ÿßŸÅ":8,"ÿßŸÑÿ£ŸÜŸÅÿßŸÑ":9,"ÿßŸÑÿ™Ÿàÿ®ÿ©":10,"ŸäŸàŸÜÿ≥":11,"ŸáŸàÿØ":11,"ŸäŸàÿ≥ŸÅ":12,"ÿßŸÑÿ±ÿπÿØ":13,"ÿ•ÿ®ÿ±ÿßŸáŸäŸÖ":13,"ÿßŸÑÿ≠ÿ¨ÿ±":14,"ÿßŸÑŸÜÿ≠ŸÑ":14,"ÿßŸÑÿ•ÿ≥ÿ±ÿßÿ°":15,"ÿßŸÑŸÉŸáŸÅ":15,"ŸÖÿ±ŸäŸÖ":16,"ÿ∑Ÿá":16,"ÿßŸÑÿ£ŸÜÿ®Ÿäÿßÿ°":17,"ÿßŸÑÿ≠ÿ¨":17,"ÿßŸÑŸÖÿ§ŸÖŸÜŸàŸÜ":18,"ÿßŸÑŸÜŸàÿ±":18,"ÿßŸÑŸÅÿ±ŸÇÿßŸÜ":18,"ÿßŸÑÿ¥ÿπÿ±ÿßÿ°":19,"ÿßŸÑŸÜŸÖŸÑ":19,"ÿßŸÑŸÇÿµÿµ":20,"ÿßŸÑÿπŸÜŸÉÿ®Ÿàÿ™":20,"ÿßŸÑÿ±ŸàŸÖ":21,"ŸÑŸÇŸÖÿßŸÜ":21,"ÿßŸÑÿ≥ÿ¨ÿØÿ©":21,"ÿßŸÑÿ£ÿ≠ÿ≤ÿßÿ®":21,"ÿ≥ÿ®ÿ£":22,"ŸÅÿßÿ∑ÿ±":22,"Ÿäÿ≥":22,"ÿßŸÑÿµÿßŸÅÿßÿ™":23,"ÿµ":23,"ÿßŸÑÿ≤ŸÖÿ±":23,"ÿ∫ÿßŸÅÿ±":24,"ŸÅÿµŸÑÿ™":24,"ÿßŸÑÿ¥Ÿàÿ±Ÿâ":25,"ÿßŸÑÿ≤ÿÆÿ±ŸÅ":25,"ÿßŸÑÿØÿÆÿßŸÜ":25,"ÿßŸÑÿ¨ÿßÿ´Ÿäÿ©":25,"ÿßŸÑÿ£ÿ≠ŸÇÿßŸÅ":26,"ŸÖÿ≠ŸÖÿØ":26,"ÿßŸÑŸÅÿ™ÿ≠":26,"ÿßŸÑÿ≠ÿ¨ÿ±ÿßÿ™":26,"ŸÇ":26,"ÿßŸÑÿ∞ÿßÿ±Ÿäÿßÿ™":27,"ÿßŸÑÿ∑Ÿàÿ±":27,"ÿßŸÑŸÜÿ¨ŸÖ":27,"ÿßŸÑŸÇŸÖÿ±":27,"ÿßŸÑÿ±ÿ≠ŸÖŸÜ":27,"ÿßŸÑŸàÿßŸÇÿπÿ©":27,"ÿßŸÑÿ≠ÿØŸäÿØ":27,"ÿßŸÑŸÖÿ¨ÿßÿØŸÑÿ©":28,"ÿßŸÑÿ≠ÿ¥ÿ±":28,"ÿßŸÑŸÖŸÖÿ™ÿ≠ŸÜÿ©":28,"ÿßŸÑÿµŸÅ":28,"ÿßŸÑÿ¨ŸÖÿπÿ©":28,"ÿßŸÑŸÖŸÜÿßŸÅŸÇŸàŸÜ":28,"ÿßŸÑÿ™ÿ∫ÿßÿ®ŸÜ":28,"ÿßŸÑÿ∑ŸÑÿßŸÇ":28,"ÿßŸÑÿ™ÿ≠ÿ±ŸäŸÖ":28,"ÿßŸÑŸÖŸÑŸÉ":29,"ÿßŸÑŸÇŸÑŸÖ":29,"ÿßŸÑÿ≠ÿßŸÇÿ©":29,"ÿßŸÑŸÖÿπÿßÿ±ÿ¨":29,"ŸÜŸàÿ≠":29,"ÿßŸÑÿ¨ŸÜ":29,"ÿßŸÑŸÖÿ≤ŸÖŸÑ":29,"ÿßŸÑŸÖÿØÿ´ÿ±":29,"ÿßŸÑŸÇŸäÿßŸÖÿ©":29,"ÿßŸÑÿ•ŸÜÿ≥ÿßŸÜ":29,"ÿßŸÑŸÖÿ±ÿ≥ŸÑÿßÿ™":29,"ÿßŸÑŸÜÿ®ÿ£":30,"ÿßŸÑŸÜÿßÿ≤ÿπÿßÿ™":30,"ÿπÿ®ÿ≥":30,"ÿßŸÑÿ™ŸÉŸàŸäÿ±":30,"ÿßŸÑÿßŸÜŸÅÿ∑ÿßÿ±":30,"ÿßŸÑÿßŸÜÿ¥ŸÇÿßŸÇ":30,"ÿßŸÑŸÖÿ∑ŸÅŸÅŸäŸÜ":30,"ÿßŸÑÿ®ÿ±Ÿàÿ¨":30,"ÿßŸÑÿ∑ÿßÿ±ŸÇ":30,"ÿßŸÑÿ£ÿπŸÑŸâ":30};
        const juzColors =  [
  // üîµ Blues
  "#2563eb", // Strong Blue
  "#3b82f6", // Blue
  "#0ea5e9", // Sky Blue
  "#0891b2", // Deep Cyan
  "#06b6d4", // Cyan
  "#14b8a6", // Teal
  "#0d9488", // Dark Teal

  // üü£ Purples / Violets
  "#6366f1", // Indigo
  "#4f46e5", // Deep Indigo
  "#6d28d9", // Royal Violet
  "#8b5cf6", // Violet
  "#a855f7", // Purple
  "#9333ea", // Electric Purple
  "#c026d3", // Magenta
  "#d946ef", // Fuchsia

  // üå∏ Pinks / Rose
  "#ec4899", // Pink
  "#be185d", // Dark Pink
  "#f43f5e", // Rose
  "#fb7185", // Coral

  // üî¥ Reds
  "#ef4444", // Red
  "#dc2626", // Crimson

  // üü† Oranges
  "#ea580c", // Burnt Orange
  "#f97316", // Orange

  // üü° Yellows / Gold
  "#f59e0b", // Amber
  "#139c7e", // tealy
  "#c99716", // Gold
  "#7a6510", // dark gold
  "#ca8a04", // Dark Mustard

  // üü¢ Greens
  "#22c55e", // Green
  "#16a34a", // Strong Green
  "#10b981", // Emerald
  "#059669", // Dark Emerald

  // ‚ö´ Dark / Neutral
  "#1e293b", // Slate Dark
];
        function resetYoutubeSearchUI() {
            const suggestionsContent = document.getElementById('suggestions-content');
            if (suggestionsContent) {
                suggestionsContent.innerHTML = ''; // Clear old suggestions
                suggestionsContent.classList.remove('hidden'); //  ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ÿ∏Ÿáÿßÿ±Ÿá ŸÖÿ¨ÿØÿØÿßŸã
            }
            
            // ÿ•ÿµŸÑÿßÿ≠: ÿ•ÿ≤ÿßŸÑÿ© ŸÇÿ≥ŸÖ ÿßŸÑÿ≥Ÿàÿ± ÿ®ÿ¥ŸÉŸÑ ÿµÿ±Ÿäÿ≠ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖŸàÿ¨ŸàÿØÿßŸã
            const existingSurahSection = document.getElementById('youtube-surah-section');
            if (existingSurahSection) {
                existingSurahSection.remove();
            }
            
            youtubeSuggestionsDiv.style.display = 'flex';
            selectedReaderName = '';
            youtubeSearchInput.value = '';

            if (lastSuccessfulSearchQuery) {
                backToSearchFloatingButton.style.display = 'flex';
            } else {
                backToSearchFloatingButton.style.display = 'none';
            }

            displayLastWatchedVideo(); // This will populate #last-watched-container
            populateYoutubeSuggestions(); // This will populate #suggestions-content
        }
        
        function handleReaderOrToolClick(selection, tabContainer, tabsContentContainer) {
            if (selection === "ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑÿµÿπÿ®ÿ© ŸÅŸä") {
                selectedReaderName = ''; // Clear reader name
                youtubeSearchInput.value = 'ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑÿµÿπÿ®ÿ© ŸÅŸä ';
            } else if (selection === "JUST_SURAH") {
                selectedReaderName = ''; 
                youtubeSearchInput.value = '';
            } else {
                selectedReaderName = selection;
                youtubeSearchInput.value = selection + ' ';
            }

            // Hide the tabs and show surahs
            tabContainer.style.display = 'none';
            tabsContentContainer.style.display = 'none';
            showSurahSuggestions();
            setTimeout(() => {
                const firstSurahButton = document.querySelector('#youtube-surah-section .grid-item');
                if (firstSurahButton) setFocus(firstSurahButton);
            }, 100);
        }


// --- REPLACE THIS FUNCTION AGAIN ---
¬† ¬† ¬† ¬†// --- REPLACE THIS FUNCTION AGAIN ---
¬† ¬† ¬† ¬†// --- REPLACE THIS FUNCTION AGAIN ---
¬† ¬†async function populateYoutubeSuggestions() {
    const suggestionsContent = document.getElementById('suggestions-content');
    if (!suggestionsContent) {
        console.error("suggestions-content element not found!");
        return;
    }
    console.log("[Debug] Starting populateYoutubeSuggestions...");

    suggestionsContent.innerHTML = '';
    suggestionsContent.className = 'flex flex-col gap-4 w-full';

    // 1. Create Tab Structure (MODIFIED)
    const tabContainer = document.createElement('div');
    tabContainer.className = 'tabs-container flex p-1 rounded-full bg-black/20 self-center';

    const recitersTabButton = document.createElement('button');
    recitersTabButton.id = 'tab-reciters';
    recitersTabButton.className = 'tab-button navigable grid-item';
    recitersTabButton.tabIndex = 0;
    recitersTabButton.textContent = 'ÿßŸÑŸÇÿ±ÿßÿ°';

    const channTabButton = document.createElement('button'); // Default active
    channTabButton.id = 'tab-channels';
    channTabButton.className = 'tab-button active navigable grid-item'; // Set Channels as active initially
    channTabButton.tabIndex = 0;
    channTabButton.textContent = 'ŸÇŸÜŸàÿßÿ™';

    const toolsTabButton = document.createElement('button');
    toolsTabButton.id = 'tab-tools';
    toolsTabButton.className = 'tab-button navigable grid-item';
    toolsTabButton.tabIndex = 0;
    toolsTabButton.textContent = 'ÿ£ÿØŸàÿßÿ™';

    // --- NEW: Split Saved Tabs ---
    const savedDTabButton = document.createElement('button');
    savedDTabButton.id = 'tab-saved-d';
    savedDTabButton.className = 'tab-button navigable grid-item';
    savedDTabButton.tabIndex = 0;
    savedDTabButton.textContent = 'ŸÖÿ™ÿßÿ®ÿπÿ©  ŸÅŸä ÿßŸÑÿ≥Ÿäÿßÿ±ÿ©'; // Car List

    const savedMTabButton = document.createElement('button');
    savedMTabButton.id = 'tab-saved-m';
    savedMTabButton.className = 'tab-button navigable grid-item';
    savedMTabButton.tabIndex = 0;
    savedMTabButton.textContent = 'ÿßŸÑŸÖÿ™ÿßÿ®ÿπÿ© ŸÅŸä ÿßŸÑÿ™ŸÑŸÅÿßÿ≤'; // TV List
    // --- END NEW ---

    tabContainer.appendChild(recitersTabButton);
    tabContainer.appendChild(channTabButton);
    tabContainer.appendChild(toolsTabButton);
    tabContainer.appendChild(savedDTabButton); // Add new D button
    tabContainer.appendChild(savedMTabButton); // Add new M button

    const tabsContentContainer = document.createElement('div');
    tabsContentContainer.id = 'tabs-content-container';
    tabsContentContainer.className = 'flex-grow w-full overflow-y-auto';

    console.log("[Debug] Created tab buttons and content container.");

    // 2. Create Content Panels (MODIFIED)
    const recitersContent = document.createElement('div');
    recitersContent.id = 'tab-content-reciters';
    recitersContent.className = 'tab-content hidden'; // Hide initially
    const readerButtonsContainer = document.createElement('div');
    readerButtonsContainer.className = 'reader-container';
    recitersContent.appendChild(readerButtonsContainer);

    const channContent = document.createElement('div'); // Default active content
    channContent.id = 'tab-content-channels';
    channContent.className = 'tab-content'; // Show initially
    const channButtonsContainer = document.createElement('div');
    channButtonsContainer.className = 'reader-container';
    channContent.appendChild(channButtonsContainer);

    const toolsContent = document.createElement('div');
    toolsContent.id = 'tab-content-tools';
    toolsContent.className = 'tab-content hidden';
    const toolsButtonsContainer = document.createElement('div');
    toolsButtonsContainer.className = 'reader-container';
    toolsContent.appendChild(toolsButtonsContainer);

    // --- NEW: Split Saved Content Divs ---
    const savedDContent = document.createElement('div');
    savedDContent.id = 'tab-content-saved-d';
    savedDContent.className = 'tab-content hidden h-full'; // Initially hidden
    savedDContent.innerHTML = `<div id="favorites-d-grid" class="p-4 grid grid-cols-1 md:grid-cols-2 gap-4"></div>`; // Grid for D

    const savedMContent = document.createElement('div');
    savedMContent.id = 'tab-content-saved-m';
    savedMContent.className = 'tab-content hidden h-full'; // Initially hidden
    savedMContent.innerHTML = `<div id="favorites-m-grid" class="p-4 grid grid-cols-1 md:grid-cols-2 gap-4"></div>`; // Grid for M
    // --- END NEW ---


    try {
        console.log("[Debug] Populating Reciters...");
        // --- Populate Reciters --- (Keep your existing code)
        youtubeReaderSuggestions.forEach(reader => {
             const card = document.createElement('div');
             card.className = 'youtube-reader-card navigable grid-item';
             card.tabIndex = 0;
             card.innerHTML = `<h3>${reader.name}</h3><img src="${reader.image}" alt="${reader.name}" onerror="this.onerror=null;this.src='https://placehold.co/100x100';">`;
             card.addEventListener('click', () => handleReaderOrToolClick(reader.name, tabContainer, tabsContentContainer));
             readerButtonsContainer.appendChild(card);
        });
        console.log("[Debug] Populated Reciters.");

        console.log("[Debug] Populating Channels...");
        // --- Populate Channels --- (Keep your existing code)
        let channList = await fetchChannelsList();
        if (Array.isArray(channList)) {
             channList.sort((a, b) => (parseInt(b?.clickschannel, 10) || 0) - (parseInt(a?.clickschannel, 10) || 0));
        } else {
             console.error("fetchChannelsList did not return an array."); channList = [];
        }
        const channelIdsToFetch = channList.filter(r => r && r.channelid).map(r => r.channelid);
        const channelThumbnails = channelIdsToFetch.length > 0 ? await fetchChannelsDetails(channelIdsToFetch) : {};
        channButtonsContainer.innerHTML = '';
        channList.forEach(reader => {
             if (!reader || typeof reader !== 'object') return;
             const card = document.createElement('div');
             card.className = 'youtube-reader-card navigable grid-item relative group';
             card.tabIndex = 0;
             const imageUrl = reader.channelid ? (channelThumbnails[reader.channelid] || 'https://placehold.co/100x100/334155/ffffff?text=?') : (reader.image || 'https://placehold.co/100x100/334155/ffffff?text=?');
             card.innerHTML = `
                 <button class="delete-channel-btn absolute bottom-2 right-2 p-1.5 bg-red-600/80 hover:bg-red-500 rounded-full transition-colors z-10 navigable grid-item" title="ÿ≠ÿ∞ŸÅ ÿßŸÑŸÇŸÜÿßÿ©" tabindex="0"><i data-lucide="trash-2" class="w-4 h-4 text-white pointer-events-none"></i></button>
                 <h3>${reader.name}</h3>
                 <img src="${imageUrl}" alt="${reader.name}" onerror="this.onerror=null;this.src='https://placehold.co/64x64';">`;
             card.addEventListener('click', (e) => {
                 if (e.target.closest('.delete-channel-btn')) return;
                 if (reader.channelid && reader.channeltitle) {
                     incrementChannelClick(reader.channelid);
                     searchVideosByChannel(reader.channelid, reader.channeltitle);
                 } else {
                     handleReaderOrToolClick(reader.name, tabContainer, tabsContentContainer);
                 }
             });
             const deleteBtn = card.querySelector('.delete-channel-btn');
             deleteBtn?.addEventListener('click', (e) => { e.stopPropagation(); removeChannelFromList(reader.channelid, reader.name); });
             channButtonsContainer.appendChild(card);
        });
        const addChannelCard = document.createElement('div');
        addChannelCard.className = 'youtube-reader-card navigable grid-item';
        addChannelCard.tabIndex = 0;
        addChannelCard.innerHTML = `<h3>ÿ•ÿ∂ÿßŸÅÿ© ŸÇŸÜÿßÿ©</h3><div class="w-[100px] h-[100px] rounded-full border-2 border-dashed border-white/30 flex items-center justify-center bg-black/20"><i data-lucide="plus" class="w-12 h-12 text-white/50"></i></div>`;
        addChannelCard.addEventListener('click', showAddChannelPrompt);
        channButtonsContainer.appendChild(addChannelCard);
        console.log("[Debug] Populated Channels.");


        console.log("[Debug] Populating Tools...");
        // --- Populate Tools --- (Keep your existing code)
        const tools = [
             { name: "ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑÿµÿπÿ®ÿ© ŸÅŸä", icon: "help-circle" },
             { name: "ŸÅŸÇÿ∑ ÿßŸÑÿ≥Ÿàÿ±ÿ©", icon: "book-open", specialAction: "JUST_SURAH" }
        ];
        tools.forEach(tool => {
            const card = document.createElement('div');
            card.className = 'youtube-reader-card navigable grid-item';
            card.tabIndex = 0;
            card.innerHTML = `<h3>${tool.name}</h3><div class="w-[100px] h-[100px] rounded-full border-2 border-white/30 flex items-center justify-center bg-black/20"><i data-lucide="${tool.icon}" class="w-12 h-12 text-white/50"></i></div>`;
            card.addEventListener('click', () => handleReaderOrToolClick(tool.specialAction || tool.name, tabContainer, tabsContentContainer));
            toolsButtonsContainer.appendChild(card);
        });
        console.log("[Debug] Populated Tools.");


        console.log("[Debug] Attaching click listeners to tab buttons...");

        // --- Tab Switching Logic (MODIFIED) ---
        const tabs = [recitersTabButton, channTabButton, toolsTabButton, savedDTabButton, savedMTabButton]; // Updated tabs array
        const contents = [recitersContent, channContent, toolsContent, savedDContent, savedMContent];   // Updated contents array

        tabs.forEach((tab, index) => {
            tab.addEventListener('click', () => {
                console.log(`[Debug] ${tab.textContent} tab clicked!`);
                tabs.forEach(t => t.classList.remove('active'));
                contents.forEach(c => c.classList.add('hidden'));
                tab.classList.add('active');
                contents[index].classList.remove('hidden');

                // --- Special actions for Saved tabs ---
                if (tab.id === 'tab-saved-d') {
                    loadSavedVideos('D'); // Load only D list
                } else if (tab.id === 'tab-saved-m') {
                    loadSavedVideos('M'); // Load only M list
                }
                // --- End Special actions ---

                const firstItem = contents[index].querySelector('.grid-item');
                if (firstItem) setFocus(firstItem); else setFocus(tab);
            });
        });
        console.log("[Debug] Finished attaching click listeners.");


        // 5. Append everything
        suggestionsContent.appendChild(tabContainer);
        tabsContentContainer.appendChild(recitersContent);
        tabsContentContainer.appendChild(channContent);
        tabsContentContainer.appendChild(toolsContent);
        tabsContentContainer.appendChild(savedDContent); // Add new D content
        tabsContentContainer.appendChild(savedMContent); // Add new M content
        suggestionsContent.appendChild(tabsContentContainer);

        // Set initial active tab (Channels is already set via class)

        lucide.createIcons();
        console.log("[Debug] Finished populateYoutubeSuggestions.");
        updateNavigableElements();

    } catch (error) {
        console.error("Error during populateYoutubeSuggestions:", error);
        suggestionsContent.innerHTML = '<p class="text-red-500 text-center">Error loading suggestions.</p>';
    }
}

        function showSurahSuggestions() {
            const existing = document.getElementById('youtube-surah-section');
            if (existing) existing.remove();

            const lastWatchedContainer = document.getElementById('last-watched-container');
            if (lastWatchedContainer) lastWatchedContainer.classList.add('hidden');

            // Hide the main suggestions content container to remove the top gap
            const suggestionsContent = document.getElementById('suggestions-content');
            if (suggestionsContent) suggestionsContent.classList.add('hidden');

            const surahSection = document.createElement('div');
            surahSection.id = 'youtube-surah-section';
            surahSection.className = 'flex flex-col gap-2 p-3 rounded-xl glass-surface glass-surface--svg w-full flex-grow';

            // 1. Create Tab Structure
            const tabContainer = document.createElement('div');
            tabContainer.className = 'tabs-container flex p-1 rounded-full bg-black/20 self-center mb-2';

            const surahTabButton = document.createElement('button');
            surahTabButton.id = 'tab-surah';
            surahTabButton.className = 'tab-button active navigable grid-item';
            surahTabButton.tabIndex = 0;
            surahTabButton.textContent = 'ÿßŸÑÿ≥Ÿàÿ±ÿ©';

            const juzTabButton = document.createElement('button');
            juzTabButton.id = 'tab-juz';
            juzTabButton.className = 'tab-button navigable grid-item';
            juzTabButton.tabIndex = 0;
            juzTabButton.textContent = 'ÿßŸÑÿ¨ÿ≤ÿ°';

            tabContainer.appendChild(surahTabButton);
            tabContainer.appendChild(juzTabButton);

            const tabsContentContainer = document.createElement('div');
            tabsContentContainer.id = 'tabs-content-container-surah';
            tabsContentContainer.className = 'flex-grow w-full overflow-hidden'; // Let inner container scroll

            // 2. Create Surah content panel
            const surahContent = document.createElement('div');
            surahContent.id = 'tab-content-surah';
            surahContent.className = 'tab-content h-full';
            
              const scrollableSurahContainer = document.createElement('div');
            scrollableSurahContainer.className = 'surah-buttons-scrollable h-full';
            const surahButtonsContainer = document.createElement('div');
            surahButtonsContainer.className = 'flex flex-wrap justify-center gap-2 w-full';
            
            youtubeSurahSuggestions.forEach(name => {
                const button = document.createElement('button');
                button.className = 'youtube-suggestion-button navigable grid-item';
                button.tabIndex = 0;
                button.innerHTML = `<span class="surah-name-text">${name}</span> <span class="juz-badge">${surahToJuzMap[name] || '?'}</span>`;
                button.style.backgroundColor = juzColors[(surahToJuzMap[name] || 1) - 1];
                button.addEventListener('click', () => {
                    let query = '';
                    const currentInput = youtubeSearchInput.value.trim();
                    if (youtubeSearchInput.value.startsWith('ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑÿµÿπÿ®ÿ© ŸÅŸä')) {
                        query = 'ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑÿµÿπÿ®ÿ© ŸÅŸä ÿ≥Ÿàÿ±ÿ© ' + name;
                    } else if (currentInput === '') {
                        query = 'ÿ≥Ÿàÿ±ÿ© ' + name;
                    } else {
                        query = selectedReaderName + ' ÿ≥Ÿàÿ±ÿ© ' + name;
                    }
                    youtubeSearchInput.value = query;
                    searchYouTubeVideos(query);
                });
                surahButtonsContainer.appendChild(button);
            });
            scrollableSurahContainer.appendChild(surahButtonsContainer);
            surahContent.appendChild(scrollableSurahContainer);

            // 3. Create Juz content panel
            const juzContent = document.createElement('div');
            juzContent.id = 'tab-content-juz';
            juzContent.className = 'tab-content hidden h-full';

            const scrollableJuzContainer = document.createElement('div');
            scrollableJuzContainer.className = 'surah-buttons-scrollable h-full';
            const juzButtonsContainer = document.createElement('div');
            juzButtonsContainer.className = 'flex flex-wrap justify-center gap-2 w-full';

            for (let i = 1; i <= 30; i++) {
                const button = document.createElement('button');
                button.className = 'youtube-suggestion-button navigable grid-item';
                button.tabIndex = 0;
                button.style.backgroundColor = juzColors[(i % juzColors.length)];
                button.innerHTML = `ÿßŸÑÿ¨ÿ≤ÿ° ${i}`;
                button.addEventListener('click', () => {
                    const juzName = juzArabicNames[i - 1];
                    let query = '';
                    const currentSearch = youtubeSearchInput.value;
                    if (currentSearch.trim() && !currentSearch.startsWith('ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑÿµÿπÿ®ÿ© ŸÅŸä')) {
                        query = currentSearch + `ÿßŸÑÿ¨ÿ≤ÿ° ${juzName}`;
                    } else {
                        query = `ÿßŸÑÿ¨ÿ≤ÿ° ${juzName}`;
                    }
                    youtubeSearchInput.value = query;
                    searchYouTubeVideos(query);
                });
                juzButtonsContainer.appendChild(button);
            }
            scrollableJuzContainer.appendChild(juzButtonsContainer);
            juzContent.appendChild(scrollableJuzContainer);

            // 4. Tab Switching Logic
            surahTabButton.addEventListener('click', () => {
                surahTabButton.classList.add('active');
                juzTabButton.classList.remove('active');
                surahContent.classList.remove('hidden');
                juzContent.classList.add('hidden');
                const firstItem = surahContent.querySelector('.grid-item');
                if (firstItem) setFocus(firstItem);
            });
            juzTabButton.addEventListener('click', () => {
                juzTabButton.classList.add('active');
                surahTabButton.classList.remove('active');
                juzContent.classList.remove('hidden');
                surahContent.classList.add('hidden');
                const firstItem = juzContent.querySelector('.grid-item');
                if (firstItem) setFocus(firstItem);
            });

            // 5. Append everything
            surahSection.appendChild(tabContainer);
            tabsContentContainer.appendChild(surahContent);
            tabsContentContainer.appendChild(juzContent);
            surahSection.appendChild(tabsContentContainer);
            youtubeSuggestionsDiv.appendChild(surahSection);
        }

        function navigateBackToMainSearch() { 
            youtubeVideoListView.classList.add('hidden'); 
            youtubeSearchResultsView.classList.add('hidden'); 
            youtubeSuggestionsDiv.style.display = 'flex'; 
            activeMediaView = 'suggestions'; 
            currentPlayingPlaylistId = ''; 
            backToPlaylistsBottomButton.style.display = 'none'; 
            backToPlaylistsBottomButtonSearch.style.display = 'none'; 
            
            // ÿ•ÿµŸÑÿßÿ≠: ÿ•ÿ≤ÿßŸÑÿ© ŸÇÿ≥ŸÖ ÿßŸÑÿ≥Ÿàÿ± ÿ®ÿ¥ŸÉŸÑ ÿµÿ±Ÿäÿ≠ ÿπŸÜÿØ ÿßŸÑÿπŸàÿØÿ©
            const existingSurahSection = document.getElementById('youtube-surah-section');
            if (existingSurahSection) {
                existingSurahSection.remove();
            }
            
            resetYoutubeSearchUI(); 
            setTimeout(() => { const firstReader = youtubeSuggestionsDiv.querySelector('.grid-item'); if (firstReader) setFocus(firstReader); }, 100); 
        }

        // --- Google Map and Geolocation (REFACTORED FOR RELIABILITY) ---
        let mapsInitialized = false;
        
        function showGeolocationErrorOnMap(message) {
            const overlay = document.getElementById('geolocation-error-overlay');
            const mapControls = document.querySelector('#dashboard-google-map ~ .absolute'); 

            if (overlay) {
                overlay.classList.remove('hidden');
                overlay.classList.add('flex');
                if (message) {
                    const p = overlay.querySelector('p');
                    if (p) p.textContent = message;
                }
                lucide.createIcons();
            }
            if (mapControls) {
                mapControls.style.display = 'none';
            }
        }

        // --- Favorites (Bookmark) Functions ---
        function closeFavoritesMenu() {
            const existingMenu = document.querySelector('.favorites-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
            // Remove the global click listener that was added to close the menu
             document.body.removeEventListener('click', closeFavoritesMenu);
        }

        function showFavoritesMenu(button, video) {
            closeFavoritesMenu(); // Close any existing menu first

            const menu = document.createElement('div');
            menu.className = 'favorites-menu';
            const rect = button.getBoundingClientRect();

            menu.style.top = `${rect.bottom + 5}px`;
            menu.style.left = `${rect.left}px`;
            
            menu.innerHTML = `
                <button data-type="D" class="navigable grid-item" tabindex="0">
                     <i data-lucide="folder-plus" class="w-4 h-4 text-blue-400"></i> CAR LIST
                </button>
                <button data-type="M" class="navigable grid-item" tabindex="0">
                    <i data-lucide="folder-plus" class="w-4 h-4 text-pink-400"></i> TV LIST
                </button>
            `;

            document.body.appendChild(menu);
            menu.classList.add('show');

            menu.addEventListener('click', e => e.stopPropagation());

            menu.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const type = btn.dataset.type;
                    await saveVideoToFavorites(video, type);
                    closeFavoritesMenu();
                });
            });

            lucide.createIcons();
            setFocus(menu.querySelector('button'));

            setTimeout(() => {
                document.body.addEventListener('click', closeFavoritesMenu, { once: true });
            }, 0);
        }

        async function fetchFavorites(type) {
            const binId = type === 'D' ? JSONBIN_BIN_ID_FAV_D : JSONBIN_BIN_ID_FAV_M;
            try {
                const res = await fetch(`https://api.jsonbin.io/v3/b/${binId}/latest`, {
                    headers: { 'X-Access-Key': JSONBIN_ACCESS_KEY_REMINDERS }
                });
                if (res.status === 404) return []; // Bin is new/empty
                if (!res.ok) throw new Error(`HTTP error ${res.status}`);
                const data = await res.json();
                return Array.isArray(data.record) ? data.record : [];
            } catch (error) {
                console.error(`Error fetching favorites ${type}:`, error);
                return [];
            }
        }

        async function updateFavorites(type, newFavoritesList) {
            const binId = type === 'D' ? JSONBIN_BIN_ID_FAV_D : JSONBIN_BIN_ID_FAV_M;
            
            // If the list is empty, send a placeholder object to avoid API errors.
            const dataToSend = (Array.isArray(newFavoritesList) && newFavoritesList.length === 0)
                ? { _init: true } 
                : newFavoritesList;

            try {
                const res = await fetch(`https://api.jsonbin.io/v3/b/${binId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': JSONBIN_API_KEY
                    },
                    body: JSON.stringify(dataToSend)
                });
                if (!res.ok) throw new Error(`Failed to update favorites: ${res.status}`);
                return true;
            } catch (error) {
                console.error(`Error updating favorites ${type}:`, error);
                showMessageBox(`ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ© ${type}`);
                return false;
            }
        }

        async function saveVideoToFavorites(video, type) {
¬† ¬† ¬† ¬† ¬† ¬† const favoritesList = type === 'D' ? favoritesD : favoritesM;
¬† ¬† ¬† ¬† ¬† ¬† if (favoritesList.some(fav => fav.id === video.id)) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showMessageBox(`ÿßŸÑŸÅŸäÿØŸäŸà ŸÖŸàÿ¨ŸàÿØ ÿ®ÿßŸÑŸÅÿπŸÑ ŸÅŸä ÿßŸÑŸÖŸÅÿ∂ŸÑÿ© ${type}`);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† const history = getWatchedHistory();
¬† ¬† ¬† ¬† ¬† ¬† const watchedInfo = history[video.id];
¬† ¬† ¬† ¬† ¬† ¬† const progress = (watchedInfo && watchedInfo.progress > 0) ? watchedInfo.progress : 0;

¬† ¬† ¬† ¬† ¬† ¬† const videoToSave = {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† id: video.id,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† title: video.title,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† thumbnail: video.thumbnail,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† channelTitle: video.channelTitle,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† channelId: video.channelId,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† duration: video.duration,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† progress: progress
¬† ¬† ¬† ¬† ¬† ¬† };

¬† ¬† ¬† ¬† ¬† ¬† // [ÿ™ÿπÿØŸäŸÑ] ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÅŸäÿØŸäŸà ÿßŸÑÿ¨ÿØŸäÿØ ŸÅŸä ÿ®ÿØÿßŸäÿ© ÿßŸÑŸÇÿßÿ¶ŸÖÿ© (ÿßŸÑÿ£ÿ≠ÿØÿ´ ÿ£ŸàŸÑÿßŸã)
¬† ¬† ¬† ¬† ¬† ¬† const updatedList = [videoToSave, ...favoritesList];
¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† const success = await updateFavorites(type, updatedList);

¬† ¬† ¬† ¬† ¬† ¬† if (success) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (type === 'D') favoritesD = updatedList; else favoritesM = updatedList;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showMessageBox(`ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑŸÅŸäÿØŸäŸà ŸÅŸä ÿßŸÑŸÖŸÅÿ∂ŸÑÿ© ${type}`);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // ÿ™ÿ≠ÿØŸäÿ´ ÿ≤ÿ± ÿßŸÑÿ≠ŸÅÿ∏ ŸÅŸä ÿßŸÑŸÉÿßÿ±ÿ™
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const bookmarkBtn = document.querySelector(`.bookmark-button[data-video-id="${video.id}"]`);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if(bookmarkBtn) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† bookmarkBtn.classList.remove('saved-d', 'saved-m', 'saved-both');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (favoritesD.some(fav => fav.id === video.id) && favoritesM.some(fav => fav.id === video.id)) bookmarkBtn.classList.add('saved-both');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† else if (favoritesD.some(fav => fav.id === video.id)) bookmarkBtn.classList.add('saved-d');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† else if (favoritesM.some(fav => fav.id === video.id)) bookmarkBtn.classList.add('saved-m');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // [ÿ•ÿ∂ÿßŸÅÿ©] ÿ™ÿ≠ÿØŸäÿ´ ÿ≤ÿ± ÿßŸÑÿ≠ŸÅÿ∏ ŸÅŸä ŸÜÿßŸÅÿ∞ÿ© ÿßŸÑŸÅŸäÿØŸäŸà ÿßŸÑŸÖŸÜÿ®ÿ´ŸÇÿ© ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ŸÖŸÅÿ™Ÿàÿ≠ÿ©
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const popupBookmarkBtn = document.getElementById('video-popup-bookmark-button');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (popupBookmarkBtn && currentPlayingVideoId === video.id) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†popupBookmarkBtn.classList.remove('saved-d', 'saved-m', 'saved-both');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (favoritesD.some(fav => fav.id === video.id) && favoritesM.some(fav => fav.id === video.id)) popupBookmarkBtn.classList.add('saved-both');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† else if (favoritesD.some(fav => fav.id === video.id)) popupBookmarkBtn.classList.add('saved-d');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† else if (favoritesM.some(fav => fav.id === video.id)) popupBookmarkBtn.classList.add('saved-m');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }

        async function removeVideoFromFavorites(videoId, type) {
            const favoritesList = type === 'D' ? favoritesD : favoritesM;
            const updatedList = favoritesList.filter(fav => fav.id !== videoId);
            const success = await updateFavorites(type, updatedList);
            if (success) {
                if (type === 'D') favoritesD = updatedList; else favoritesM = updatedList;
                showMessageBox(`ÿ™ŸÖÿ™ ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸÅŸäÿØŸäŸà ŸÖŸÜ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ© ${type}`);
                loadSavedVideos(); 
            }
        }

        // Replace the existing loadSavedVideos function
async function loadSavedVideos(type) { // Added 'type' parameter ('D', 'M', or undefined)
    console.log(`[Debug SavedVideos] Starting loadSavedVideos(${type || 'both'})...`);

    const gridD = document.getElementById('favorites-d-grid');
    const gridM = document.getElementById('favorites-m-grid');
    const savedDContent = document.getElementById('tab-content-saved-d');
    const savedMContent = document.getElementById('tab-content-saved-m');

    // Determine which grids/content areas to update
    const updateD = !type || type === 'D';
    const updateM = !type || type === 'M';

    if (updateD && !gridD) console.error("[Debug SavedVideos] favorites-d-grid not found!");
    if (updateM && !gridM) console.error("[Debug SavedVideos] favorites-m-grid not found!");

    // Show loading messages only in the relevant grids
    if (updateD && gridD) gridD.innerHTML = '<p class="text-white/70 text-center col-span-full">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ≥Ÿäÿßÿ±ÿ©...</p>';
    if (updateM && gridM) gridM.innerHTML = '<p class="text-white/70 text-center col-span-full">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ™ŸÑŸÅÿßÿ≤...</p>';

    try {
        let fetchedD = [], fetchedM = [];

        // Fetch only the necessary lists
        if (updateD && updateM) { // Fetch both if no type specified
             const results = await Promise.allSettled([fetchFavorites('D'), fetchFavorites('M')]);
             fetchedD = results[0].status === 'fulfilled' ? results[0].value : [];
             fetchedM = results[1].status === 'fulfilled' ? results[1].value : [];
             favoritesD = fetchedD; // Update global cache
             favoritesM = fetchedM; // Update global cache
        } else if (updateD) { // Fetch only D
             fetchedD = await fetchFavorites('D');
             favoritesD = fetchedD; // Update global cache
        } else if (updateM) { // Fetch only M
             fetchedM = await fetchFavorites('M');
             favoritesM = fetchedM; // Update global cache
        }

        console.log("[Debug SavedVideos] Fetched D:", fetchedD);
        console.log("[Debug SavedVideos] Fetched M:", fetchedM);

        // Render D list if needed
        if (updateD && gridD) {
            gridD.innerHTML = '';
            if (fetchedD.length > 0) {
                 fetchedD.forEach(video => {
                     const cardElement = createFavoriteVideoCard(video, 'D');
                     if (cardElement) gridD.appendChild(cardElement);
                 });
            } else {
                 gridD.innerHTML = '<p class="text-white/70 text-center col-span-full">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÖÿ≠ŸÅŸàÿ∏ÿ© ŸáŸÜÿß.</p>';
            }
        }

        // Render M list if needed
        if (updateM && gridM) {
             gridM.innerHTML = '';
             if (fetchedM.length > 0) {
                 fetchedM.forEach(video => {
                     const cardElement = createFavoriteVideoCard(video, 'M');
                     if (cardElement) gridM.appendChild(cardElement);
                 });
             } else {
                 gridM.innerHTML = '<p class="text-white/70 text-center col-span-full">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÖÿ≠ŸÅŸàÿ∏ÿ© ŸáŸÜÿß.</p>';
             }
        }

        lucide.createIcons();
        updateNavigableElements(); // Ensure focusable elements are updated after rendering
        console.log("[Debug SavedVideos] Finished rendering saved videos.");

    } catch (error) {
        console.error("[Debug SavedVideos] Error in loadSavedVideos:", error);
        if (updateD && gridD) gridD.innerHTML = '<p class="text-red-500 text-center col-span-full">ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©.</p>';
        if (updateM && gridM) gridM.innerHTML = '<p class="text-red-500 text-center col-span-full">ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©.</p>';
    }
}

        function createFavoriteVideoCard(video, type) {
            const card = document.createElement('div');
            card.className = 'glass-surface glass-surface--svg youtube-video-card navigable grid-item';
            card.tabIndex = 0;
            card.dataset.videoId = video.id;

            card.innerHTML = `
                <div class="video-details">
                    <h3 class="video-title">${video.title}</h3>
                    <div class="video-meta">
                        <span>${video.channelTitle || ''}</span>
                    </div>
                </div>
                <div class="thumbnail-container relative">
                     <img src="${video.thumbnail}" alt="${video.title}" class="w-[180px] h-[101.25px] object-cover rounded-md ml-4 flex-shrink-0" onerror="this.onerror=null;this.src='https://placehold.co/180x101';">
                     <span class="video-duration">${video.duration || ''}</span>
                     <button class="remove-favorite-button" title="ÿ•ÿ≤ÿßŸÑÿ© ŸÖŸÜ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©"><i data-lucide="trash-2" class="w-5 h-5"></i></button>
                </div>
            `;
            // Ensure the progress value is treated as a number and passed to the video player
            const startProgress = parseFloat(video.progress || 0);
            card.addEventListener('click', () => showVideoPopup(video.id, startProgress));
            card.querySelector('.remove-favorite-button').addEventListener('click', (e) => {
                e.stopPropagation();
                removeVideoFromFavorites(video.id, type);
            });
            return card;
        }

        // --- Google Map and Geolocation (REFACTORED FOR RELIABILITY) ---
        function loadGoogleMaps() {
            if (googleMapsPromise) return googleMapsPromise;

            googleMapsPromise = new Promise((resolve, reject) => {
                if (typeof google !== 'undefined' && google.maps) {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&libraries=geometry,places`;
                script.async = true;
                script.defer = true;
                script.onload = () => resolve();
                script.onerror = () => reject('Failed to load Google Maps script.');
                document.head.appendChild(script);
            });

            return googleMapsPromise;
        }

        async function initMap() {
             if (mapsInitialized) return;
             mapsInitialized = true;
            try {
                const mapElement = document.getElementById('dashboard-google-map');
                if (!mapElement) {
                    console.error("Map container 'dashboard-google-map' not found.");
                    return;
                }
                dashboardGoogleMap = new google.maps.Map(mapElement, {
                    center: { lat: appState.mapLocation.lat, lng: appState.mapLocation.lon },
                    zoom: appState.mapLocation.zoom,
                    disableDefaultUI: true,
                    mapTypeId: 'satellite',
                });

                dashboardGoogleMarker = new google.maps.Marker({
                    position: { lat: appState.mapLocation.lat, lng: appState.mapLocation.lon },
                    map: dashboardGoogleMap,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 7,
                        fillColor: "#4285F4",
                        fillOpacity: 1,
                        strokeColor: "white",
                        strokeWeight: 2,
                    },
                });

                // Initialize Directions Service and Renderer
                directionsService = new google.maps.DirectionsService();
                directionsRenderer = new google.maps.DirectionsRenderer({
                    map: dashboardGoogleMap,
                    suppressMarkers: true // We use our custom marker
                });

                dashboardGoogleMap.addListener('zoom_changed', () => { if (dashboardGoogleMap.getZoom() !== appState.mapLocation.zoom) appState.mapZoomChangedByUser = true; }); 
                startContinuousLocationTracking();
            } catch (error) {
                console.error("Failed to initialize map due to API load error:", error);
                showGeolocationErrorOnMap("ÿ™ÿπÿ∞ÿ± ÿ™ÿ≠ŸÖŸäŸÑ ÿÆÿ±ÿßÿ¶ÿ∑ ÿ¨Ÿàÿ¨ŸÑ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ™ÿµÿßŸÑŸÉ ÿ®ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™ ŸàŸÖŸÅÿ™ÿßÿ≠ API.");
            }
        }

        // Helper function to calculate distance between two lat/lng points
        function haversineDistance(coords1, coords2) {
            function toRad(x) { return x * Math.PI / 180; }
            const R = 6371; // km
            const dLat = toRad(coords2.lat - coords1.lat);
            const dLon = toRad(coords2.lng - coords1.lng);
            const lat1 = toRad(coords1.lat);
            const lat2 = toRad(coords2.lat);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c * 1000; // in meters
        }
        
        // NEW: Helper function to convert bearing to direction
        function bearingToDirection(bearing) {
            if (typeof bearing !== 'number' || isNaN(bearing)) return '--';
            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            const index = Math.round((bearing % 360) / 45) % 8;
            return directions[index];
        }

        function updateGoogleMapLocation(pos) {
            const { latitude: lat, longitude: lng, heading } = pos.coords;
            appState.currentLocation = { lat, lng };
            const newLatLng = { lat, lng };

            // Logic for speed, gear, and direction based on movement
            if (appState.previousLocation) {
                const distance = haversineDistance(appState.previousLocation, newLatLng);
                if (distance > 2) {
                    appState.car.gear = 'D';
                    appState.car.speed = (Math.random() * 60 + 40).toFixed(0);
                } else {
                    appState.car.gear = 'P';
                    appState.car.speed = 0;
                }
            } else {
                appState.car.gear = 'P';
                appState.car.speed = 0;
            }
            appState.previousLocation = newLatLng;
            appState.car.direction = bearingToDirection(heading); // Update direction
            update3dScreenWidgets(); // Update UI immediately

            if (dashboardGoogleMap && dashboardGoogleMarker) {
                dashboardGoogleMarker.setPosition(newLatLng);
                if (!appState.mapZoomChangedByUser) {
                    dashboardGoogleMap.setCenter(newLatLng);
                    dashboardGoogleMap.setZoom(appState.mapLocation.zoom);
                }
            }
            if (typeof heading === 'number' && !isNaN(heading)) {
                if (dashboardGoogleMap) dashboardGoogleMap.setHeading(heading);
            }
        }
        function startContinuousLocationTracking() {
            if (navigator.geolocation) {
                watchId = navigator.geolocation.watchPosition(
                    (pos) => { 
                        const overlay = document.getElementById('geolocation-error-overlay');
                        if (overlay) overlay.classList.add('hidden');
                        const mapControls = document.querySelector('#dashboard-google-map ~ .absolute');
                        if (mapControls) mapControls.style.display = 'flex';
                        
                        updateGoogleMapLocation(pos); 
                        appState.hasShownGeolocationError = false; 

                        // Fetch weather for the first time with accurate location
                        if (!initialLocationFetched) {
                            fetchWeatherData();
                            initialLocationFetched = true;
                        }
                    }, 
                    (err) => { 
                        if (err.code === 1) { // PERMISSION_DENIED
                            showGeolocationErrorOnMap('ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿ•ÿ∞ŸÜ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ. Ÿäÿ±ÿ¨Ÿâ ÿ™ŸÖŸÉŸäŸÜŸá ŸÅŸä ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠.');
                        } else if (!appState.hasShownGeolocationError) {
                            let msg = 'ÿ™ÿπÿ∞ÿ± ÿ™ÿ™ÿ®ÿπ ŸÖŸàŸÇÿπŸÉ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ÿ∞ŸàŸÜÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ.';
                            showMessageBox(msg); 
                            appState.hasShownGeolocationError = true; 
                        }
                    }, 
                    { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                );
            } else {
                showGeolocationErrorOnMap('ÿÆÿØŸÖÿ© ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàÿßŸÇÿπ ÿ∫Ÿäÿ± ŸÖÿØÿπŸàŸÖÿ© ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑŸÖÿ™ÿµŸÅÿ≠.');
            }
        }
        function centerMapOnUserLocation() { 
            if (navigator.geolocation) { 
                navigator.geolocation.getCurrentPosition(
                    (pos) => { 
                        updateGoogleMapLocation(pos); 
                        showMessageBox(`ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿÆÿ±Ÿäÿ∑ÿ©.`); 
                    }, 
                    () => {
                        showGeolocationErrorOnMap('ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖŸàŸÇÿπŸÉ ÿßŸÑÿ≠ÿßŸÑŸä. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ£ÿ∞ŸàŸÜÿßÿ™.');
                    }, 
                    { enableHighAccuracy: true }
                ); 
            } 
        }
        
        async function calculateAndDisplayRouteTo(destinationCoords) {
            if (!appState.currentLocation) {
                showMessageBox('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ŸÖŸàŸÇÿπŸÉ ÿßŸÑÿ≠ÿßŸÑŸä ÿ®ÿπÿØ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ÿ£Ÿà ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸàŸÇÿπ.');
                return;
            }
            if (!directionsService || !directionsRenderer) {
                showMessageBox('ÿÆÿØŸÖÿ© ÿßŸÑÿ™Ÿàÿ¨ŸäŸáÿßÿ™ ÿ∫Ÿäÿ± ÿ¨ÿßŸáÿ≤ÿ©.');
                return;
            }
            
            const request = {
                origin: appState.currentLocation,
                destination: destinationCoords,
                travelMode: 'DRIVING'
            };

            try {
                const response = await directionsService.route(request);
                if (response.status === 'OK') {
                    directionsRenderer.setDirections(response);
                    const route = response.routes[0].legs[0];
                   
                    showMessageBox(`ÿßŸÑÿ∑ÿ±ŸäŸÇ ÿ•ŸÑŸâ Ÿàÿ¨Ÿáÿ™ŸÉ: ${route.distance.text}, ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖŸÇÿØÿ±: ${route.duration.text}`);
                } else {
                    showMessageBox('ÿ™ÿπÿ∞ÿ± ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßÿ™ÿ¨ÿßŸáÿßÿ™: ' + response.status);
                }
            } catch (err) {
                console.error('Error calculating directions:', err);
                showMessageBox('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿßÿ™ÿ¨ÿßŸáÿßÿ™.');
            }
        }

        // --- Weather API Integration ---
        async function fetchWeatherData() {
            if (WEATHER_API_KEY.startsWith('YOUR_')) return showMessageBox('ÿÆÿ∑ÿ£: ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ŸÖŸÅÿ™ÿßÿ≠ WeatherAPI.');
            try {
                const locationQuery = appState.currentLocation ? `${appState.currentLocation.lat},${appState.currentLocation.lng}` : appState.weather.location.split(',')[0].trim();
                const res = await fetch(`https://api.weatherapi.com/v1/forecast.json?key=${WEATHER_API_KEY}&q=${locationQuery}&days=2&aqi=yes&alerts=no&lang=ar`);
                if (!res.ok) throw new Error(`ÿÆÿ∑ÿ£ HTTP! ÿßŸÑÿ≠ÿßŸÑÿ©: ${res.status}`);
                const data = await res.json();
                
                // Update main state for Salalah
                appState.weather.temperature = data.current.temp_c;
                appState.weather.description = data.current.condition.text;
                appState.weather.uvIndex = data.current.uv;
                appState.weather.iconUrl = `https:${data.current.condition.icon}`;
                appState.weather.location = `${data.location.name}, ${data.location.country}`;

                appState.weather.humidity = data.current.humidity;
                
                // --- NEW: Handle hourly forecast ---
                const hourlyData = [...data.forecast.forecastday[0].hour, ...data.forecast.forecastday[1]?.hour || []];
                const now = new Date();
                const currentHourData = {
                    time: "ÿßŸÑÿ¢ŸÜ",
                    temp_c: data.current.temp_c,
                    condition: { icon: data.current.condition.icon }
                };
                const upcomingHours = hourlyData.filter(h => new Date(h.time_epoch * 1000) > now).slice(0, 6);
                const forecastToRender = [currentHourData, ...upcomingHours];
                renderHourlyForecast(forecastToRender);
                
                // --- NEW: Fetch other locations ---
                renderAdvancedWeatherCards(data);

                updateUI(); // Update other UI elements
            } catch (err) {
                console.error('Error fetching weather data:', err);
            
            }


        }

        function renderHourlyForecast(forecastData) {
            const container = document.getElementById('hourly-forecast-container');
            if (!container) return;
            container.innerHTML = '';
            forecastData.forEach(hour => {
                  const timeLabel = hour.time === "ÿßŸÑÿ¢ŸÜ"
                    ? "ÿßŸÑÿ¢ŸÜ"
                    : new Date(hour.time_epoch * 1000).toLocaleTimeString('ar-SA', { hour: 'numeric', hour12: true });

                const card = document.createElement('div');
                card.className = 'flex flex-col items-center justify-center p-1 rounded-lg';
                card.innerHTML = `
                    <span class="text-base font-medium text-white/80">${timeLabel}</span>
                    <img src="https:${hour.condition.icon}" alt="weather" class="w-8 h-8 my-1">
                    <span class="text-xl font-bold">${Math.round(hour.temp_c)}¬∞</span>
                `;
                container.appendChild(card);
            });
        }

        function renderAdvancedWeatherCards(data) {
            const container = document.getElementById('location-temps-container');
            if (!container) return;
            container.innerHTML = '';
             // Change layout to a flex column to stack the cards vertically
            container.className = 'flex flex-col gap-4 w-full flex-grow';

            // Create a container for the top two cards (Humidity and Best Time)
            const topCardsContainer = document.createElement('div');
            topCardsContainer.className = 'grid grid-cols-2 gap-4 w-full flex-grow';
            container.appendChild(topCardsContainer); // Append this container first

            // Card 1: Humidity
            const humidity = data.current.humidity;
            let humidityColor = 'text-green-400';
            let humidityDesc = 'ŸÖŸÜÿÆŸÅÿ∂ÿ©';
            if (humidity >= 60 && humidity < 75) {
                humidityColor = 'text-yellow-400';
                humidityDesc = 'ŸÖÿπÿ™ÿØŸÑÿ©';
            } else if (humidity >= 75 && humidity < 85) {
                humidityColor = 'text-orange-400';
                humidityDesc = 'ŸÖÿ±ÿ™ŸÅÿπÿ©';
            } else if (humidity >= 85) {
                humidityColor = 'text-red-400';
                humidityDesc = 'ŸÖÿ±ÿ™ŸÅÿπÿ© ÿ¨ÿØÿßŸã';
            }

            const humidityCard = document.createElement('div');
            humidityCard.className = 'glass-surface glass-surface--svg p-4 rounded-3xl flex flex-col items-center justify-center text-center navigable grid-item';
            humidityCard.tabIndex = 0;
            humidityCard.innerHTML = `
                <div class="flex items-center gap-3 mb-2">
                    <i data-lucide="droplets" class="w-8 h-8 ${humidityColor}"></i>
                    <h3 class="text-xl font-bold">ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ±ÿ∑Ÿàÿ®ÿ©</h3>
                </div>
                <div class="text-6xl font-extrabold ${humidityColor}">${humidity}%</div>
                <div class="text-lg text-white/80 mt-2">${humidityDesc}</div>
            `;
            topCardsContainer.appendChild(humidityCard);

            // Card 2: Best Time to Go Out (with 30-min intervals for next 6 hours)
            const hourlyData = [...data.forecast.forecastday[0].hour, ...data.forecast.forecastday[1]?.hour || []];
            const now = new Date();
            const sixHoursFromNowEpoch = (now.getTime() / 1000) + (6 * 3600);

            // Get the next 7 hours to have enough data for interpolation
            const upcomingRawHours = hourlyData.filter(h => new Date(h.time_epoch * 1000) > now).slice(0, 7);
            
            const interpolatedSlots = [];
            // Create slots for every 30 mins over the next 6 hours
            if (upcomingRawHours.length > 1) {
                for (let i = 0; i < upcomingRawHours.length - 1; i++) {
                    const currentHour = upcomingRawHours[i];
                    const nextHour = upcomingRawHours[i+1];

                    // Add the current full hour
                    interpolatedSlots.push(currentHour);

                    // Create the half-hour slot
                    const halfHourSlot = {
                        time_epoch: currentHour.time_epoch + 1800,
                        temp_c: (currentHour.temp_c + nextHour.temp_c) / 2,
                        uv: (currentHour.uv + nextHour.uv) / 2,
                        humidity: (currentHour.humidity + nextHour.humidity) / 2
                    };
                    interpolatedSlots.push(halfHourSlot);
                }
            } else if (upcomingRawHours.length === 1) {
                interpolatedSlots.push(upcomingRawHours[0]);
            }

            // Filter the final list to be strictly within the next 6 hours
            const next6HourSlots = interpolatedSlots.filter(slot => slot.time_epoch <= sixHoursFromNowEpoch);

            let bestHour = null;
            let bestScore = Infinity;

            if (next6HourSlots.length > 0) {
                next6HourSlots.forEach(hour => {
                    // ÿ™ÿ≠ÿØŸäÿ´ ŸÖŸÜÿ∑ŸÇ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÜŸÇÿßÿ∑: ÿßŸÑÿ£ŸàŸÑŸàŸäÿ© ŸÑŸÑÿ±ÿ∑Ÿàÿ®ÿ© ÿßŸÑÿ£ŸÇŸÑÿå ÿ´ŸÖ ÿßŸÑÿ≠ÿ±ÿßÿ±ÿ© ÿßŸÑÿ£ŸÇŸÑÿå ÿ´ŸÖ ÿßŸÑÿ£ÿ¥ÿπÿ© ŸÅŸàŸÇ ÿßŸÑÿ®ŸÜŸÅÿ≥ÿ¨Ÿäÿ© ÿßŸÑÿ£ŸÇŸÑ
                    const score = (hour.humidity * 1000) + (hour.temp_c * 100) + hour.uv;
                    if (score < bestScore) {
                        bestScore = score;
                        bestHour = hour;
                    }
                });
            } else {
                 // Fallback if no data is available
                 bestHour = { time_epoch: Date.now()/1000 + 3600, temp_c: data.current.temp_c, uv: data.current.uv, humidity: data.current.humidity };
            }


            const bestTime = new Date(bestHour.time_epoch * 1000).toLocaleTimeString('ar-OM', { hour: 'numeric', minute: '2-digit', hour12: true });

            const bestTimeCard = document.createElement('div');
            bestTimeCard.className = 'glass-surface glass-surface--svg p-4 rounded-3xl flex flex-col items-center justify-center text-center navigable grid-item';
            bestTimeCard.tabIndex = 0;
            bestTimeCard.innerHTML = `
                <div class="flex items-center gap-3 mb-3">
                     <i data-lucide="walk" class="w-8 h-8 text-green-300"></i>
                    <h3 class="text-xl font-bold">ÿ£ŸÅÿ∂ŸÑ ŸàŸÇÿ™ ŸÑŸÑÿÆÿ±Ÿàÿ¨</h3>
                </div>
                <div class="text-4xl font-extrabold text-green-300 mb-3">${bestTime}</div>
                <div class="grid grid-cols-3 gap-2 text-sm w-full">
                    <div class="bg-black/20 p-2 rounded-lg text-center">
                        <div class="font-bold text-lg ${getTempTextColor(bestHour.temp_c)}">${Math.round(bestHour.temp_c)}¬∞C</div>
                        <div class="text-xs opacity-90">ÿßŸÑÿ≠ÿ±ÿßÿ±ÿ©</div>
                    </div>
                    <div class="bg-black/20 p-2 rounded-lg text-center">
                        <div class="font-bold text-lg ${getUvTextColor(bestHour.uv)}">${Math.round(bestHour.uv)}</div>
                        <div class="text-xs opacity-90">UV</div>
                    </div>
                    <div class="bg-black/20 p-2 rounded-lg text-center">
                        <div class="font-bold text-lg ${getHumidityTextColor(bestHour.humidity)}">${bestHour.humidity}%</div>
                        <div class="text-xs opacity-90">ÿßŸÑÿ±ÿ∑Ÿàÿ®ÿ©</div>
                    </div>
                </div>
            `;
            topCardsContainer.appendChild(bestTimeCard);
            
            // NOW, create and append the horizontal card LAST to the main container
            const currentConditions = data.current;
            const aqi = currentConditions.air_quality ? currentConditions.air_quality['us-epa-index'] : null;

            const nowCard = document.createElement('div');
            nowCard.className = 'glass-surface glass-surface--svg p-4 rounded-3xl w-full flex justify-around items-center text-center navigable grid-item';
            nowCard.tabIndex = 0;
            nowCard.innerHTML = `
                <div class="flex flex-col items-center gap-2">
                    <h4 class="text-sm font-bold text-white/70">ŸÖÿ§ÿ¥ÿ± UV</h4>
                    <div class="text-2xl font-bold px-4 py-1 rounded-lg ${getUvColor(currentConditions.uv)}">
                        ${currentConditions.uv || '--'}
                  </div>
                </div>
                <div class="flex flex-col items-center gap-2">
                    <h4 class="text-sm font-bold text-white/70">ÿßŸÑÿ≠ÿ±ÿßÿ±ÿ© ÿßŸÑÿ¢ŸÜ</h4>
                    <div class="text-2xl font-bold px-4 py-1 rounded-lg ${getTempColor(currentConditions.temp_c)}">
                        ${Math.round(currentConditions.temp_c)}¬∞C
                    </div>
                </div>
                <div class="flex flex-col items-center gap-2">
                    <h4 class="text-sm font-bold text-white/70">ÿ¨ŸàÿØÿ© ÿßŸÑŸáŸàÿßÿ°</h4>
                    <div class="text-2xl font-bold px-4 py-1 rounded-lg ${getAqiColor(aqi)}">
                        ${aqi || '--'}
                    </div>
                </div>
            `;
            container.appendChild(nowCard);

            lucide.createIcons();
        }

        function getUvIndexColor(uv) { if (uv <= 2) return '#4ade80'; if (uv <= 5) return '#facc15'; if (uv <= 7) return '#fb923c'; if (uv <= 10) return '#f87171'; return '#c084fc'; }

        // --- NEW COLORING FUNCTIONS ---
        const getTempColor = (temp) => {
            const tempValue = parseFloat(temp);
            if (tempValue < 25) return 'bg-blue-500 text-white';
            if (tempValue <= 30) return 'bg-green-500 text-white';
            if (tempValue <= 35) return 'bg-yellow-400 text-black';
            return 'bg-red-500 text-white';
        };

        const getHumidityColorBestTime = (humidity) => {
            const humidityValue = parseInt(humidity);
            if (humidityValue < 60) return 'bg-cyan-500/90 text-white';
            if (humidityValue < 75) return 'bg-yellow-400/90 text-black';
            return 'bg-orange-500/90 text-white';
        };

        const getAqiColor = (aqi) => {
            const aqiValue = parseInt(aqi);
            if (aqiValue <= 1) return 'bg-green-500 text-white'; // US EPA Index 1-50 is 1
            if (aqiValue <= 2) return 'bg-yellow-400 text-black'; // 51-100 is 2
            if (aqiValue <= 3) return 'bg-orange-500 text-white'; // 101-150 is 3
            if (aqiValue <= 4) return 'bg-red-500 text-white'; // 151-200 is 4
            if (aqiValue <= 5) return 'bg-purple-500 text-white'; // 201-300 is 5
            return 'bg-red-800 text-white'; // > 300
        };

        const getUvColor = (uv) => {
            const uvValue = Math.round(uv);
            if (uvValue <= 2) return 'bg-green-500 text-white';
            if (uvValue <= 5) return 'bg-yellow-400 text-black';
            if (uvValue <= 7) return 'bg-orange-500 text-white';
            if (uvValue <= 10) return 'bg-red-500 text-white';
            return 'bg-purple-500 text-white';
        };

        // --- NEW TEXT COLORING FUNCTIONS ---
        const getTempTextColor = (temp) => {
            const tempValue = parseFloat(temp);
            if (tempValue < 25) return 'text-blue-400';
            if (tempValue <= 30) return 'text-green-400';
            if (tempValue <= 35) return 'text-yellow-400';
            return 'text-red-400';
        };

        const getHumidityTextColor = (humidity) => {
            const humidityValue = parseInt(humidity);
            if (humidityValue < 60) return 'text-cyan-400';
            if (humidityValue < 75) return 'text-yellow-400';
            return 'text-orange-400';
        };
        
        const getUvTextColor = (uv) => {
            const uvValue = Math.round(uv);
            if (uvValue <= 2) return 'text-green-400';
            if (uvValue <= 5) return 'text-yellow-400';
            if (uvValue <= 7) return 'text-orange-400';
            if (uvValue <= 10) return 'text-red-400';
            return 'text-purple-400';
        };


        // --- Simulated Car Data ---
        function simulateOtherCarData() { 
            appState.car.rpm = (Math.random() * 4200 + 800).toFixed(0); 
            appState.car.fuel = (Math.random() * 100).toFixed(0); 
            appState.car.temp = (Math.random() * 30 + 70).toFixed(1); 
            update3dScreenWidgets(); 
        }

        // --- Prayer Times Integration ---
        const prayerTimes = [

    {"date":"2025-11-01","fajr":"05:08","sunrise":"06:22","dhuhr":"12:12","asr":"15:31","maghrib":"17:58","isha":"19:06"},
    {"date":"2025-11-02","fajr":"05:08","sunrise":"06:22","dhuhr":"12:12","asr":"15:30","maghrib":"17:57","isha":"19:06"},
    {"date":"2025-11-03","fajr":"05:09","sunrise":"06:23","dhuhr":"12:12","asr":"15:30","maghrib":"17:57","isha":"19:06"},
    {"date":"2025-11-04","fajr":"05:09","sunrise":"06:23","dhuhr":"12:12","asr":"15:30","maghrib":"17:57","isha":"19:05"},
    {"date":"2025-11-05","fajr":"05:09","sunrise":"06:23","dhuhr":"12:12","asr":"15:30","maghrib":"17:56","isha":"19:05"},
    {"date":"2025-11-06","fajr":"05:10","sunrise":"06:24","dhuhr":"12:12","asr":"15:30","maghrib":"17:56","isha":"19:05"},
    {"date":"2025-11-07","fajr":"05:10","sunrise":"06:24","dhuhr":"12:12","asr":"15:29","maghrib":"17:55","isha":"19:04"},
    {"date":"2025-11-08","fajr":"05:10","sunrise":"06:25","dhuhr":"12:12","asr":"15:29","maghrib":"17:55","isha":"19:04"},
    {"date":"2025-11-09","fajr":"05:11","sunrise":"06:25","dhuhr":"12:12","asr":"15:29","maghrib":"17:55","isha":"19:04"},
    {"date":"2025-11-10","fajr":"05:11","sunrise":"06:26","dhuhr":"12:13","asr":"15:29","maghrib":"17:55","isha":"19:04"},
    {"date":"2025-11-11","fajr":"05:12","sunrise":"06:26","dhuhr":"12:13","asr":"15:29","maghrib":"17:54","isha":"19:04"},
    {"date":"2025-11-12","fajr":"05:12","sunrise":"06:27","dhuhr":"12:13","asr":"15:29","maghrib":"17:54","isha":"19:04"},
    {"date":"2025-11-13","fajr":"05:12","sunrise":"06:27","dhuhr":"12:13","asr":"15:29","maghrib":"17:54","isha":"19:03"},
    {"date":"2025-11-14","fajr":"05:13","sunrise":"06:28","dhuhr":"12:13","asr":"15:29","maghrib":"17:54","isha":"19:03"},
    {"date":"2025-11-15","fajr":"05:13","sunrise":"06:28","dhuhr":"12:13","asr":"15:29","maghrib":"17:53","isha":"19:03"},
    {"date":"2025-11-16","fajr":"05:13","sunrise":"06:29","dhuhr":"12:13","asr":"15:29","maghrib":"17:53","isha":"19:03"},
    {"date":"2025-11-17","fajr":"05:14","sunrise":"06:29","dhuhr":"12:14","asr":"15:28","maghrib":"17:53","isha":"19:03"},
    {"date":"2025-11-18","fajr":"05:14","sunrise":"06:30","dhuhr":"12:14","asr":"15:28","maghrib":"17:53","isha":"19:03"},
    {"date":"2025-11-19","fajr":"05:15","sunrise":"06:30","dhuhr":"12:14","asr":"15:28","maghrib":"17:53","isha":"19:03"},
    {"date":"2025-11-20","fajr":"05:15","sunrise":"06:31","dhuhr":"12:14","asr":"15:28","maghrib":"17:53","isha":"19:03"},
    {"date":"2025-11-21","fajr":"05:16","sunrise":"06:31","dhuhr":"12:14","asr":"15:29","maghrib":"17:53","isha":"19:03"},
    {"date":"2025-11-22","fajr":"05:16","sunrise":"06:32","dhuhr":"12:15","asr":"15:29","maghrib":"17:53","isha":"19:03"},
    {"date":"2025-11-23","fajr":"05:17","sunrise":"06:32","dhuhr":"12:15","asr":"15:29","maghrib":"17:53","isha":"19:03"},
    {"date":"2025-11-24","fajr":"05:17","sunrise":"06:33","dhuhr":"12:15","asr":"15:29","maghrib":"17:53","isha":"19:04"},
    {"date":"2025-11-25","fajr":"05:17","sunrise":"06:33","dhuhr":"12:16","asr":"15:29","maghrib":"17:53","isha":"19:04"},
    {"date":"2025-11-26","fajr":"05:18","sunrise":"06:34","dhuhr":"12:16","asr":"15:29","maghrib":"17:53","isha":"19:04"},
    {"date":"2025-11-27","fajr":"05:18","sunrise":"06:35","dhuhr":"12:16","asr":"15:29","maghrib":"17:53","isha":"19:04"},
    {"date":"2025-11-28","fajr":"05:19","sunrise":"06:35","dhuhr":"12:17","asr":"15:29","maghrib":"17:53","isha":"19:04"},
    {"date":"2025-11-29","fajr":"05:19","sunrise":"06:36","dhuhr":"12:17","asr":"15:29","maghrib":"17:53","isha":"19:04"},
    {"date":"2025-11-30","fajr":"05:20","sunrise":"06:36","dhuhr":"12:17","asr":"15:30","maghrib":"17:53","isha":"19:05"}
];
/**
 * Converts a 24-hour time string (HH:MM) to a 12-hour time string (H:MM).
 * * @param {string} time24h - Time in 24-hour format (e.g., "15:36").
 * @returns {string} Time in 12-hour format (e.g., "3:36").
 */
function convertTo12Hour(time24h) {
    if (!time24h || typeof time24h !== 'string' || time24h === '--:--') {
        return time24h; // Return as is if invalid or not loaded
    }

    // Split the time string into hours and minutes
    const [hours24, minutes] = time24h.split(':').map(str => parseInt(str, 10));

    // Convert hours from 24h to 12h format
    let hours12 = hours24 % 12;

    // The hour '0' (midnight) should be '12' in 12-hour format
    hours12 = hours12 ? hours12 : 12;

    // Return the formatted string (we don't pad the hour, but keep minutes padded)
    return `${hours12}:${minutes.toString().padStart(2, '0')}`;
}


        function loadPrayerTimes() {
            const today = new Date().toISOString().split('T')[0];
            const data = prayerTimes.find(p => p.date === today);
            if (data) {
                appState.prayerTimes = { ...appState.prayerTimes, Fajr: data.fajr, Dhuhr: data.dhuhr, Asr: data.asr, Maghrib: data.maghrib, Isha: data.isha };
                prayerTimesContainer.innerHTML = '';
               const prayerOrder = ['Fajr', 'Dhuhr', 'Asr', 'Maghrib', 'Isha'];
                const prayerNames = { Fajr: 'ÿßŸÑŸÅÿ¨ÿ±', Dhuhr: 'ÿßŸÑÿ∏Ÿáÿ±', Asr: 'ÿßŸÑÿπÿµÿ±', Maghrib: 'ÿßŸÑŸÖÿ∫ÿ±ÿ®', Isha: 'ÿßŸÑÿπÿ¥ÿßÿ°' };
                const iqamaOffsets = { Fajr: 25, Dhuhr: 20, Asr: 20, Maghrib: 5, Isha: 20 };
                
                prayerOrder.forEach(key => {
                    const item = document.createElement('div');
                    item.className = 'prayer-time-item navigable grid-item';
                    item.tabIndex = 0;
                    
                    // 1. Get the 24-hour time
                    const time24h = data[key.toLowerCase()]; 
                    
                    // 2. Convert to 12-hour time (e.g., 3:30 ŸÖ)
                    const time12hDisplay = convertTo12HourWithAmPm(time24h); // ‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿØÿßŸÑÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©
                    
                    // 3. Calculate Iqama time (24h format string)
                    const iqamaTime24h = addMinutes(time24h, iqamaOffsets[key]); 
                    
                    // 4. Convert Iqama time for display (e.g., 3:50 ŸÖ)
                    const iqamaTime12hDisplay = convertTo12HourWithAmPm(iqamaTime24h); // ‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿØÿßŸÑÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©
                    
                    // 5. Update the inner HTML using the 12h format
                    item.innerHTML = `<span class="prayer-name">${prayerNames[key]}</span><span class="prayer-time">${time12hDisplay}</span><span class="prayer-iqama text-xs text-white/50">ÿßŸÑÿ•ŸÇÿßŸÖÿ©: ${iqamaTime12hDisplay}</span>`;
                    
                    prayerTimesContainer.appendChild(item);
                });

                // Create a container for the action buttons
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex gap-2 mt-2 homebtn';

                // Ruqyah Button
                const ruqyahButton = document.createElement('button');
                ruqyahButton.id = 'ruqyah-tv-button';
                ruqyahButton.className = 'navigable grid-item w-1/2 bg-teal-500/50 hover:bg-teal-400/50 text-white font-bold p-2 rounded-lg shadow-lg text-lg transition-all duration-300 ease-in-out flex items-center justify-center gap-2';
                ruqyahButton.innerHTML = `<i data-lucide="shield-check" class="w-6 h-6"></i><span>ÿßŸÑÿ±ŸÇŸäÿ© ÿßŸÑÿ¥ÿ±ÿπŸäÿ©</span>`;
                ruqyahButton.tabIndex = 0;
                ruqyahButton.addEventListener('click', () => {
                setTimeout(() => searchYouTubeVideos('ÿßŸÑÿ±ŸÇŸäÿ© ÿßŸÑÿ¥ÿ±ÿπŸäÿ© ÿßŸÑŸÜŸÅŸäÿ≥'), 100);
                switchApp('Media');
                });
                
                // Adhkar Button
                const adhkarButton = document.createElement('button');
                adhkarButton.id = 'adhkar-tv-button';
                adhkarButton.className = 'navigable grid-item w-1/2 bg-sky-500/50 hover:bg-sky-400/50 text-white font-bold p-2 rounded-lg shadow-lg text-lg transition-all duration-300 ease-in-out flex items-center justify-center gap-2';
                adhkarButton.innerHTML = `<i data-lucide="sunrise" class="w-6 h-6"></i><span>ÿßŸÑÿ£ÿ∞ŸÉÿßÿ±</span>`;
                adhkarButton.tabIndex = 0;
                adhkarButton.addEventListener('click', () => {
                    setTimeout(() => searchYouTubeVideos('ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑÿµÿ®ÿßÿ≠ ŸàÿßŸÑŸÖÿ≥ÿßÿ°'), 100);
                     switchApp('Media');
                });
                
                // Add buttons to their container, then add the container to the main prayer times area
                buttonContainer.appendChild(ruqyahButton);
                buttonContainer.appendChild(adhkarButton);
                prayerTimesContainer.appendChild(buttonContainer);

                lucide.createIcons();
                determineNextPrayer();
                updateDigitalClock();
            } else {
                prayerTimesContainer.innerHTML = `<p class="text-white/70 col-span-full">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ŸàŸÇÿßÿ™ ÿµŸÑÿßÿ© ŸÑŸáÿ∞ÿß ÿßŸÑŸäŸàŸÖ.</p>`;
            }
        }
        function addMinutes(time, min) { const [h, m] = time.split(':').map(Number); const d = new Date(); d.setHours(h, m + min, 0, 0); return d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false }); }
// -------------------------------------------------------------
// --- CORRECTED timeToDate function (Crucial for 24H -> Date conversion) ---
// -------------------------------------------------------------
// -------------------------------------------------------------
// --- CORRECTED timeToDate function (Uses CURRENT System Date) ---
// -------------------------------------------------------------
function timeToDate(time) {
    // 1. ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿ≥ÿßÿπÿßÿ™ ŸàÿßŸÑÿØŸÇÿßÿ¶ŸÇ (24-hour format)
    const [h, m] = time.split(':').map(Number);
    
    // 2. ÿ•ŸÜÿ¥ÿßÿ° ŸÉÿßÿ¶ŸÜ Date ÿ¨ÿØŸäÿØ ŸÖŸÜ ÿßŸÑŸàŸÇÿ™ ŸàÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ≠ÿßŸÑŸäŸäŸÜ ŸÑŸÑŸÜÿ∏ÿßŸÖ
    const d = new Date();
    
    // 3. ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ≥ÿßÿπÿßÿ™ ŸàÿßŸÑÿØŸÇÿßÿ¶ŸÇ
    // Ÿáÿ∞ÿß Ÿäÿ∂ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸáŸà ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸÅÿπŸÑŸä ŸÑŸÑŸÜÿ∏ÿßŸÖÿå ŸÑŸÉŸÜ ÿßŸÑÿ™ŸàŸÇŸäÿ™ ŸáŸà ÿ™ŸàŸÇŸäÿ™ ÿßŸÑÿµŸÑÿßÿ© (ŸÖÿ´ŸÑ 15:30)
    d.setHours(h, m, 0, 0); 
    
    return d;
}

// -------------------------------------------------------------
// --- MODIFIED determineNextPrayer function (FINAL Time Context FIX) ---
// -------------------------------------------------------------
function determineNextPrayer() {
    // ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä ÿßŸÑŸÅÿπŸÑŸä
    const now = new Date();
    const todayTimings = appState.prayerTimes;
    if (!todayTimings.Fajr || todayTimings.Fajr === '--:--') return;

    // 1. Define constants
    const PRAYER_OFFSETS = { Fajr: 25, Dhuhr: 20, Asr: 20, Maghrib: 5, Isha: 15 }; // ÿ™ŸÖ ÿ™ÿπÿØŸäŸÑ Isha graceEnd ÿ•ŸÑŸâ 15 (ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä)
    const PRAYER_GRACE = { Fajr: 5, Dhuhr: 15, Asr: 20, Maghrib: 20, Isha: 15 };
    const PRAYER_NAMES = { Fajr: 'ÿßŸÑŸÅÿ¨ÿ±', Dhuhr: 'ÿßŸÑÿ∏Ÿáÿ±', Asr: 'ÿßŸÑÿπÿµÿ±', Maghrib: 'ÿßŸÑŸÖÿ∫ÿ±ÿ®', Isha: 'ÿßŸÑÿπÿ¥ÿßÿ°' };
    const ORDER = ['Fajr', 'Dhuhr', 'Asr', 'Maghrib', 'Isha'];

    let prayerEvents = [];
    
    // 2. Populate Events for TODAY
    ORDER.forEach(key => {
        // pTime Ÿäÿ≠ŸÖŸÑ ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸäŸàŸÖ ÿßŸÑŸÅÿπŸÑŸä Ÿàÿ™ŸàŸÇŸäÿ™ ÿßŸÑÿµŸÑÿßÿ©
        const pTime = timeToDate(todayTimings[key]);
        const iqamaTime = new Date(pTime.getTime() + PRAYER_OFFSETS[key] * 60000);
        const graceEnd = new Date(iqamaTime.getTime() + PRAYER_GRACE[key] * 60000);

        prayerEvents.push({ 
            name: PRAYER_NAMES[key], 
            azan: pTime, 
            iqama: iqamaTime, 
            graceEnd: graceEnd 
        });
    });

    // 3. Prepare Tomorrow's Fajr (Set to tomorrow's date based on current system time)
    const fajrTomorrow = timeToDate(todayTimings.Fajr);
    fajrTomorrow.setDate(fajrTomorrow.getDate() + 1); // ÿßŸÑÿ™ŸÇÿØŸÖ ŸÑŸäŸàŸÖ Ÿàÿßÿ≠ÿØ
    
    prayerEvents.push({
        name: 'ÿßŸÑŸÅÿ¨ÿ± (ÿ∫ÿØŸãÿß)', azan: fajrTomorrow,
        iqama: new Date(fajrTomorrow.getTime() + PRAYER_OFFSETS.Fajr * 60000),
        graceEnd: new Date(fajrTomorrow.getTime() + PRAYER_OFFSETS.Fajr * 60000 + PRAYER_GRACE.Fajr * 60000)
    });


    // 4. Find CURRENT and NEXT States
    appState.prayerTimes.currentPrayer = null;
    appState.prayerTimes.currentPrayerIqamaTime = null;
    let nextEvent = null;
    let currentEvent = null;
    
    // Find CURRENT (Iterate backwards to find the latest active prayer)
    for (let i = prayerEvents.length - 1; i >= 0; i--) {
        const event = prayerEvents[i];
        if (now >= event.azan && now < event.graceEnd) {
             currentEvent = event;
             break;
        }
    }

    // Find NEXT (First event whose Azan time is in the future)
    nextEvent = prayerEvents.find(event => event.azan > now);

    
    // 5. Set Final Application State
    
    if (currentEvent) {
        appState.prayerTimes.currentPrayer = currentEvent.name.replace(' (ÿ∫ÿØŸãÿß)', '');
        appState.prayerTimes.currentPrayerIqamaTime = currentEvent.iqama;

        if (now < currentEvent.iqama) {
            // Case 1: Counting down TO Iqama 
            appState.prayerTimes.nextPrayer = appState.prayerTimes.currentPrayer;
            appState.prayerTimes.nextPrayerIqamaTime = currentEvent.iqama;
        } else if (nextEvent) {
            // Case 2: Iqama passed, waiting for the NEXT AZAN
            appState.prayerTimes.nextPrayer = nextEvent.name;
            appState.prayerTimes.nextPrayerIqamaTime = nextEvent.azan;
        }
    } else if (nextEvent) {
        // Case 3: Outside any prayer window, waiting for the NEXT AZAN (Should be Asr/Maghrib)
        appState.prayerTimes.nextPrayer = nextEvent.name;
        appState.prayerTimes.nextPrayerIqamaTime = nextEvent.azan;
    } else {
        // Fallback: This means we are past tomorrow's Fajr (Shouldn't happen with the list logic)
        appState.prayerTimes.nextPrayer = "ÿßŸÑŸÅÿ¨ÿ± (ÿ∫ÿØŸãÿß)";
        appState.prayerTimes.nextPrayerIqamaTime = fajrTomorrow;
    }
    
    // 6. Render Updates
    renderPrayerTimesHighlights();
}
       function renderPrayerTimesHighlights() { if (!prayerTimesContainer) return; document.querySelectorAll('.prayer-time-item').forEach(i => i.classList.remove('current-prayer', 'next-prayer')); if (appState.prayerTimes.currentPrayer) { const item = Array.from(prayerTimesContainer.querySelectorAll('.prayer-name')).find(s => s.textContent === appState.prayerTimes.currentPrayer)?.parentElement; if (item) item.classList.add('current-prayer'); } if (appState.prayerTimes.nextPrayer && appState.prayerTimes.nextPrayer !== appState.prayerTimes.currentPrayer) { const nextPrayerName = appState.prayerTimes.nextPrayer.replace(' (ÿ∫ÿØŸãÿß)', ''); const item = Array.from(prayerTimesContainer.querySelectorAll('.prayer-name')).find(s => s.textContent === nextPrayerName)?.parentElement; if (item && !item.classList.contains('current-prayer')) item.classList.add('next-prayer'); } }
        
        // --- Digital Clock ---
        // --- Digital Clock ---
function updateDigitalClock() {
    const now = new Date();
    
    // --- 1. Get Hours and Minutes ---
    const h24 = now.getHours(); // üõë ŸÜÿ≥ÿ™ÿÆÿØŸÖ h24 (0-23) ŸÑŸÑŸÖŸÜÿ∑ŸÇ ÿßŸÑÿ≤ŸÖŸÜŸä
    let h12 = h24;              // h12 ŸÑŸÑÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÖÿ±ÿ¶Ÿä
    const m = now.getMinutes();
    const s = now.getSeconds();
    
    // Convert to 12-hour format for display
    h12 = h12 % 12;
    h12 = h12 ? h12 : 12; // The hour '0' should be '12'

    // --- 2. Update the Digital Display ---
    digitalHoursSpan.textContent = h12; 
    digitalMinutesSpan.textContent = m.toString().padStart(2, '0');
    
    if (digitalSecondsSpan) {
        // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿπŸÜÿµÿ± ŸÖŸàÿ¨ŸàÿØÿßŸãÿå ÿßÿπÿ±ÿ∂ ÿßŸÑÿ´ŸàÿßŸÜŸä (ŸÜÿ∏ÿßŸÖ 24 ÿ≥ÿßÿπÿ©)
        digitalSecondsSpan.textContent = s.toString().padStart(2, '0');
    }
    
    // --- 3. Update the TIME ICON based on the 24H time (h24) ---
    const iconContainer = document.getElementById('time-icon-container');
    if (iconContainer) {
        let iconSrc = '';
        
        // ÿßŸÑŸÖŸÜÿ∑ŸÇ ÿßŸÑÿ≤ŸÖŸÜŸä ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 24
        
        // 1. ÿßŸÑŸÜŸáÿßÿ± ÿßŸÑŸÖÿ¥ŸÖÿ≥ (8:30 AM - 4:59 PM)
        if ((h24 > 8 || (h24 === 8 && m >= 30)) && (h24 < 17)) { 
            iconSrc = 'https://cdn.weatherapi.com/weather/64x64/day/113.png'; // Sun Icon
        } 
        
        // 2. ÿßŸÑÿ∫ÿ±Ÿàÿ® (6:00 PM - 7:00 PM) (18:00 - 19:00)
        else if ((h24 >= 18 && h24 < 19)) { 
            iconSrc = 'https://cdn.weatherapi.com/weather/64x64/day/1087.png'; // Sunset Icon (Dusk)
        } 
        
        // 3. ÿßŸÑŸÑŸäŸÑ (7:01 PM - 6:00 AM) (19:01 - 06:00)
        else if (h24 >= 19 || h24 < 6 || (h24 === 6 && m === 0)) {
            iconSrc = 'https://cdn.weatherapi.com/weather/64x64/night/113.png'; // Moon Icon
        } 
        
        // 4. ÿßŸÑÿ¥ÿ±ŸàŸÇ (6:00 AM - 6:30 AM) (06:00 - 06:30)
        else if (h24 === 6 && m > 0 && m <= 30) { 
            iconSrc = 'https://cdn.weatherapi.com/weather/64x64/day/1087.png'; // Sunrise Icon (Dusk)
        } 
        
        // 5. ÿßŸÑÿ∫ŸäŸàŸÖ ÿßŸÑÿµÿ®ÿßÿ≠Ÿäÿ© ŸàÿßŸÑŸÖÿ≥ÿßÿ¶Ÿäÿ© (Morning Cloudy: 6:30 AM - 8:30 AM)
        // (Pre-sunset Cloudy: 5:00 PM - 6:00 PM) (17:00 - 18:00)
        else if ((h24 === 6 && m > 30) || (h24 === 7) || (h24 === 8 && m <= 30) || (h24 >= 17 && h24 < 18)) { 
            iconSrc = 'https://cdn.weatherapi.com/weather/64x64/day/116.png'; // Cloudy/Overcast Icon
        }
        
        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿπŸÜÿµÿ± ŸÅŸä DOM
        if (iconSrc) {
            iconContainer.innerHTML = `<img src="${iconSrc}" alt="Time Icon" class="w-8 h-8 inline-block ml-2" style="transform: translateY(4px);">`;
        } else {
            iconContainer.innerHTML = '';
        }
    }
    
    // --- 4. Prayer Time Logic ---
    // ... (ÿ®ŸÇŸäÿ© ŸÉŸàÿØ ÿßŸÑÿµŸÑÿßÿ©) ...
}

        // --- 360 Camera ---
        function handleImageUpload(e) { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (ev) => { appState.custom360Image = ev.target.result; localStorage.setItem('custom360Image', ev.target.result); updateUI(); }; reader.readAsDataURL(file); } }
        function resetImageToDefault() { appState.custom360Image = null; localStorage.removeItem('custom360Image'); updateUI(); }

        // --- NEW: 3D Screen Widgets Update ---
        function update3dScreenWidgets() {
            const nextPrayerEl = document.getElementById('3d-screen-next-prayer');
            const speedEl = document.getElementById('3d-screen-speed');
            const gearEl = document.getElementById('3d-screen-gear');
            const dirEl = document.getElementById('3d-screen-dir');

            if (nextPrayerEl) nextPrayerEl.textContent = appState.prayerTimes.nextPrayer || '--';
            if (speedEl) speedEl.textContent = `${appState.car.speed} km/h`;
            if (gearEl) gearEl.textContent = appState.car.gear;
            if (dirEl) dirEl.textContent = appState.car.direction;
        }

        // --- Draggable/Resizable Popup Logic ---
        let isDragging = false;
        let offsetX, offsetY;
        videoPopupContainer.addEventListener('mousedown', (e) => {
            if (e.target === videoPopupContainer || e.target.closest('.video-popup-controls')) {
                isDragging = true;
                offsetX = e.clientX - videoPopupContainer.offsetLeft;
                offsetY = e.clientY - videoPopupContainer.offsetTop;
                videoPopupContainer.style.cursor = 'grabbing';
                videoPopupPlayerContainer.style.pointerEvents = 'none';
            }
        });
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                videoPopupContainer.style.left = `${e.clientX - offsetX}px`;
                videoPopupContainer.style.top = `${e.clientY - offsetY}px`;
                videoPopupContainer.style.bottom = 'auto';
                videoPopupContainer.style.right = 'auto';
            }
        });
        document.addEventListener('mouseup', () => {
            isDragging = false;
            videoPopupContainer.style.cursor = 'grab';
            videoPopupPlayerContainer.style.pointerEvents = 'auto';
        });

        // --- Swipe Gesture Handling (NEW) ---
    

        // --- TV Remote / Keyboard Navigation ---
        let currentFocus = null;
        let navigableElements = []; // Global array for focusable items

        function updateNavigableElements() {
            // This function rebuilds the list of all currently visible, focusable elements.
            // It's called after the UI changes, like loading new search results or switching tabs.
            navigableElements = Array.from(
                document.querySelectorAll('.app-screen.active .navigable, nav .navigable, .video-popup-controls.grid-container .navigable, #bottom-left-controls .navigable, #floating-minimized-video-button.navigable')
            ).filter(el => el.offsetParent !== null && !el.closest('.hidden'));
        }

        function setFocus(el) { if (currentFocus) currentFocus.classList.remove('tv-focus'); if (el) { el.classList.add('tv-focus'); el.focus({ preventScroll: true }); currentFocus = el; el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' }); } else { if (currentFocus) currentFocus.classList.remove('tv-focus'); currentFocus = null; } }
        
        // --- MASTER KEY HANDLER (REFACTORED) ---
        function handleRemoteControlInput(e) {
            const key = e.key.toLowerCase();
            const activeEl = document.activeElement;

          

       

            // --- Priority 1: Video Player is Active ---
            if (videoPopupContainer.classList.contains('active') || appState.isVideoPlayerMinimized) {
                const customHandledKeys = [
                    'arrowup', 'arrowdown', 'arrowleft', 'arrowright',
                    'enter', 'ok', 'p',
                    'b', 'stop', 'red', 'colorf0red', 'x',
                    'yellow', 'colorf2yellow', '8',
                    '9' // Added for fullscreen
                ];

                if (customHandledKeys.includes(key)) {
                    e.preventDefault();

                    if (key === 'yellow' || key === 'colorf2yellow' || key === '8') {
                        if (appState.isVideoPlayerMinimized) restoreVideoPopup();
                        else minimizeVideoPopup();
                        return;
                    }
                    if (key === 'b' || key === 'stop' || key === 'red' || key === 'colorf0red' || key === 'x') {
                        hideVideoPopup();
                        return;
                    }
                    if (key === 'enter' || key === 'ok' || key === 'p') {
                        const playerState = popupPlayer.getPlayerState();
                        if (playerState === YT.PlayerState.PLAYING) popupPlayer.pauseVideo();
                        else popupPlayer.playVideo();
                        return;
                    }
                    if (key === '9') {
                        toggleFullScreen();
                        return;
                    }
                    
                    const currentTime = popupPlayer.getCurrentTime();
                    const currentVolume = popupPlayer.getVolume();
                    
                }
                // For other keys (like 'f', 'm', spacebar), do nothing and let the event bubble up.
                return;
            }

            // --- Priority 2: Typing in Search Bar ---
            const isTyping = !youtubeSearchInput.readOnly && activeEl === youtubeSearchInput;
            if (isTyping) {
                if (key === 'enter' || key === 'ok') {
                    e.preventDefault();
                    youtubeSearchButton.click();
                } else if (key.length === 1 && (key.match(/[a-z0-9\s]/i) || key.match(/[\u0600-\u06FF]/))) {
                    // Allow default typing
                } else if (key === 'backspace') {
                    // Allow default backspace
                } else {
                    handleNavigation(e);
                }
                return;
            }

            // --- Priority 3: Standard Arrow/OK Navigation ---
            handleNavigation(e);
        }

        function handleNavigation(e) {
            const key = e.key.toLowerCase();
            if (!['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'enter', 'ok'].includes(key)) return;
            
            e.preventDefault(); // Prevent default scroll for navigation keys

            const activeEl = document.activeElement;
            if (!activeEl || activeEl === document.body) {
                const firstIcon = document.querySelector('nav .app-icon');
                if (firstIcon) setFocus(firstIcon);
                return;
            }

            const inNav = activeEl.closest('nav');
            const inMediaScreen = activeEl.closest('#screen-Media');

            if (inNav) {
                handleNavSidebarNavigation(e, activeEl);
            } else if (inMediaScreen) {
                handleMediaScreenNavigation(e, activeEl);
            } else {
                const container = activeEl.closest('.grid-container');
                if (container) {
                    handleGenericGridNavigation(e, activeEl, container);
                }
            }
        }

        function handleNavSidebarNavigation(e, activeEl) {
            const icons = Array.from(document.querySelectorAll('nav .app-icon'));
            const idx = icons.indexOf(activeEl);
            let nextIdx = -1;
            switch (e.key.toLowerCase()) {
                case 'arrowup':
                    nextIdx = idx > 0 ? idx - 1 : icons.length - 1;
                    break;
                case 'arrowdown':
                    nextIdx = idx < icons.length - 1 ? idx + 1 : 0;
                    break;
                case 'arrowright': // In RTL, right arrow should go to main content
                    const screen = document.querySelector('.app-screen.active');
                    if (screen) {
                        const firstItem = screen.querySelector('.grid-item');
                        if (firstItem) setFocus(firstItem);
                    }
                    return;
                case 'enter': case 'ok':
                    activeEl.click();
                    return;
            }
            if (nextIdx !== -1) setFocus(icons[nextIdx]);
        }
        
        function handleMediaScreenNavigation(e, activeEl) {
            const searchRow = document.querySelector('#screen-Media .flex.flex-row.items-center.gap-2.grid-container');
            const readersContainer = document.querySelector('.reader-container');
            const surahContainer = document.querySelector('#youtube-surah-section');
            const videoListContainer = document.querySelector('#video-list-container');
            const searchResultsContainer = document.querySelector('#search-results-container');
            const inSearchRow = activeEl.closest('.flex.flex-row.items-center.gap-2.grid-container');
            const inReaders = activeEl.closest('.reader-container');

            if (e.key.toLowerCase() === 'arrowdown') {
                if (inSearchRow) {
                    const nextVisibleContainer = [readersContainer, surahContainer, videoListContainer, searchResultsContainer].find(c => c && c.offsetParent !== null);
                    if (nextVisibleContainer) {
                        const firstItem = nextVisibleContainer.querySelector('.grid-item');
                        if (firstItem) { setFocus(firstItem); return; }
                    }
                }
                if (inReaders) {
                    if (surahContainer && surahContainer.offsetParent !== null) {
                        const firstItem = surahContainer.querySelector('.grid-item');
                        if (firstItem) { setFocus(firstItem); return; }
                    }
                }
            }

            if (e.key.toLowerCase() === 'arrowup') {
                const currentContainer = activeEl.closest('.grid-container, .reader-container');
                if (currentContainer && currentContainer !== searchRow) {
                    const items = Array.from(currentContainer.querySelectorAll('.grid-item:not([style*="display: none"])')).filter(el => el.offsetParent !== null);
                    const idx = items.indexOf(activeEl);
                    if (idx !== -1) {
                        const firstItemTop = items[0].getBoundingClientRect().top;
                        let cols = items.filter(item => Math.abs(item.getBoundingClientRect().top - firstItemTop) < 20).length;
                        if (cols === 0) cols = 1;
                        if (idx < cols) { setFocus(youtubeSearchInput); return; }
                    }
                }
            }
            if (inReaders) {
                const items = Array.from(readersContainer.querySelectorAll('.grid-item'));
                const idx = items.indexOf(activeEl);
                if (e.key.toLowerCase() === 'arrowleft') { if (idx > 0) setFocus(items[idx - 1]); } 
                else if (e.key.toLowerCase() === 'arrowright') { if (idx < items.length - 1) setFocus(items[idx + 1]); } 
                else if (e.key.toLowerCase() === 'enter' || e.key.toLowerCase() === 'ok') { activeEl.click(); } 
                else if (e.key.toLowerCase() === 'arrowleft' && idx === 0) { const navIcon = document.querySelector('nav .app-icon.active'); if (navIcon) setFocus(navIcon); }
                return;
            }
            const container = activeEl.closest('.grid-container');
            if (container) { handleGenericGridNavigation(e, activeEl, container); }
        }

        function handleGenericGridNavigation(e, activeEl, container) {
            const items = Array.from(container.querySelectorAll('.grid-item:not([style*="display: none"])')).filter(el => el.offsetParent !== null);
            if (items.length === 0) return;
            const idx = items.indexOf(activeEl);
            if (idx === -1) return;
            const firstItemTop = items[0].getBoundingClientRect().top;
            let cols = items.filter(item => Math.abs(item.getBoundingClientRect().top - firstItemTop) < 20).length;
            if (cols === 0) cols = 1;
            const isTopRow = idx < cols;
            let nextIdx = -1;
            switch (e.key.toLowerCase()) {
                case 'arrowup': if (!isTopRow) { nextIdx = idx - cols; } break;
                case 'arrowdown': nextIdx = idx + cols; break;
                case 'arrowright': if (idx % cols !== 0) { nextIdx = idx - 1; } break;
                case 'arrowleft':
                    if ((idx + 1) % cols === 0 || idx === items.length - 1) {
                        const navIcon = document.querySelector('nav .app-icon.active');
                        if (navIcon) setFocus(navIcon);
                        return;
                    } else { nextIdx = idx + 1; }
                    break;
                case 'enter': case 'ok': activeEl.click(); return;
            }
            if (nextIdx >= 0 && nextIdx < items.length) { setFocus(items[nextIdx]); }
        }
        
        // --- Welcome Voice Message ---
        function playWelcomeMessage() {
            const today = new Date();
            today.setFullYear(2025);
            const gregorianDate = new Intl.DateTimeFormat('en-UK', {  year: 'numeric', month: 'long', day: 'numeric' }).format(today);
            const hijriDate = new Intl.DateTimeFormat('ar-SA-u-ca-islamic', { weekday: 'long'}).format(today);

            let welcomeText = '';
            let weatherText = '';

            const speak = (textToSpeak) => {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(textToSpeak);
                    const voices = window.speechSynthesis.getVoices();
                    // Try to find a male Arabic voice, fallback to any Arabic voice
                    let arabicVoice = voices.find(voice => voice.lang.startsWith('ar') && voice.name.includes('Male'));
                    if (!arabicVoice) {
                        arabicVoice = voices.find(voice => voice.lang.startsWith('ar'));
                    }
                    if (arabicVoice) {
                        utterance.voice = arabicVoice;
                    }
                    utterance.lang = 'ar-SA';
                    utterance.rate = 0.9;
                    window.speechSynthesis.speak(utterance);
                } else {
                    console.log('Text-to-speech not supported in this browser.');
                }
            };

            const speakWithVoicesReady = (text) => {
                 if (window.speechSynthesis.getVoices().length === 0) {
                    window.speechSynthesis.onvoiceschanged = () => {
                        speak(text);
                    };
                } else {
                    speak(text);
                }
            }
// 1. ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ "ÿßŸÑÿ≠ÿßÿ±ÿ≥ ÿßŸÑÿπÿßŸÑŸÖŸä" ÿ£ŸàŸÑÿßŸã
if (!window.hasInitializedWeatherSpeaker) {

    // 2. ÿ•ÿ∞ÿß ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ŸÖŸÜ ŸÇÿ®ŸÑÿå ŸÇŸÖ ÿ®ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ≠ÿßÿ±ÿ≥ ŸÅŸàÿ±ÿßŸã
    window.hasInitializedWeatherSpeaker = true;
    
    // 3. ÿßŸÑÿ¢ŸÜÿå ÿ∂ÿπ ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ£ÿµŸÑŸä ÿ®ÿßŸÑŸÉÿßŸÖŸÑ ŸáŸÜÿß
    let hasSpokenWelcome = false; // Ÿáÿ∞ÿß ÿßŸÑÿπŸÑŸÖ ÿ≥ŸäÿπŸÖŸÑ ÿßŸÑÿ¢ŸÜ ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠

    const checkWeatherAndSpeak = () => {
        // ŸÜÿ∑ŸÇ ÿßŸÑÿ™ÿ±ÿ≠Ÿäÿ® ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ© ŸÅŸÇÿ∑
        if (!hasSpokenWelcome) {
            const welcomeText = `ŸÖÿ±ÿ≠ÿ®ÿßÿå ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸäŸàŸÖ ${hijriDate} ÿßŸÑŸÖŸàÿßŸÅŸÇ ${gregorianDate}`;
            speakWithVoicesReady(welcomeText);
            hasSpokenWelcome = true;
        }

        // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ∑ŸÇÿ≥ ÿ¨ÿßŸáÿ≤ÿ©ÿå ŸÜÿ∑ŸÇŸáÿß ÿ®ÿπÿØ ÿ™ÿ£ÿÆŸäÿ±
        if (appState.weather.temperature !== null) {
            setTimeout(() => {
                const weatherText = `ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÇÿ≥ ÿßŸÑÿ¢ŸÜ ${appState.weather.temperature} ÿØÿ±ÿ¨ÿ© ŸÖÿ¶ŸàŸäÿ©`;
                speakWithVoicesReady(weatherText);
            }, 7000);
        } else {
            // ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ŸÉŸÜ ÿ¨ÿßŸáÿ≤ÿ©ÿå ŸÉÿ±ÿ± ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑÿßÿ≠ŸÇŸãÿß
            setTimeout(checkWeatherAndSpeak, 500);
        }
    };

    // 4. ÿßÿ®ÿØÿ£ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ (ÿ≥Ÿäÿ≠ÿØÿ´ Ÿáÿ∞ÿß ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ© ŸÅŸÇÿ∑)
    checkWeatherAndSpeak();
}
// 5. ŸÅŸä ÿßŸÑŸÖÿ±ÿ© ÿßŸÑÿ´ÿßŸÜŸäÿ© ŸàÿßŸÑÿ´ÿßŸÑÿ´ÿ© ÿßŸÑÿ™Ÿä Ÿäÿ≠ÿßŸàŸÑ ŸÅŸäŸáÿß ÿßŸÑŸÉŸàÿØ ÿßŸÑÿπŸÖŸÑÿå
// ÿ≥ŸäŸÅÿ¥ŸÑ ÿßŸÑÿ¥ÿ±ÿ∑ ÿßŸÑÿ£ŸàŸÑ (!window.hasInitializedWeatherSpeaker)
// Ÿàÿ≥Ÿäÿ™ŸÖ ÿ™ÿÆÿ∑Ÿä ÿßŸÑŸÉŸàÿØ ÿ®ÿßŸÑŸÉÿßŸÖŸÑ.

        }

        // --- Fullscreen Toggle ---
        function toggleFullScreen() {
            let elem;
            if (videoPopupContainer.classList.contains('active')) {
                elem = popupPlayer.getIframe();
            } else {
                elem = document.documentElement;
            }

            if (!document.fullscreenElement) {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) { /* Safari */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE11 */
                    elem.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => { 
            // Standard Listeners
            getMyLocationButtonDashboard?.addEventListener('click', centerMapOnUserLocation);
            goToHome1Button?.addEventListener('click', () => calculateAndDisplayRouteTo(HOME1_COORDS));
            goToHome2Button?.addEventListener('click', () => calculateAndDisplayRouteTo(HOME2_COORDS));
            floatingMediaButton?.addEventListener('click', () => switchApp('Media')); 
            floatingMinimizedVideoButton?.addEventListener('click', restoreVideoPopup); // NEW listener
            

    // ... (ÿßŸÑŸÉŸàÿØ ÿßŸÑŸÖŸàÿ¨ŸàÿØ ŸÑÿØŸäŸÉ)
const recitersIframe = document.getElementById('reciters-iframe');
    const iframeSrcButtons = document.querySelectorAll('#screen-Reciters .iframe-src-button');

    if (recitersIframe && iframeSrcButtons.length > 0) {
        iframeSrcButtons.forEach(button => {
            button.addEventListener('click', () => {
                const newSrc = button.dataset.src;
                if (newSrc && recitersIframe.src !== newSrc) {
                    console.log(`Changing iframe src to: ${newSrc}`);
                    recitersIframe.src = newSrc; // Change the iframe source

                    // Update active button state
                    iframeSrcButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                }
            });
        });
    }
    // Initial Calls
   
    Promise.all([fetchFavorites('D'), fetchFavorites('M')]).then(([d, m]) => {
        favoritesD = d;
        favoritesM = m;
    });
migrateChannelData();
    loadGoogleMaps().then(initMap);
    fetchWeatherData(); 
    loadPrayerTimes();
    updateFullDateWidget(); // <-- ÿ£ÿ∂ŸÅ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ± (ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿ£ŸàŸÑŸä)

    // Play welcome message once after a short delay
    setTimeout(playWelcomeMessage, 20000);

    setInterval(fetchWeatherData, 800000); 
    setInterval(updateDigitalClock, 1000); 
    setInterval(determineNextPrayer, 60000);
    setInterval(updateFullDateWidget, 6000000); // <-- ÿ£ÿ∂ŸÅ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ± (ÿ™ÿ≠ÿØŸäÿ´ ÿØŸàÿ±Ÿä)
    setInterval(simulateOtherCarData, 6000);
    setInterval(updateTimerDisplay, 2000);

    // ... (ÿ®ŸÇŸäÿ© ÿßŸÑŸÉŸàÿØ)


            
            // NEW/UPDATED: Event listener for the floating back button
            backToSearchFloatingButton.addEventListener('click', () => {
                // If we are on the suggestions screen AND we have a previous search to go back to...
                if (activeMediaView === 'suggestions' && lastSuccessfulSearchQuery) {
                    searchYouTubeVideos(lastSuccessfulSearchQuery); // ...then re-run that search.
                } else {
                    // Otherwise (i.e., we are on the search results screen), perform the original "back" action.
                    navigateBackToMainSearch();
                }
            });

            startTripFloatingButton?.addEventListener('click', () => { if (appState.destinationSet) calculateAndDisplayRoute(); else showMessageBox('ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ™ÿ≠ÿØŸäÿØ Ÿàÿ¨Ÿáÿ© ÿ£ŸàŸÑÿßŸã.'); }); 
            upload360ImageButton?.addEventListener('click', () => upload360ImageInput.click()); 
            upload360ImageInput?.addEventListener('change', handleImageUpload); 
            reset360ImageButton?.addEventListener('click', resetImageToDefault); 
            document.addEventListener('keydown', handleRemoteControlInput);
            document.addEventListener('fullscreenchange', handleFullScreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullScreenChange); // For Safari
            
            videoPopupCloseButton.addEventListener('click', hideVideoPopup);
            backToPlaylistsFromVideosButton.addEventListener('click', navigateBackToMainSearch);
            backToPlaylistsBottomButton.addEventListener('click', navigateBackToMainSearch);
            backToPlaylistsBottomButtonSearch.addEventListener('click', navigateBackToMainSearch);
            floatingKeyboardButton.addEventListener('click', () => { 
                youtubeSearchInput.readOnly = !youtubeSearchInput.readOnly; 
                if (!youtubeSearchInput.readOnly) {
                    youtubeSearchInput.focus(); 
                } else {
                    youtubeSearchInput.blur();
                    // Return focus to the search button after disabling keyboard
                    setFocus(youtubeSearchButton);
                }
                floatingKeyboardButton.classList.toggle('active-keyboard', !youtubeSearchInput.readOnly); 
                floatingKeyboardButton.classList.toggle('inactive-keyboard', youtubeSearchInput.readOnly); 
            });
            
            // UPDATED: Clear button logic
            clearSearchButton.addEventListener('click', () => {
                youtubeSearchInput.value = ''; // Clear input immediately
                lastSuccessfulSearchQuery = null; // NEW: Clear the last search memory
                navigateBackToMainSearch();
            });

            youtubeSearchInput.addEventListener('focus', () => { if (youtubeSearchInput.value.trim() === '') { resetYoutubeSearchUI(); } });
            youtubeSearchButton.addEventListener('click', () => { const query = youtubeSearchInput.value.trim(); if (query) searchYouTubeVideos(query); else showMessageBox('ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ŸÉŸÑŸÖÿ© ŸÑŸÑÿ®ÿ≠ÿ´.'); });
            
            // UPDATED: Auto-search for Tarteel channel with pre-click effect
            youtubeSearchInput.addEventListener('input', () => {
                const targetText = 'ÿ™ÿ±ÿ™ŸäŸÑ-@TarteelArabic';
                const currentText = youtubeSearchInput.value;

                if (currentText.includes(targetText + ' ')) {
                    // If text with space is present, visually confirm and trigger the click
                    youtubeSearchButton.classList.add('tv-focus'); 
                    setTimeout(() => {
                        youtubeSearchButton.click();
                        // Optional: remove focus style after click to reset state
                        setTimeout(() => youtubeSearchButton.classList.remove('tv-focus'), 100);
                    }, 50);
                } else if (currentText.includes(targetText)) {
                    // If only the text (no space) is present, show pre-click effect
                    youtubeSearchButton.classList.add('tv-focus');
                } else {
                    // If the text is not present, remove the effect
                    youtubeSearchButton.classList.remove('tv-focus');
                }
            });

            // NEW Listeners for Animation and Zoom Controls
            pauseAnimationButton.addEventListener('click', () => {
                document.body.classList.toggle('animation-paused');
                const isPaused = document.body.classList.contains('animation-paused');
                const playIcon = pauseAnimationButton.querySelector('[data-lucide="play"]');
                const pauseIcon = pauseAnimationButton.querySelector('[data-lucide="pause"]');
                playIcon.classList.toggle('hidden', !isPaused);
                pauseIcon.classList.toggle('hidden', isPaused);
            });

            removeCacheButton.addEventListener('click', () => {
                localStorage.clear();
                showMessageBox('ÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™ ÿ®ŸÜÿ¨ÿßÿ≠. ÿ≥Ÿäÿ™ŸÖ ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ.');
                setTimeout(() => {
                    location.reload();
                }, 2000);
            });

            zoomInButton.addEventListener('click', () => {
                if (currentFontSize < maxFontSize) {
                    currentFontSize += fontSizeStep;
                    document.documentElement.style.fontSize = `${currentFontSize}px`;
                }
            });

            zoomOutButton.addEventListener('click', () => {
                if (currentFontSize > minFontSize) {
                    currentFontSize -= fontSizeStep;
                    document.documentElement.style.fontSize = `${currentFontSize}px`;
                }
            });

            // Initial Calls
           
            loadGoogleMaps().then(initMap);
            fetchWeatherData(); 
            loadPrayerTimes();
            setInterval(fetchWeatherData, 300000); 
            setInterval(updateDigitalClock, 1000); 
            setInterval(determineNextPrayer, 60000);
            setInterval(simulateOtherCarData, 2000); // Call the modified simulation
            switchApp('Dashboard'); 
            
            // Play welcome message once after a short delay
            setTimeout(playWelcomeMessage, 1500);

            // --- START: Islamic Daily Reminders Logic ---
            // NEW: Helper functions for managing manual states
            // --- ÿØŸàÿßŸÑ ÿ¨ÿØŸäÿØÿ© ŸÑŸÑÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ÿßŸÑÿ≠ÿßŸÑÿßÿ™ ÿ®ÿ¥ŸÉŸÑ ŸÖÿ≠ŸÑŸä ---

// --- NEW & CORRECTED: Helper functions for managing manual states via Server ---

async function getManualReminderStates() {
    try {
        const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID_REMINDERS}/latest`, {
            headers: {
                'X-Access-Key': JSONBIN_ACCESS_KEY_REMINDERS
            }
        });
        if (!response.ok) {
            console.error('Failed to fetch reminder states:', response.statusText);
            return {};
        }
        const data = await response.json();
        const states = data.record || {};
        
        // If the only thing in the bin is our placeholder, return an empty object
        if (Object.keys(states).length === 1 && states._init) {
            return {};
        }
        return states;

    } catch (error) {
        if (error instanceof SyntaxError) {
             console.log("Bin is likely empty or invalid. Returning default state.");
             return {};
        }
        console.error('Error in getManualReminderStates:', error);
        return {};
    }
}

async function setManualReminderState(reminderId, state) {
    let currentStates = await getManualReminderStates();
    
    if (state === 'auto') {
        delete currentStates[reminderId];
    } else {
        currentStates[reminderId] = state;
    }

    // ‚úÖ THE FIX: If the object becomes empty, add a placeholder
    if (Object.keys(currentStates).length === 0) {
        currentStates = { "_init": true };
    }

    try {
        await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID_REMINDERS}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-Master-Key': JSONBIN_API_KEY
            },
            body: JSON.stringify(currentStates)
        });
    } catch (error) {
        console.error('Error writing to JSONBin:', error);
        showMessageBox('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿ≠ÿßŸÑÿ©.');
    }
    
    // We pass the *real* state (without the placeholder) to the renderer
    if (currentStates._init) {
        renderDailyReminders({});
    } else {
        renderDailyReminders(currentStates);
    }
    closeAllDropdowns();
}

            // NEW: Function to create and manage the dropdown
            function createReminderDropdown(reminderId, parentElement) {
                closeAllDropdowns(); // Close any other open dropdowns first

                const dropdown = document.createElement('div');
                dropdown.className = 'reminder-status-dropdown show';
                dropdown.innerHTML = `
                    <button data-state="active" class="navigable grid-item" tabindex="0">ÿ≠ÿßŸÑŸä</button>
                    <button data-state="completed" class="navigable grid-item" tabindex="0">ŸÖŸÜÿ™ŸáŸä</button>
                    <button data-state="missed" class="navigable grid-item" tabindex="0">ŸÅÿßÿ¶ÿ™</button>
                    <hr class="border-white/10 my-1">
                    <button data-state="auto" class="navigable grid-item" tabindex="0">ÿ™ŸÑŸÇÿßÿ¶Ÿä</button>
                `;
                parentElement.appendChild(dropdown);

                dropdown.querySelectorAll('button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent the main click listener from firing again
                        const state = button.dataset.state;
                        setManualReminderState(reminderId, state);
                    });
                });
                 // Focus the first button in the dropdown
                const firstButton = dropdown.querySelector('button');
                if (firstButton) setFocus(firstButton);
            }

            function closeAllDropdowns() {
                document.querySelectorAll('.reminder-status-dropdown').forEach(d => d.remove());
            }

            // 1. ÿ™ÿπÿ±ŸäŸÅ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ£ÿ∞ŸÉÿßÿ± ŸàÿßŸÑÿπÿ®ÿßÿØÿßÿ™ ŸÖÿπ ÿßŸÑÿ¥ÿ±Ÿàÿ∑ ÿßŸÑÿÆÿßÿµÿ© ÿ®Ÿáÿß
            const dailyReminders = [
    { id: 'adhkar_morning', name: 'ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑÿµÿ®ÿßÿ≠', icon: 'sunrise', isActive: (now, times) => now >= times.Fajr && now < times.Dhuhr, getStartTime: (now, times) => times.Fajr, getEndTime: (now, times) => times.Dhuhr, action: () => { switchApp('Media'); searchYouTubeVideos('ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑÿµÿ®ÿßÿ≠ ŸÉÿßŸÖŸÑÿ©'); } },
    { id: 'salat_duha', name: 'ÿµŸÑÿßÿ© ÿßŸÑÿ∂ÿ≠Ÿâ', icon: 'sun', isActive: (now, times) => { if (!times.Sunrise || !times.Dhuhr) return false; const sunriseTime = new Date(times.Sunrise.getTime() + 20 * 60000); const dhuhrTime = new Date(times.Dhuhr.getTime() - 10 * 60000); return now >= sunriseTime && now < dhuhrTime; }, getStartTime: (now, times) => { if (!times.Sunrise) return null; return new Date(times.Sunrise.getTime() + 20 * 60000); }, getEndTime: (now, times) => { if (!times.Dhuhr) return null; return new Date(times.Dhuhr.getTime() - 10 * 60000); }, action: () => showMessageBox('ÿµŸÑÿßÿ© ÿßŸÑÿ∂ÿ≠Ÿâ ÿ≥ŸÜÿ© ŸÖÿ§ŸÉÿØÿ©ÿå ŸàŸàŸÇÿ™Ÿáÿß ŸÖŸÜ ÿ®ÿπÿØ ÿ¥ÿ±ŸàŸÇ ÿßŸÑÿ¥ŸÖÿ≥ Ÿàÿßÿ±ÿ™ŸÅÿßÿπŸáÿß ŸÇÿØÿ± ÿ±ŸÖÿ≠ ÿ•ŸÑŸâ ŸÇÿ®ŸäŸÑ ŸàŸÇÿ™ ÿµŸÑÿßÿ© ÿßŸÑÿ∏Ÿáÿ±.') },
    { id: 'sunan_rawatib', name: 'ÿßŸÑÿ≥ŸÜŸÜ ÿßŸÑÿ±Ÿàÿßÿ™ÿ®', icon: 'calendar-check', isActive: (now, times) => { if (!times.Fajr || !times.Dhuhr || !times.Maghrib || !times.Isha) return false; const tenMinutes = 10 * 60 * 1000; if (now < times.Fajr && (times.Fajr.getTime() - now.getTime()) <= tenMinutes) return true; if (now < times.Dhuhr && (times.Dhuhr.getTime() - now.getTime()) <= tenMinutes) return true; if (now > times.Dhuhr && (now.getTime() - times.Dhuhr.getTime()) <= tenMinutes) return true; if (now > times.Maghrib && (now.getTime() - times.Maghrib.getTime()) <= tenMinutes) return true; if (now > times.Isha && (now.getTime() - times.Isha.getTime()) <= tenMinutes) return true; return false; }, getStartTime: null, getEndTime: null, action: () => showMessageBox('ÿßŸÑÿ≥ŸÜŸÜ ÿßŸÑÿ±Ÿàÿßÿ™ÿ®: ÿ±ŸÉÿπÿ™ÿßŸÜ ŸÇÿ®ŸÑ ÿßŸÑŸÅÿ¨ÿ±ÿå ÿ£ÿ±ÿ®ÿπ ŸÇÿ®ŸÑ ÿßŸÑÿ∏Ÿáÿ±ÿå ÿ±ŸÉÿπÿ™ÿßŸÜ ÿ®ÿπÿØŸáÿå ÿ±ŸÉÿπÿ™ÿßŸÜ ÿ®ÿπÿØ ÿßŸÑŸÖÿ∫ÿ±ÿ®ÿå Ÿàÿ±ŸÉÿπÿ™ÿßŸÜ ÿ®ÿπÿØ ÿßŸÑÿπÿ¥ÿßÿ°.') },
    { id: 'adhkar_evening', name: 'ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑŸÖÿ≥ÿßÿ°', icon: 'sunset', isActive: (now, times) => now >= times.Asr && now.getHours() < 23, getStartTime: (now, times) => times.Asr, getEndTime: (now, times) => { const d = new Date(now); d.setHours(22, 59, 59, 999); return d; }, action: () => { switchApp('Media'); searchYouTubeVideos('ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑŸÖÿ≥ÿßÿ° ŸÉÿßŸÖŸÑÿ©'); } },
    { id: 'wird_daily', name: 'ÿßŸÑŸàÿ±ÿØ ÿßŸÑŸäŸàŸÖŸä', icon: 'book-marked', isActive: (now, times) => true, getStartTime: null, getEndTime: null, action: () => switchApp('Quran') },
    { id: 'surah_mulk', name: 'ÿ≥Ÿàÿ±ÿ© ÿßŸÑŸÖŸÑŸÉ', icon: 'moon', isActive: (now, times) => now >= times.Isha || now < times.Fajr, getStartTime: (now, times) => times.Isha, getEndTime: (now, times) => { if (now < times.Fajr) return times.Fajr; return new Date(times.Fajr.getTime() + 24 * 60 * 60 * 1000); }, action: () => { switchApp('Media'); searchYouTubeVideos('ÿ≥Ÿàÿ±ÿ© ÿßŸÑŸÖŸÑŸÉ ŸÉÿßŸÖŸÑÿ©'); } },
                { id: 'salat_witr', name: 'ÿµŸÑÿßÿ© ÿßŸÑŸàÿ™ÿ±', icon: 'star', isActive: (now, times) => now >= times.Isha || now < times.Fajr, getStartTime: (now, times) => times.Isha, getEndTime: (now, times) => { if (now < times.Fajr) return times.Fajr; return new Date(times.Fajr.getTime() + 24 * 60 * 60 * 1000); }, action: () => showMessageBox('ÿµŸÑÿßÿ© ÿßŸÑŸàÿ™ÿ± ÿ≥ŸÜÿ© ŸÖÿ§ŸÉÿØÿ©ÿå Ÿàÿ£ŸÇŸÑŸáÿß ÿ±ŸÉÿπÿ© Ÿàÿßÿ≠ÿØÿ©ÿå ŸàŸàŸÇÿ™Ÿáÿß ŸÖŸÜ ÿ®ÿπÿØ ÿµŸÑÿßÿ© ÿßŸÑÿπÿ¥ÿßÿ° ÿ•ŸÑŸâ ÿ∑ŸÑŸàÿπ ÿßŸÑŸÅÿ¨ÿ±.') },
                { id: 'adhkar_sleep', name: 'ŸÇŸäÿßŸÖ ÿßŸÑŸÑŸäŸÑ ', icon: 'bed', isActive: (now, times) => now.getHours() >= 23, getStartTime: (now, times) => { const d = new Date(now); d.setHours(23, 0, 0, 0); return d; }, getEndTime: (now, times) => { const d = new Date(now); d.setHours(23, 59, 59, 999); return d; }, action: () => { switchApp('Media'); searchYouTubeVideos('ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑŸÜŸàŸÖ'); } }
            ];

            // 2. ÿØÿßŸÑÿ© ŸÑÿ•ŸÜÿ¥ÿßÿ° Ÿàÿπÿ±ÿ∂ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© (MODIFIED)
         // ‚úÖ Corrected Version of the function
async function renderDailyReminders(states) { // We added 'async' and 'states' here
    const container = document.getElementById('tv');
    if (!container || !appState.prayerTimes.Fajr || appState.prayerTimes.Fajr === '--:--') return;

    // If no states are passed in, fetch them. Otherwise, use the states that were passed.
    const manualStates = states || await getManualReminderStates(); // We added 'await' here

    const now = new Date();
    const prayerDateTimes = {
        Fajr: timeToDate(appState.prayerTimes.Fajr),
        Sunrise: timeToDate(appState.prayerTimes.Sunrise || '06:15'),
        Dhuhr: timeToDate(appState.prayerTimes.Dhuhr),
        Asr: timeToDate(appState.prayerTimes.Asr),
        Maghrib: timeToDate(appState.prayerTimes.Maghrib),
        Isha: timeToDate(appState.prayerTimes.Isha)
    };

    container.innerHTML = '';
    const grid = document.createElement('div');
    grid.className = 'reminders-grid grid-container'; // Added grid-container for navigation
    grid.id = 'reminders-grid-container';

    dailyReminders.forEach(reminder => {
        const manualState = manualStates[reminder.id];
        let classList = 'reminder-item navigable grid-item';
        let iconName = '';

        if (manualState) {
            classList += ` ${manualState}`;
            switch (manualState) {
                case 'active':    iconName = 'clock'; break;
                case 'completed': iconName = 'check-check'; break;
                case 'missed':    iconName = 'x-circle'; break;
            }
        } else {
            const isActive = reminder.isActive(now, prayerDateTimes);
            let isUpcoming = false;
            if (reminder.getStartTime && !isActive) {
                const startTime = reminder.getStartTime(now, prayerDateTimes);
                if (startTime && startTime > now) { isUpcoming = true; }
            }
            let isCompleted = false;
            if (!isActive && !isUpcoming && reminder.getEndTime) {
                const endTime = reminder.getEndTime(now, prayerDateTimes);
                if (endTime && now > endTime) { isCompleted = true; }
            }

            if (isActive) { classList += ' active'; iconName = 'play-circle'; } 
            else if (isUpcoming) { classList += ' upcoming'; iconName = 'bell'; } 
            else if (isCompleted) { classList += ' completed'; iconName = 'check-check'; } 
            else { iconName = 'circle'; }
        }

        const item = document.createElement('div');
        item.className = classList;
        item.dataset.reminderId = reminder.id;
        item.tabIndex = 0;

        item.innerHTML = `
            <div class="icon-wrapper relative">
                <i data-lucide="${iconName || 'circle'}" class="icon w-12 h-12"></i>
            </div>
            <span class="text">${reminder.name}</span>
        `;
        grid.appendChild(item);
    });

    container.appendChild(grid);
    lucide.createIcons();
}

            // --- ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ¨ÿØŸäÿØ ---
// 3. ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿ≥ÿ™ŸÖÿπ ŸÜŸÇÿ± Ÿàÿßÿ≠ÿØ ŸÑŸÑÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ŸÉŸÑ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± (MODIFIED)
document.addEventListener('click', (e) => {
    const reminderItem = e.target.closest('.reminder-item');
    const dropdownButton = e.target.closest('.reminder-status-dropdown button');

    // ÿ•ÿ∞ÿß ÿ™ŸÖ ÿßŸÑŸÜŸÇÿ± ÿπŸÑŸâ ÿ≤ÿ± ÿØÿßÿÆŸÑ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖŸÜÿ≥ÿØŸÑÿ©ÿå ÿØÿπŸá ŸäÿπŸÖŸÑ (ÿßŸÑŸÖÿ≥ÿ™ŸÖÿπ ÿßŸÑÿÆÿßÿµ ÿ®Ÿá ÿ≥ŸäÿπŸÖŸÑ)
    if (dropdownButton) {
        return;
    }

    // ÿ•ÿ∞ÿß ÿ™ŸÖ ÿßŸÑŸÜŸÇÿ± ÿÆÿßÿ±ÿ¨ ÿπŸÜÿµÿ± ÿ™ÿ∞ŸÉŸäÿ± ŸàÿÆÿßÿ±ÿ¨ ŸÇÿßÿ¶ŸÖÿ© ŸÖŸÜÿ≥ÿØŸÑÿ©ÿå ÿ£ÿ∫ŸÑŸÇ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸàÿßÿ¶ŸÖ
    if (!reminderItem && !e.target.closest('.reminder-status-dropdown')) {
        closeAllDropdowns();
        return;
    }

    // ÿ•ÿ∞ÿß ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑŸÜŸÇÿ± ÿπŸÑŸâ ÿπŸÜÿµÿ± ÿ™ÿ∞ŸÉŸäÿ±ÿå ÿ™ŸàŸÇŸÅ ŸáŸÜÿß
    if (!reminderItem) return;

    // --- ÿßŸÑÿ¨ÿ≤ÿ° ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä ŸÑŸÑÿ™ÿπÿØŸäŸÑ ---
    // ÿ£ŸàŸÇŸÅ ÿßŸÜÿ™ÿ¥ÿßÿ± ÿßŸÑÿ≠ÿØÿ´ ŸÑŸÖŸÜÿπ ÿ£Ÿä ÿ•ÿ¨ÿ±ÿßÿ°ÿßÿ™ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ© ÿ£ÿÆÿ±Ÿâ
    e.stopPropagation();

    const reminderId = reminderItem.dataset.reminderId;
    const iconWrapper = reminderItem.querySelector('.icon-wrapper'); // ÿßÿ®ÿ≠ÿ´ ÿπŸÜ ÿ≠ÿßŸàŸäÿ© ÿßŸÑÿ£ŸäŸÇŸàŸÜÿ©

    if (!iconWrapper) return; // ÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿ≠ÿßŸàŸäÿ© ÿßŸÑÿ£ŸäŸÇŸàŸÜÿ©

    // ÿ™ÿ≠ŸÇŸÇ ŸÖŸÖÿß ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖŸÜÿ≥ÿØŸÑÿ© ŸÑŸáÿ∞ÿß ÿßŸÑÿπŸÜÿµÿ± ŸÖŸÅÿ™Ÿàÿ≠ÿ© ÿ®ÿßŸÑŸÅÿπŸÑ
    const existingDropdown = reminderItem.querySelector('.reminder-status-dropdown');

    if (existingDropdown) {
        // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ŸÖŸÅÿ™Ÿàÿ≠ÿ©ÿå ÿ£ÿ∫ŸÑŸÇŸáÿß
        existingDropdown.remove();
    } else {
        // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ŸÖÿ∫ŸÑŸÇÿ©ÿå ÿ£ÿ∫ŸÑŸÇ ÿ£Ÿä ŸÇŸàÿßÿ¶ŸÖ ÿ£ÿÆÿ±Ÿâ ŸàÿßŸÅÿ™ÿ≠ Ÿáÿ∞Ÿá ÿßŸÑŸÇÿßÿ¶ŸÖÿ©
        closeAllDropdowns(); // ÿ£ÿ∫ŸÑŸÇ ÿßŸÑŸÇŸàÿßÿ¶ŸÖ ÿßŸÑÿ£ÿÆÿ±Ÿâ ÿ£ŸàŸÑÿßŸã
        createReminderDropdown(reminderId, iconWrapper); // ÿßŸÅÿ™ÿ≠ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ© ÿ®ÿßŸÑŸÜÿ≥ÿ®ÿ© ŸÑÿ≠ÿßŸàŸäÿ© ÿßŸÑÿ£ŸäŸÇŸàŸÜÿ©
    }
    // --- ŸÜŸáÿßŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ ---

    // ÿ™ŸÖ ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ¨ÿ≤ÿ° ÿßŸÑÿÆÿßÿµ ÿ®ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä (ŸÖÿ´ŸÑ ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ŸäŸàÿ™ŸäŸàÿ®)
});
            
            renderDailyReminders(); // ÿßŸÑÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿßŸÑÿ£ŸàŸÑ
            setInterval(renderDailyReminders, 60000); // ÿ™ÿ≠ÿØŸäÿ´ ŸÉŸÑ 60 ÿ´ÿßŸÜŸäÿ©
        });

        // --- Athkar App Logic ---
        const tabSabah = document.getElementById('tab-sabah');
        const tabMasaa = document.getElementById('tab-masaa');
        const athkarSabahContent = document.getElementById('athkar-sabah-content');
        const athkarMasaaContent = document.getElementById('athkar-masaa-content');
        const tabMonthly = document.getElementById('tab-monthly');
        const athkarMonthlyContent = document.getElementById('athkar-monthly-content');

        if (tabSabah && tabMasaa && athkarSabahContent && athkarMasaaContent && tabMonthly && athkarMonthlyContent) {
            tabSabah.addEventListener('click', () => {
                tabSabah.classList.add('active');
                tabMasaa.classList.remove('active');
                tabMonthly.classList.remove('active');
                athkarSabahContent.classList.remove('hidden');
                athkarMasaaContent.classList.add('hidden');
                athkarMonthlyContent.classList.add('hidden');
                setFocus(tabSabah); // Keep focus on the active tab
            });

            tabMasaa.addEventListener('click', () => {
                tabMasaa.classList.add('active');
                tabSabah.classList.remove('active');
                tabMonthly.classList.remove('active');
                athkarMasaaContent.classList.remove('hidden');
                athkarSabahContent.classList.add('hidden');
                athkarMonthlyContent.classList.add('hidden');
                setFocus(tabMasaa); // Keep focus on the active tab
            });

            tabMonthly.addEventListener('click', () => {
                tabMonthly.classList.add('active');
                tabSabah.classList.remove('active');
                tabMasaa.classList.remove('active');
                athkarMonthlyContent.classList.remove('hidden');
                athkarSabahContent.classList.add('hidden');
                athkarMasaaContent.classList.add('hidden');
                setFocus(tabMonthly);
            });
        }
    </script>
</body> 
</html>
